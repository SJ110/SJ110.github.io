<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
        background: #1E92FB; /*��������ɫ*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*��Ӱ��ɫ*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*�ϱ߿���ɫ*/
        border-left-color: #1E92FB;    /*��߿���ɫ*/
    }
</style>
  <meta name="description" content="前言此次复习主要参考侯捷翻译的《STL源码剖析》之前一段时间已经看过一遍STL，但是有些东西总是会忘记，为了加深记忆，也为了之后秋招着想，最近一天再将这本书过一遍，相信再看第二遍的时候一定会有不一样的收获，之前没有看的时候没有加入任何笔记，好在这次可以记录在博客里，一些我认为已经不必要或者我已经记的很清楚的东西将不再重复。我会按照章节来进行复习。当然，这本书也包括了c++和c中各方面的知识，我所能">
<meta name="keywords" content="STL">
<meta property="og:type" content="article">
<meta property="og:title" content="STL复习">
<meta property="og:url" content="http://yoursite.com/2019/08/21/STL源码剖析复习/index.html">
<meta property="og:site_name" content="xiaopingpp">
<meta property="og:description" content="前言此次复习主要参考侯捷翻译的《STL源码剖析》之前一段时间已经看过一遍STL，但是有些东西总是会忘记，为了加深记忆，也为了之后秋招着想，最近一天再将这本书过一遍，相信再看第二遍的时候一定会有不一样的收获，之前没有看的时候没有加入任何笔记，好在这次可以记录在博客里，一些我认为已经不必要或者我已经记的很清楚的东西将不再重复。我会按照章节来进行复习。当然，这本书也包括了c++和c中各方面的知识，我所能">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/08/21/STL源码剖析复习/rongqi.jpg">
<meta property="og:image" content="http://yoursite.com/2019/08/21/STL源码剖析复习/deque.jpg">
<meta property="og:image" content="http://yoursite.com/2019/08/21/STL源码剖析复习/set1.png">
<meta property="og:image" content="http://yoursite.com/2019/08/21/STL源码剖析复习/mapandset.png">
<meta property="og:image" content="http://yoursite.com/2019/08/21/STL源码剖析复习/hash.png">
<meta property="og:updated_time" content="2019-09-23T04:53:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="STL复习">
<meta name="twitter:description" content="前言此次复习主要参考侯捷翻译的《STL源码剖析》之前一段时间已经看过一遍STL，但是有些东西总是会忘记，为了加深记忆，也为了之后秋招着想，最近一天再将这本书过一遍，相信再看第二遍的时候一定会有不一样的收获，之前没有看的时候没有加入任何笔记，好在这次可以记录在博客里，一些我认为已经不必要或者我已经记的很清楚的东西将不再重复。我会按照章节来进行复习。当然，这本书也包括了c++和c中各方面的知识，我所能">
<meta name="twitter:image" content="http://yoursite.com/2019/08/21/STL源码剖析复习/rongqi.jpg">



  <link rel="alternate" href="/atom.xml" title="xiaopingpp" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://yoursite.com/2019/08/21/STL源码剖析复习/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>STL复习 | xiaopingpp</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiaopingpp</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/21/STL源码剖析复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xiaopingpp">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaopingpp">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">STL复习

              
            
          </h1>
        

        <div class="post-meta">

          
            <i class="fa fa-thumb-tack"></i>
            <font color="7D26CD">top</font>
            <span class="post-meta-divider">|</span>
          

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-21 09:38:12" itemprop="dateCreated datePublished" datetime="2019-08-21T09:38:12+08:00">2019-08-21</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-23 12:53:24" itemprop="dateModified" datetime="2019-09-23T12:53:24+08:00">2019-09-23</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">14k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">13 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>此次复习主要参考侯捷翻译的《STL源码剖析》</code></pre><p>之前一段时间已经看过一遍STL，但是有些东西总是会忘记，为了加深记忆，也为了之后秋招着想，最近一天再将这本书过一遍，相信再看第二遍的时候一定会有不一样的收获，之前没有看的时候没有加入任何笔记，好在这次可以记录在博客里，一些我认为已经不必要或者我已经记的很清楚的东西将不再重复。我会按照章节来进行复习。当然，这本书也包括了c++和c中各方面的知识，我所能做的就是尽量理解透彻当前我所知道的那部分。有些东西还是需要慢慢积累的。</p>
<a id="more"></a> 

<h3 id="第一章-STL概论于版本简介"><a href="#第一章-STL概论于版本简介" class="headerlink" title="第一章 STL概论于版本简介"></a>第一章 STL概论于版本简介</h3><h4 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h4><p> <strong>1.容器</strong> 指STL中的各种数据结构，比如 vector list deque map set等，这些容器中已经封装了各种各样的算法，从实现的角度看属于一种类模板（class template）</p>
<p><strong>2.算法</strong> 算法中包括了很多STL中常用的一些，比如 sort search copy等，从实现的角度看STL算法是函数模板（function template）还有一些很简单的算法，但是其实现机制也是相当简单，大致就是你觉得这个算法你也可以实现，而且你的方法也很简单了，但是这个算法的源码却是更加简单，可以这么说——他想尽一切办法来减少内存和提升速度。</p>
<p><strong>3.迭代器</strong> 迭代器是连接在算法和容器之间的桥梁，是一种泛型指针，在STL迭代器是重载了 <em>*operator</em> operator-&gt; operator++ operator– **等相关操作的 class template，类比之后，原生指针（int * 等）也是一种迭代器，迭代器也是一种智能指针。</p>
<p><strong>4.仿函数</strong> 行为类似函数，可作为算法的某种策略，这个当时我也没太关注，之后需要好好注意一下。</p>
<p><strong>5.配接器</strong> 是一种用来修饰容器或者仿函数，迭代器的东西，比如stack和queue，<del>priority_queue</del>，虽然表面看是一种容器，但是底层完全是依靠deque的结构特性来实现的。</p>
<p><strong>6.配置器</strong> 主要是完成STL内存空间的管理和配置。</p>
<h4 id="GNU源码开放精神"><a href="#GNU源码开放精神" class="headerlink" title="GNU源码开放精神"></a>GNU源码开放精神</h4><p>STL的实现版本有多种，但是全世界所有的STL的实现版本都源于 <strong>Alexander Stepanov和 Meng Lee</strong>完成的原始版本，每一个头文件都有一个声明，这份原始版本由惠普公司拥有，允许任何人任意运用，修改，拷贝传播，贩卖这些代码，唯一条件是将这份声明加入新开发的文件内。</p>
<p>STL的版本由很多，有兴趣的可以去找一下，本书使用的是<strong>SGI STL</strong>这个版本。</p>
<h4 id="STL中一些c-语法"><a href="#STL中一些c-语法" class="headerlink" title="STL中一些c++语法"></a>STL中一些c++语法</h4><ol>
<li>静态常量数据成员在类内部直接初试化。</li>
<li>迭代器的++/– 因为STL中各种容器需要根据自身的特性完成迭代器的移动，所以，不同的容器会对迭代器进行不同的运算符重载。</li>
<li><strong>[ )</strong>表示法，这一点是我认为比较重要的，这一点直接表示了在STL中 back和end的区别，在STL中所有区间都是一个前闭后开的区间，因此end一般指最后一个元素的下一位置，而back刚好指向最后一个元素，同样的思维可以和erase算法比较<del>（现在记不太清）</del>。</li>
</ol>
<h3 id="第二章-空间配置器"><a href="#第二章-空间配置器" class="headerlink" title="第二章 空间配置器"></a>第二章 空间配置器</h3><p>空间配置这部分其实在使用STL时都会很少注意到，但是这也是使得STL可以完美运行的底层必要的东西。</p>
<p>说到空间配置就需要提allocator（内存配置器），下面列出STL中allocator的一些接口，可以从命名中看出这些接口的特性。</p>
<ol>
<li>allocator::value_type</li>
<li>allocator::pointer</li>
<li>allocator::const_pointer</li>
<li>allocator::reference</li>
<li>allocator::const_reference</li>
<li>allocator::size_type</li>
<li>allocator::difference_type</li>
<li>allocator::rebind</li>
</ol>
<p>值得注意的是SGI配置并不是上述的allocator，其名称是alloc，而且其中缺省的就是使用alloc配置器这一点是与其他版本STL不同之一，至于理由就是认为allocator效率不如alloc，allcator只是将c++中的new和delete做了一层简单的封装而已。</p>
<p>一般来讲，我们习惯的内存配置是这样的， </p>
<pre><code>class A{};
A* tmp=new A;
delete tmp;</code></pre><p>这其中的顺序是，new分配内存，然后构造类对象，删除时则是先调用析构函数将对象析构，然后使用delete释放空间。在STL allocator中这两步分开由 内存配置alloc：：allocate（）和内存释放由alloc：：deallocate()完成。对象构造由：：construct()完成，对象析构由：：destroy（）完成。</p>
<h4 id="空间的配置与释放"><a href="#空间的配置与释放" class="headerlink" title="空间的配置与释放"></a>空间的配置与释放</h4><p>前面已经说过，对象构造前的空间配置和对象析构后的空间释放由alloc完成，其设计如下：</p>
<ol>
<li>向system heap（堆）申请内存</li>
<li>考虑多线程状态（不太明白，本书没讲）</li>
<li>考虑内存不足时的应变措施</li>
<li>考虑过多小型区块造成的内存碎片问题。</li>
</ol>
<p>c++和c的内存分配分别是 new/malloc ，释放则是 delete/free,而在SGI STL中设计了双层的空间配置器，第一级使用malloc和free，第二级则采用如下策略：</p>
<p><strong>当配置区块超过128bytes时，认为空间足够大，使用第一级配置<br>器，当小于128bytes时，认为过小，使用memory pool处理方式，不再使用第一级配置器。</strong></p>
<p>STL空间配置第一级配置以malloc，free，relloc来执行，不是直接运用C++ new-handler机制（new-handler机制是：要求系统在内存配置需求无法被满足时，调用一个你所指定的函数，在此处大意为，在new无法满足内存需求，抛出bad_alloc之前,会先调，用客户端指定的函数）</p>
<p>按上述的话，当第一级空间配置无法满足或者分配空间小于128bytes时，就会调用第二级空间配置器。第二级空间配置的做法是以内存池管理，每次配置一大块内存，并维护对应的自由链表（free-list），下次如果有相同大小的需求，直接从free-list中拨出，如果客户端释放小额区块，就有配置器返还到free-list中。free-list维护16个节点，每个节点各自管理8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128bytes的大小空间。如果free-list中也没有可用区块，需要调用refill（）进行填充，其新取得的空间来自内存池，缺省为20个节点，也可能小于20个。如果内存池中也无法取得足够的空间，同时堆中的空间也不足，那将无法解决申请空间的问题，</p>
<h3 id="第三章-迭代器概念与traits编程技法"><a href="#第三章-迭代器概念与traits编程技法" class="headerlink" title="第三章 迭代器概念与traits编程技法"></a>第三章 迭代器概念与traits编程技法</h3><p>iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器的各个元素，而又无需暴露出容器的表述方式。</p>
<p>iteartor是一种smart pointer。关于smart pointer可以参考其他博客，不过之后我也会复习到。大概就是智能指针也是一个类，极大的帮助编写人员减小内存泄漏的问题。</p>
<h4 id="模板偏特化的意义"><a href="#模板偏特化的意义" class="headerlink" title="模板偏特化的意义"></a>模板偏特化的意义</h4><p> 如果class template 拥有两个或以上的参数，我们可以对其中某个但不是全部的template参数进行偏特化，换句话说，我们可以在泛化设计中提供一个特化版本。</p>
<p>根据经验，最常用到的迭代器类型有五种， value type，difference type， pointer，reference，iterator catagory</p>
<ol>
<li>value type指的是迭代器所指对象的型别，任何一个class中用到了 STL，就需要定义自己的value type。</li>
<li>difference type表示两个迭代器之间的距离，因此也可表示容器的最大容量。</li>
<li>iterator_catagory根据不同容器的移动特性和操作，分为下面几类</li>
</ol>
<p>input iterator：迭代器所指对象只读</p>
<p>output iterator：迭代器所指对象只写</p>
<p>forward iterator：可以向前移动，且可读可写</p>
<p>bidirectional iterator：可双向移动，</p>
<p>random iterator： 具有算术能力，可以随机访问比如vector的迭代器</p>
<h3 id="第四章-序列式容器"><a href="#第四章-序列式容器" class="headerlink" title="第四章 序列式容器"></a>第四章 序列式容器</h3><p>stl中各种容器关系如下：</p>
<p><img src="/2019/08/21/STL源码剖析复习/rongqi.jpg" alt="rongqi"><br>序列式容器指容器中元素都可序但未必是有序的。比如 array，vector，list deque。</p>
<h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p><strong>note</strong>:8.22更新</p>
<p>由于array不属于STL的一部分，在此就不过多讲述，但是vector和array是比较相似的，差别在于array是静态的空间，一旦配置了大小就不能在改变，而vector比较灵活。<strong>空间配置是一个较大耗费时间的工程，分为（配置新空间，数据移动，释放旧空间）。所以在vector中增加空间时一般都是按照当前空间大小的两倍来增加。</strong></p>
<h5 id="vector迭代器"><a href="#vector迭代器" class="headerlink" title="vector迭代器"></a>vector迭代器</h5><p>根据vector的性质，其维护的是一段连续空间，需要能够访问其中任意一个元素，按前面迭代器的类型可知使用的是random iterator，可以进行算术运算。</p>
<h5 id="vector数据结构"><a href="#vector数据结构" class="headerlink" title="vector数据结构"></a>vector数据结构</h5><p>大致形式如下：</p>
<pre><code>class vector{
...
protected:
iterator start; //当前使用空间头部
iterator finish;//当前使用空间尾部
iterator end_of_storage; //当前可用空间尾部
...
}</code></pre><p>所以vector的容量（capacity）永远大于或等于其大小。如果容量等于大小，当扩充大小时就需要—配置新空间，数据移动，释放旧空间。将空间扩展为当前的两倍，然后移动数据，释放原空间，如果两倍不够，则获取更大的空间。</p>
<h5 id="vector-元素操作"><a href="#vector-元素操作" class="headerlink" title="vector 元素操作"></a>vector 元素操作</h5><p>vector元素操作很多，这里整理其中一部分，<br>首先区别 </p>
<pre><code>capacity（）//大于等于size（）
size（） //当前元素的个数</code></pre><p>pop_back()</p>
<pre><code>{
    --finish;//finish指向最后元素的下一位置
    destroy(finish); //释放空间
}</code></pre><p>erase（）</p>
<pre><code> //删除范围内所有元素
iterator erase(iterator first, iterator last)    
{
    iterator i= copy(last,finish,first);
    destroy(i,finish); //析构对象，空间仍可用
    finish= finish-(last-first);
    return first;
}

//删除指定元素
iterator erase(iterator pos){
    if((pos+1)!=end()) //不是最后一个元素，吧后面的元素向前移动
        copy(pos+1,finish,pos);
    --finish；
    destroy(finish); 
    return pos;//返回删除元素的后一个元素
}</code></pre><p>insert（postion,n,x）//在postion插入n个x元素，返回position<br><strong>需要注意的一点是STL的规范插入节点应该在所指position（节点）的前方。</strong></p>
<p>clear（），清空所有对象，但是空间任然可用。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p> 顾名思义，list就是链表，不过STL的list是双向链表，且其中有list迭代器，结合链表的特性，删除和插入元素都是常数时间复杂度。</p>
<p>list节点：</p>
<pre><code>template&lt;class T&gt;
 struct _list_node{
    typedef void* pointer;
    void_pointer pre;
    void_pointer next;
    T data;    
}</code></pre><p>从节点设计也可以看出是双向链表，考虑其迭代器，需要访问其中的任意数据，但是空间不是连续的，所以无法进行算术运算，由于本质是双向链表，所以能前后移动，使用bidirectional iterator。<strong>由于地址空间不是连续的，所以插入和删除操作不会造成后续的迭代器失效，删除操作也只会造成被删除的那个迭代器失效</strong>，这是list的一个特征。</p>
<p>更特别的是SGI STL的list是双向循环链表，为了表示前闭后开区间，最后一个元素的数据域为空，而且只需要一个iterator就可以遍历整个list。</p>
<h5 id="list-元素操作"><a href="#list-元素操作" class="headerlink" title="list 元素操作"></a>list 元素操作</h5><p>下面简述部分list中的操作</p>
<pre><code>//插入一个头节点
void push_front(const T&amp;x){
    insert(begin(),x);//insert的一种重载方式
}

//插入一个尾节点
void push_back(const T&amp;x){
    insert(end(),x);//end()是最后一个元素下一个位置
}

//移出迭代器所指节点
iterator erase(iterator pos){
    ....
    //于链表操作一致
    return iterator（next_pos）;//返回下一个节点
}

void pop_front()//移出头节点
void pop_back()//移出尾节点
void list&lt;T,Alloc&gt; ::remove(const T&amp; x);//移出值为x的节点

void list&lt;T,Alloc&gt;:: unique();//移出连续且相同元素中多个，只留下一个

void list&lt;T,Alloc&gt;:: reverse();//数据翻转
void list&lt;T,Alloc&gt;::sort();// STL 算法提供的sort必须传入随机访问迭代器 ，这是list自己的sort</code></pre><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>和vector做对比，vector是单向开口的连续序列，deque是双向开口的连续序列。的却相较于vector的最大优点就是可以常数时间内在头部进行插入。而且deque没有容量的概念，他是动态的以分段连续的空间组合起来的。原书中如下讲述：** 虽然deque也提供random access iterator，但是他的迭代器比较复杂，如非必要，尽量使用vector代替deque，deque的sort操作，为了提高效率，是先复制到vector中再排序，然后复制回deque中。</p>
<h5 id="deque构造"><a href="#deque构造" class="headerlink" title="deque构造"></a>deque构造</h5><p>deque采用连续分段的map（不是STL中的map）作为主控，每个map中的节点指向一块连续的线性空间，该空间才是deque主要存储区。</p>
<p>结构如下：<br>    template&lt;class T,Alloc=alloc,size_t BufSize=0&gt;<br>    class deque{<br>    public：<br>    typedef T value_type;<br>    typedef value_typ* pointer;<br>    …<br>    protected:<br>    typedef pointer map_pointer;<br>    map_pointer map; //指向连续空间，其中每个空间都是一个指向缓冲区的指针<br>    size_type map_size; //map内可容纳的指针<br>    }</p>
<p><img src="/2019/08/21/STL源码剖析复习/deque.jpg" alt="deque1"></p>
<h5 id="deque迭代器"><a href="#deque迭代器" class="headerlink" title="deque迭代器"></a>deque迭代器</h5><p>为了维持“整体连续”，deque的迭代器需要实现operator–和operator++的功能，结合deque的结构，为了保证一个缓冲区满后可以跳到相邻的另一个缓冲区，必须管理好其中的map</p>
<h5 id="deque元素操作"><a href="#deque元素操作" class="headerlink" title="deque元素操作"></a>deque元素操作</h5><p><strong>deque可以使用随机访问迭代器，注意其和vector的差别在于表面上是连续存储，可以双端插入数据</strong></p>
<table>
    <thead>
        <tr>
            <th>方法</th>
            <th>含义</th>

<pre><code>    &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
    &lt;tr&gt;
        &lt;td&gt;push_back&lt;/td&gt;
        &lt;td&gt;在末尾加入一个元素&lt;/td&gt;

    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;push_front&lt;/td&gt;
        &lt;td&gt;再deque首部加入一个元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;pop_back&lt;/td&gt;
        &lt;td&gt;在deque末尾删除一个元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;pop_front&lt;/td&gt;
        &lt;td&gt;删除deque首部的一个元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;emplace_front&lt;/td&gt;
        &lt;td&gt;在deque开头插入一个新元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;emplace_back&lt;/td&gt;
        &lt;td&gt;在deque末尾插入一个新元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;erase&lt;/td&gt;
        &lt;td&gt;可重载，删除某个元素或者删除某个区间的元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;insert&lt;/td&gt;
        &lt;td&gt;在某个位置之前插入一个元素&lt;/td&gt;
    &lt;/tr&gt;
&lt;/tbody&gt;</code></pre></tr></thead></table>

<h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>stack是一种后进先出的数据结构，只有一端开口，在本书中，采用deque作为底层的结构，构造stack，也可以使用list构造stack，list和deque一样都是两端开口的，只要保证使用时指开启一段即可。<br>主要元素操作：</p>
<pre><code>push()//向stack中推入一个元素
pop()//取出栈顶元素
top() //获取栈顶元素
size() //获取元素个数
empty() //判断栈空</code></pre><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>queue是一种先进先出的数据结构有两个开口，结合前面说述，SGI STL底层使用deque是西安queue，可以说完成了queue的所有性能，与stack相同，queue也没有迭代器，只能从一段进，另一端出。支持的元素操作</p>
<pre><code>push()//向queue中推入一个元素
pop()//取出栈顶元素
front() //获取栈顶元素
size() //获取元素个数
empty() //判断栈空
back() //获取尾端元素</code></pre><h4 id="heap概述"><a href="#heap概述" class="headerlink" title="heap概述"></a>heap概述</h4><p>heap并不是stl中的容器或者配接器，但是他是是西安priority_queue（优先）的助手，优先队列是指队列首部元素永远是其中的极值元素。要实现优先队列需要实现堆算法</p>
<h5 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h5><p>堆分为max heap 和min heap，下面以maxheap为例，整个堆算法包裹 push_heap  pop_heap sort_heap</p>
<p><strong>pushheap:</strong><br>push_heap所形成的是完全二叉树，要实现大顶堆，每次新加入的元素都是在最下一层的叶节点，新元素是否属于这个位置（每个节点的值都大于或者等于子节点的值），每次加入一个新节点就进行上溯，与其父节点比较，大就对换位置，直到不能换位置即可。<strong>注意任意节点（i）的父节点可表示(i((i-1)/2).</strong></p>
<p><strong>popheap:</strong></p>
<p>前面实现的大顶堆只有根节点是最大的，要保证每次取出一个节点后剩余节点最大值也在根节点，需要进行popheap，具体做法是：**每次循环取出一个最大元素后，将其和末尾元素（最后一个叶子节点交换），同时堆的大小减1，此时将堆进行调整，比较其和子节点大小，并交换其位置，直到对末尾。（注意此时堆的大小已经变化）。整个完成后便从小到大排好了序。</p>
<p><strong>sortheap：</strong></p>
<p>按前面所述，只要完成了pushheap popheap,每次减小堆大小最后就可以实现堆排序。</p>
<p>heap不提供迭代器，但是可以使用algorithm中实现的堆算法进行排序</p>
<pre><code>make_heap() //构造一个大顶堆
push_heap() //向堆中加入元素，同时保证大顶堆的特性
pop_heap() //从堆中取出一个元素，同时保证大顶堆的特性
sort_heap() //进行堆排序</code></pre><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><p>优先队列，有heap构成，没有迭代器，处于最顶端的元素是最大值或者最小值,缺省使用vector作为底层容器。</p>
<p>支持的部分元素操作：</p>
<pre><code>empty() //是否为空
size() //大小
top() //获取首部元素
push() //向尾部插入元素，且保证队列的优先特性
pop() //取出末尾元素，</code></pre><h4 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h4><p>STL list 是一个双向链表，slist是单项链表，考虑到器结构特性，只能向后遍历数据，因此其迭代器的类型是forward iterator，指向slit的首节点，因此slist一般只适合在头部进行元素的插入。所以插入的元素顺序会和slist表现出来的顺序相反。</p>
<p>slist元素操作与我们构造的链表操作差别不大，其中表头是一个不含元素的空节点，这样方便在head部分插入元素。</p>
<p>元素操作：</p>
<pre><code>push_front() //头部插入元素
size() //元素个数
find() //查找某个元素
insert() //插入元素</code></pre><h3 id="第六章-关联式容器"><a href="#第六章-关联式容器" class="headerlink" title="第六章 关联式容器"></a>第六章 关联式容器</h3><p>关联式容器分为set和map两大类，以及衍生出的multiset,multimap,这些容器底层均以红黑树完成。 红黑树也是一个独立容器，但不开放给外界使用</p>
<p>SGI STL还提供了一个不再标准规格内的关联式容器，hashtable， 以及以hashtable为底层的hashmap和hashset  hash_multiset, hash_multimap</p>
<p>关联式容器类似关联数据库，每一笔数据都有一个key和value，内部以找key的值放于适当位置，因此没有头和尾部，也就没有 push_back(),push_front() pop_back() 等元素操作。</p>
<h4 id="树的导览"><a href="#树的导览" class="headerlink" title="树的导览"></a>树的导览</h4><p><strong>二叉搜索树</strong> </p>
<p>是指可提供对数时间的元素插入和访问，二叉搜索树的防止规则是：任何节点的键值一定大于左孩子的键值且小于右孩子的键值。因此一致往左走，走到最后可得到最小值，一直往右走，走到最后可得到最大值。</p>
<p><strong>平衡二叉搜索树(AVL树)</strong></p>
<p>平衡二叉树：它是一棵空树或者左右两个子树的高度差的绝对值不超过1，并且左右子树都是一棵平衡二叉树。</p>
<p>AVL树： 树的每个左子树和右子树都是AVL树</p>
<p>左子树与右子树高度之差的绝对值不超过1</p>
<p>每一个节点都有一个平衡因子（balance factor），任一节点的平衡因子是-1、0、1（每一个节点的平衡因子 = 右子树高度 - 左子树高度）</p>
<p>当插入新的节点后可能会破坏原有树的平衡性，需要进行调整，即进行节点旋转。</p>
<p><strong>红黑树</strong></p>
<p>是一个二叉搜索树，且满足1.每个节点不是红色就是黑色，2.根节点为黑色<br>3.如果节点为红色，那么其子节点为黑色.4.任一个节点至NULL的任何路径所包含的黑色节点数相同。</p>
<p><strong>2019.9.6补充</strong></p>
<p>相比于AVL,红黑树不是严格平衡的，在多次插入元素后，AVL树的效率编得低下，当AVL删除元素时，需要维护这条路径上被影响的所有节点，复杂度为O(logn).而RB树每次插入/删除元素只需最多三次旋转。</p>
<h5 id="RBtree-迭代器"><a href="#RBtree-迭代器" class="headerlink" title="RBtree 迭代器"></a>RBtree 迭代器</h5><p>RBtree迭代其属于双向迭代器，但不具备随机定位的能力，因此其迭代器的类型应该是bidirectional iterator</p>
<h5 id="RBtree元素操作"><a href="#RBtree元素操作" class="headerlink" title="RBtree元素操作"></a>RBtree元素操作</h5><p>RBtree提供两种元素操作， insert_unique(),insert_equal();</p>
<p><strong>insert_equal()</strong></p>
<p>插入新值，节点键值允许重复。</p>
<p><strong>insert_unique()</strong></p>
<p>插入新值，节点键值不允许重复，返回一个pair，第一个元素是RBtree的迭代器，第二个元素表示插入成功与否。</p>
<p>在RBtree中每次插入元素后都需要进行调整，保证树的状态符合RBtree的要求。</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>set的特性是只有一个键值，且键值就是实值。set不允许右两个元素相同的键值。不可以通过set的迭代器改变set的元素值。元素值关系到set的排序规则。 因此set的迭代器是一种 constant iterator（<strong>只读</strong>）。set和list有相同之处。在增加或者删除元素后，其余迭代器都是有效的。</p>
<p>由于底层是RBtree，所以有很好的排序效果。</p>
<pre><code>int main(){
set&lt;int&gt; test;
test.insert(5);
test.insert(7);
test.insert(2);
test.insert(-1);
test.insert(18);
test.insert(6);
test.insert(1);
test.insert(15);
for (auto it = test.begin(); it != test.end();it++)

    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
return 0;</code></pre><p><img src="/2019/08/21/STL源码剖析复习/set1.png" alt="set1"></p>
<p>其中元素已经自动排好序了。</p>
<p>由于map和set性质类似，元素操作也类似，放在后面一起讲述</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map特性是根据元素键值自动排序，map所有元素都是pair，同时拥有key和value，可以通过pair访问每一个元素的key和value同时不可以通过map迭代器修改map的元素内容，因此内部迭代器也是 constant iterator（<strong>只读</strong>）<br>元素操作如下：</p>
<p><img src="/2019/08/21/STL源码剖析复习/mapandset.png" alt="mapset"></p>
<p>同时也有如下操作：</p>
<pre><code>size() //返回元素个数
empty（） //是否为空
operator[]() //map独有 可以访问key和value</code></pre><p>multiset和multimap结构与上述完全一致，只是其中可以插入相同的元素。在此不再赘述。</p>
<h4 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h4><p>hashtable优点在于在插入，删除，查找等方面也有常数的平均时间复杂度。不过其底层是通过hash算法实现的，底层hashmap和hashset的操作也map set类似，综合总结如下：</p>
<p><img src="/2019/08/21/STL源码剖析复习/hash.png" alt="hash"></p>
<p>其元素操作也与上述map，set类似，不再赘述。<strong>需要注意的是以hashtable为底层机制实现的容器，其元素并未有序。</strong></p>
<p><strong>Note: 2019.9.10更新</strong></p>
<p>TreeMap是基于树（红黑树）的实现方式，即添加到一个有序列表，在O(log n)的复杂度内通过key值找到value，优点是空间要求低，但在时间上不如HashMap。C++中Map的实现就是基于这种方式HashMap是基于HashCode的实现方式，在查找上要比TreeMap速度快（o(1)），添加时也没有任何顺序，但空间复杂度高。C++ unordered_Map就是基于该种方式。</p>
<p>hashmap原理：1. 哈希表的优点在于把数据存储和消耗的时间大大降低，与之对应的代价是空间的消耗。 2. 基本原理：使用一个下标比较大的数组来存储元素，设计一个哈希函数（散列函数），使得每个元素值都和下标对应。但是这样并不能保证每个元素（value）和关键字（key）一一对应，可能会出现对不同的元素计算出相同的函数值，这样就导致了冲突。</p>
<p>hash表解决冲突的方式： 1.线性探测法：在发生冲突时从发生冲突的位置向下一个单元移动，直到下以恶搞单元为空时将元素插入。 2. 平方探测法：若当前key与原来key产生相同的哈希地址，则当前key存在该地址后偏移量为（1,2,3…）的二次方地址处</p>
<p>key1：hash(key)+0</p>
<p>key2：hash(key)+1^2</p>
<p>key3：hash(key)+2^2</p>
<p>3.再哈希法： 同时构造多个哈希函数，Hi=RHi(key) i=1,2,3,k….当H1=RH1(key)发生冲突时，再用H2=RH2（key）计算，直到不产生冲突。 4. 链地址法：将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针放在哈希表的单元格中，查找，插入和删除都在链表中进行。适用于进程进行删除和插入的情况。</p>
<h3 id="算法概观"><a href="#算法概观" class="headerlink" title="算法概观"></a>算法概观</h3><p>下面简述部分STL中的一些算法。</p>
<p>质变算法：指运算过程中会改变区间内元素内容，比如排序，删除等。</p>
<p>非质变算法：不改变操作对象的值，比如查找，计数等。</p>
<h4 id="泛化算法"><a href="#泛化算法" class="headerlink" title="泛化算法"></a>泛化算法</h4><p>find()</p>
<pre><code>template&lt;class Iterator,class T&gt;
Iterator find(Iterator begin,Iterator end,const&amp;value){
    while(begin!=end &amp;&amp; *begin!=value)
        begin++;
    return  begin;
}</code></pre><p>equal() //如果两个序列在 [first,last) 间相等， 返回true，如果第二个序列元素较多，多出的元素不考虑。如果第二个序列元素比第一个序列元素少，会出错，因此开始前需要先比较元素个数。</p>
<pre><code>template&lt;class InputIterator1,class InputIterator2,class BinaryPredicate&gt;
inline bool equal(InputIterator first1,InputIterator last1,InputIterator first2,inputIterator last2,BinaryPredicate binary_pred){
    for(;first1!=last1;++first1,++first2)
        if(!binary_pred(*first1,*first2))
            return false;
    return true;
}</code></pre><p>fill(first,last,value) //[first,last)内的所有元素都填入新值</p>
<p>fill_n(first,last,n,value)//[first,last) 内n个元素填入新值</p>
<p>lexicographical_compare()//按序对两个序列的元素进行比较可能结果</p>
<ol>
<li>如果第一个序列结果比较小，返回true</li>
<li>如果到达last1没有到达last2，返回true，如果到达last2，没有到达last1返回false</li>
<li>如果同时到达last1，last2返回false</li>
</ol>
<p>max()/min() //比较两个元素大小 返回较大/较小值</p>
<pre><code>template&lt;class T&gt;
inline const T&amp;max(const T&amp;a,const T&amp;b){
    return a&gt;b?a:b;
}</code></pre><p><strong>note： 8.23更新</strong></p>
<p>copy_backward(beg, end, dest); // 从输入范围中拷贝元素到指定目的位置。如果范围为空,则返回值为 dest；否则，返回值表示从 *beg 中拷贝或移动的元素。</p>
<h4 id="set相关算法"><a href="#set相关算法" class="headerlink" title="set相关算法"></a>set相关算法</h4><p>STL中set相关算法包括并集，交集，差集，对称差集</p>
<p>set_union(first1,last1,first2,last2) //返回[first1,last1)和[first2,last2)之间的所有元素，<strong>注意此处set为有序序列（底层是set），序列中允许出现重复数据。</strong></p>
<p>set_intersection()//求存在于[first1,last1)且存在于[first2,last2)之间的所有元素。<strong>注意此处set为有序序列（底层是set），序列中允许出现重复数据。</strong></p>
<p>set_difference() //求存在于[first1,last1)且不存在于[first2,last2)之间的所有元素，<strong>注意此处set为有序序列（底层是set），序列中允许出现重复数据。</strong></p>
<p>set_symmetric_difference //对称差集，求存在于[first1,last1)且不存在于[first2,last2)之间的所有元素，且存在于[first2,last2)且不存在于[first1,last1)之间的所有元素.<strong>注意此处set为有序序列（底层是set），序列中允许出现重复数据。</strong></p>
<h4 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h4><p> count(first,last,value) // 计算[first,last)间值为value的个数</p>
<p>count_if(first,last,pred) //计算[first，last)间满足条件pre的元素个数</p>
<p>find(first,last,value) //找出区间内第一个满足条件为value的元素</p>
<p>find_if(first,last,pred) //找不区间内第一个满足条件pred的元素</p>
<p>find_end(first1,last1,first2,last2) //在序列一的区间内找序列二最后出现的位置，找不到返回last1</p>
<p>find_first_of(first1,last1，first2,last2) //查找[first2,last2) 第一次出现在[first1，last1)的位置，如果找不到，返回last1;</p>
<p>for_each(first,last,function f) //对输入序列中的每个元素应用可调用对象f，f的返回值被忽略.</p>
<p>generate(first,last,Gen) //将反函数Gen的运算结果填写在[first,last)区间</p>
<p>includes(firsst1,last1,first2,last2) //判断序列[first2,last2)是否包含于[first1,last1)，返回bool值， <strong>两个序列都是有序的</strong></p>
<p>merge(fis1,las1,fis2,las2，dst) // 将两个有序序列合并成一个有序序列,填入dst中。</p>
<p>partition(first,last,pred) //在区间内，满足条件的元素放在前面，不满足条件的元素放在后面，返回第一个迭代器。</p>
<p>remove(first,last,value)  //移出区间中等于value的元素，并未真正移出，而是将不等于value的元素赋值给first开始的区间</p>
<p>remove(first,last,output,value) //将区间中不等于value的元素移动到output区间内。 </p>
<p>replace(first,last,old,new) //将区间内的old都已new代替</p>
<p>replace_if(first,last,pred,new) //区间内满足条件pred的值都会被new代替</p>
<p>reverse(first,last) //将元素在原容器中颠倒重拍</p>
<p>reverse_cpoy(first,last,out) //将元素重排，但是输出到out</p>
<p>rotate(first,mid,last) //将[first,mid)放到原区间后面，[mid,last)放到前面</p>
<p>unique(first,last) //移出区间内<strong>相邻的相同元素</strong>，保留一个</p>
<p>lower_bound(beg, end, val);// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</p>
<p>lower_bound(beg, end, val, comp); // 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</p>
<p>upper_bound(beg, end, val); // 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</p>
<p>upper_bound(beg, end, val, comp); // 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</p>
<p>binary_search(beg, end, val); // 返回一个 bool 值，指出序列中是否包含等于 val 的元素。对于两个值 x 和 y，当 x 不小于 y 且 y 也不小于 x 时，认为它们相等。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/STL/" rel="tag"><i class="fa fa-tag"></i> STL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/18/leetcode-1144-递减元素使数组呈锯齿状/" rel="next" title="leetcode 1144. 递减元素使数组呈锯齿状">
                <i class="fa fa-chevron-left"></i> leetcode 1144. 递减元素使数组呈锯齿状
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/21/C-new和malloc的区别/" rel="prev" title="C++ new和malloc的区别">
                C++ new和malloc的区别 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Xiaopingpp">
            
              <p class="site-author-name" itemprop="name">Xiaopingpp</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/SJ110" title="GitHub &rarr; https://github.com/SJ110" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:songjunp@qq.com" title="E-Mail &rarr; mailto:songjunp@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://leetcode-cn.com/u/songjunp/" title="leetcode &rarr; https://leetcode-cn.com/u/songjunp/" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>leetcode</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一章-STL概论于版本简介"><span class="nav-number">2.</span> <span class="nav-text">第一章 STL概论于版本简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#STL六大组件"><span class="nav-number">2.1.</span> <span class="nav-text">STL六大组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GNU源码开放精神"><span class="nav-number">2.2.</span> <span class="nav-text">GNU源码开放精神</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STL中一些c-语法"><span class="nav-number">2.3.</span> <span class="nav-text">STL中一些c++语法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二章-空间配置器"><span class="nav-number">3.</span> <span class="nav-text">第二章 空间配置器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#空间的配置与释放"><span class="nav-number">3.1.</span> <span class="nav-text">空间的配置与释放</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三章-迭代器概念与traits编程技法"><span class="nav-number">4.</span> <span class="nav-text">第三章 迭代器概念与traits编程技法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模板偏特化的意义"><span class="nav-number">4.1.</span> <span class="nav-text">模板偏特化的意义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四章-序列式容器"><span class="nav-number">5.</span> <span class="nav-text">第四章 序列式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vector"><span class="nav-number">5.1.</span> <span class="nav-text">vector</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#vector迭代器"><span class="nav-number">5.1.1.</span> <span class="nav-text">vector迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#vector数据结构"><span class="nav-number">5.1.2.</span> <span class="nav-text">vector数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#vector-元素操作"><span class="nav-number">5.1.3.</span> <span class="nav-text">vector 元素操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list"><span class="nav-number">5.2.</span> <span class="nav-text">list</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述"><span class="nav-number">5.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#list-元素操作"><span class="nav-number">5.2.2.</span> <span class="nav-text">list 元素操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deque"><span class="nav-number">5.3.</span> <span class="nav-text">deque</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#deque构造"><span class="nav-number">5.3.1.</span> <span class="nav-text">deque构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#deque迭代器"><span class="nav-number">5.3.2.</span> <span class="nav-text">deque迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#deque元素操作"><span class="nav-number">5.3.3.</span> <span class="nav-text">deque元素操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stack"><span class="nav-number">5.4.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#queue"><span class="nav-number">5.5.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#heap概述"><span class="nav-number">5.6.</span> <span class="nav-text">heap概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#heap算法"><span class="nav-number">5.6.1.</span> <span class="nav-text">heap算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#priority-queue"><span class="nav-number">5.7.</span> <span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slist"><span class="nav-number">5.8.</span> <span class="nav-text">slist</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第六章-关联式容器"><span class="nav-number">6.</span> <span class="nav-text">第六章 关联式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#树的导览"><span class="nav-number">6.1.</span> <span class="nav-text">树的导览</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RBtree-迭代器"><span class="nav-number">6.1.1.</span> <span class="nav-text">RBtree 迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RBtree元素操作"><span class="nav-number">6.1.2.</span> <span class="nav-text">RBtree元素操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set"><span class="nav-number">6.2.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map"><span class="nav-number">6.3.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashtable"><span class="nav-number">6.4.</span> <span class="nav-text">hashtable</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法概观"><span class="nav-number">7.</span> <span class="nav-text">算法概观</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#泛化算法"><span class="nav-number">7.1.</span> <span class="nav-text">泛化算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set相关算法"><span class="nav-number">7.2.</span> <span class="nav-text">set相关算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他算法"><span class="nav-number">7.3.</span> <span class="nav-text">其他算法</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiaopingpp</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">176k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">2:40</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>