<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
        background: #1E92FB; /*��������ɫ*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*��Ӱ��ɫ*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*�ϱ߿���ɫ*/
        border-left-color: #1E92FB;    /*��߿���ɫ*/
    }
</style>
  <meta name="description" content="前言&amp;ensp;&amp;ensp;最近开始看下《Swift4从零到精通iOS开发》,学习下Swift的语法.也相当于做一个简单的读书笔记. &amp;ensp;&amp;ensp;虽然在毕业前也做过一丢丢的Swift语法学习,但是那个时候还没有接触到任何的iOS开发,当时学起来也是晦涩难懂,所以之前的学习就当作空白归零,现在重新开始新的Swift语法学习.">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift基础语法">
<meta property="og:url" content="http://yoursite.com/2021/12/06/Swift基础语法/index.html">
<meta property="og:site_name" content="xiaopingpp">
<meta property="og:description" content="前言&amp;ensp;&amp;ensp;最近开始看下《Swift4从零到精通iOS开发》,学习下Swift的语法.也相当于做一个简单的读书笔记. &amp;ensp;&amp;ensp;虽然在毕业前也做过一丢丢的Swift语法学习,但是那个时候还没有接触到任何的iOS开发,当时学起来也是晦涩难懂,所以之前的学习就当作空白归零,现在重新开始新的Swift语法学习.">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-12-29T12:54:22.248Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift基础语法">
<meta name="twitter:description" content="前言&amp;ensp;&amp;ensp;最近开始看下《Swift4从零到精通iOS开发》,学习下Swift的语法.也相当于做一个简单的读书笔记. &amp;ensp;&amp;ensp;虽然在毕业前也做过一丢丢的Swift语法学习,但是那个时候还没有接触到任何的iOS开发,当时学起来也是晦涩难懂,所以之前的学习就当作空白归零,现在重新开始新的Swift语法学习.">



  <link rel="alternate" href="/atom.xml" title="xiaopingpp" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://yoursite.com/2021/12/06/Swift基础语法/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Swift基础语法 | xiaopingpp</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiaopingpp</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/06/Swift基础语法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xiaopingpp">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaopingpp">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Swift基础语法

              
            
          </h1>
        

        <div class="post-meta">

          
            <i class="fa fa-thumb-tack"></i>
            <font color="7D26CD">top</font>
            <span class="post-meta-divider">|</span>
          

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-12-06 10:29:17" itemprop="dateCreated datePublished" datetime="2021-12-06T10:29:17+08:00">2021-12-06</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-12-29 20:54:22" itemprop="dateModified" datetime="2021-12-29T20:54:22+08:00">2021-12-29</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">11k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">10 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;最近开始看下<a href="https://weread.qq.com/web/reader/7a232e307199a64a7a29ea8k9bf32f301f9bf31c7ff0a60" target="_blank" rel="noopener">《Swift4从零到精通iOS开发》</a>,学习下Swift的语法.也相当于做一个简单的读书笔记.</p>
<p>&ensp;&ensp;虽然在毕业前也做过一丢丢的Swift语法学习,但是那个时候还没有接触到任何的iOS开发,当时学起来也是晦涩难懂,所以之前的学习就当作空白归零,现在重新开始新的Swift语法学习.</p>
<a id="more"></a>

<h3 id="量值与基本数据类型"><a href="#量值与基本数据类型" class="headerlink" title="量值与基本数据类型"></a>量值与基本数据类型</h3><h4 id="特殊的基本数据类型"><a href="#特殊的基本数据类型" class="headerlink" title="特殊的基本数据类型"></a>特殊的基本数据类型</h4><ul>
<li>元组<br>&ensp;&ensp; 元组是Swift中特有的数据类型,允许一些不相关的数据类型进行自由组合成为新的集合类型.如下定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// note Swift中对于string类型前面不需要加@</span><br><span class="line">    var pen:(name:String,price:Int) = (&quot;钢笔&quot;,2)</span><br><span class="line">/// 进行元组定义后,可以使用通过参数名称来取得各个参数</span><br><span class="line">    var name = pen.name; //钢笔</span><br><span class="line">    var price = pen.price; //2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&ensp;&ensp;在创建元组时,可以不指定元组中的参数名称,此时元组会自动为每个参数分配下标,从0开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var newpen:(String,Int) = (&quot;钢笔&quot;,2)</span><br><span class="line">var newpenName = newpen.0; //钢笔</span><br><span class="line">var newpenPrice = newpen.1; // 2</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;元组分解,元组创建后,可以通过制定变量为分解.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var newpen:(String,Int) = (&quot;钢笔&quot;,2)</span><br><span class="line">///分解元组,分组成员分解为两个变量</span><br><span class="line">var (newpenName,newpenPrice) = newpen</span><br><span class="line">print(newpenName,newpenPrice)</span><br><span class="line">/// 匿名分解</span><br><span class="line">var (newpenName2,_) = newpen;</span><br><span class="line">print(newpenName2);</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;在上面代码中,使用<strong>_</strong>来表示匿名的概念,因此只分解了第一个参数</p>
<ul>
<li>可选值类型<br>&ensp;&ensp;optional类型是Swift特有的一种类型,在实现Swift类型安全上,使用Optional对普通类型进行包装,实现对空值的监控.在Swift中,如下代码会在编译时报错,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Variable &apos;obj&apos; used before being initialized</span><br><span class="line">    var obj:String</span><br><span class="line">    if obj == nil &#123;</span><br><span class="line">        obj = &quot;111&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&ensp;&ensp;在Swift中如果需要基本类型为nil的话,应该将其包装为Optional类型.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj:String?</span><br><span class="line">/// 在普通数据类型后加?包装为Optional类型.</span><br><span class="line">/// Optional类型不会独立存在,总是附着在某个具体的数据类型上.具体数据类型可以是基本数据类型/结构体/类等.</span><br><span class="line">/// Optional只有两种值 1、如果附着类型的对应变量有值,那么其为具体值的包装 2、如果没有具体值,那么为nil</span><br><span class="line">if obj == nil &#123;</span><br><span class="line">    obj = &quot;111&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;Optional是对普通类型的一种包装,在使用时也需要拆包操作.拆包使用操作符”!”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj:String?</span><br><span class="line">if obj != nil &#123;</span><br><span class="line">    obj!;</span><br><span class="line">&#125;</span><br><span class="line">/// 一般开发中,更常用的拆包操作</span><br><span class="line">    var obj:String? </span><br><span class="line">/// if let 结构将创建一个临时变量接受拆包后的数据    </span><br><span class="line">    if let tmp = obj &#123;</span><br><span class="line">        print(tmp)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        obj = &quot;111&quot;;</span><br><span class="line">        print(obj!)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符-字符串和集合类型"><a href="#字符-字符串和集合类型" class="headerlink" title="字符,字符串和集合类型"></a>字符,字符串和集合类型</h3><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>&ensp;&ensp;在Swift中,String类型是一个结构体,结构体中定义了属性和方法.String中提供了很多的重载构造方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        var str:String = &quot;123&quot;; //使用字符串初始化</span><br><span class="line">        str = &quot;&quot;; // 使用空字符串</span><br><span class="line">        str = String(); // &quot;&quot;</span><br><span class="line">        str = String(&quot;123&quot;); // &quot;123&quot;</span><br><span class="line">        str = String(123);  /// 数字转字符串&quot;123&quot;</span><br><span class="line">        str = String(&quot;a&quot;); /// 字符转字符串&quot;a&quot;</span><br><span class="line">        str = String(describing: (1,1,true)); /// 元组转字符串 &quot;(1,1,true)&quot;</span><br><span class="line">        str = String(false);</span><br><span class="line">        str = String(format: &quot;12%@&quot;,&quot;3&quot;); /// 格式化字符串 &quot;123&quot;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### 字符串组合</span><br><span class="line">&amp;ensp;&amp;ensp;Swift中重载了+号运算符,可以将两个字符串连接起来.</span><br></pre></td></tr></table></figure>

<pre><code>var str1 = &quot;hello&quot;;
var str2 = &quot;world&quot;;
/// 注意重载运算符+两边不能有空格
str1 = str1+&quot; &quot;+str2;
print(str1);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;可以使用插值的方式对字符串进行组合拼接.这种方式**在开发中经常使用**</span><br></pre></td></tr></table></figure>

<pre><code>var str3 = &quot;hello\(123)&quot;
var str4 = &quot;hello \(str2)&quot;
print(str3,str4); // hello123 , hello world</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 字符串类型中的常用方法</span><br><span class="line">&amp;ensp;&amp;ensp;Swift中可以使用 &gt;/&lt;/==比较两个字符串,其比较方式是对每一个字符依次比较其对应AscII码大小.</span><br></pre></td></tr></table></figure>

<pre><code>var sstr = &quot;hello-swift&quot;
var startIndex = sstr.startIndex; ///起始索引,不是一个integer
var endIndex = sstr.endIndex; /// 结束索引,不是一个integer,注意,此处返回结束位置的下一个位置
var lenth = sstr.count; /// 字符串长度 11

var char = sstr[sstr.index(after: startIndex)]; /// 第二个字符 e
var char2 = sstr[sstr.index(before: endIndex)]; /// 最后一个字符 t
print(char,char2); ///e t
var range = sstr.range(of: &quot;hello&quot;) ///子串所在的位置
sstr.append(&quot;!&quot;) /// hello-Swift!
print(sstr)
sstr.insert(&quot;1&quot;, at: sstr.endIndex) /// hello-Swift!1
print(sstr)
sstr.insert(contentsOf: [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], at: sstr.endIndex) /// hello-Swift!1111
sstr.remove(at: sstr.index(before: sstr.endIndex)) /// hello-Swift!111
print(sstr)
sstr.hasPrefix(&quot;hell&quot;)  ///是否有前缀 yes
sstr.hasSuffix(&quot;222&quot;)  ///是否有后缀  no
sstr.uppercased()  ///转大写
sstr.lowercased()  ///转小写</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#### 集合类型</span><br><span class="line"> - Array类型 </span><br><span class="line">&amp;ensp;&amp;ensp;申明</span><br></pre></td></tr></table></figure>

<p>///申明空数组<br>        var arr1:[Int] = []<br>        var arr2:Array<int> = Array()<br>        arr1 = [1,2,3];  // [1,2,3]<br>        arr2 = Array(arrayLiteral: 1,2,3) [1,2,3]</int></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;数组相加 Swift中对数组的+运算符也进行了重载,但是要保证相加的数组元素类型相同</span><br></pre></td></tr></table></figure>

<pre><code>var arr3 = [1,2,3]+[4,5,6] //[1,2,3,4,5,6]</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;数组中的常用方法</span><br></pre></td></tr></table></figure>

<pre><code>arr3.count; /// 个数
arr3.isEmpty /// 是否空
arr3.first; /// 第一个元素
arr3.last; ///最后一个元素
arr3.append(7); ///[1,2,3,4,5,6,7]
arr3.removeLast() /// [1,2,3,4,5,6]
arr3.removeLast(2) /// [1,2,3,4]
arr3.max() /// 最大值
arr3.min() /// 最小值</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> - Set集合</span><br><span class="line">&amp;ensp;&amp;ensp; set和C++中的set比较类型,对比即可,Swift中的set可以进行集合的运算.</span><br></pre></td></tr></table></figure>

<pre><code>var set1:Set&lt;Int&gt; = [1,2,3,4]
var set2:Set&lt;Int&gt; = [3,4,5,6] 
var setInter = set1.intersection(set2)  //[4, 3] 交集
var setEx = set1.symmetricDifference(set2) // [6, 5, 1, 2] 交集的补集
var setUni = set1.union(set2) /// 并集 [4, 5, 6, 1, 3, 2]
var setSub = set1.subtracting(set2) /// 差集 [1,2]
print(setInter,setEx, setUni,setSub)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Swift两种特殊运算符</span><br><span class="line"> - 空合并运算符 空合并运算符是针对Optional类型设计的运算符,比如如下判断代码</span><br></pre></td></tr></table></figure>

<pre><code>    var q:Int? = 8
    var value:Int
    if q != nil {
        /// 不为空,拆包
        value = q!
    } else {
        /// 为空,赋值0
        value = 0
    }
/// 使用空合并运算符
var q:Int? = 8
var value:Int
value = q ?? 0  /// 8</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;空合并运算符会自行判断是否为空,并自行拆包.**注意:??两边需要有空格**</span><br><span class="line"></span><br><span class="line"> - 区间运算符 在Swift中使用了区间运算符来快捷的表示范围.实例代码如下</span><br></pre></td></tr></table></figure>

<pre><code>var srange = 0...10
var srange2 = 0..&lt;10</code></pre><p>//        var range3 = 0&lt;..10 ///报错,没有左开区间<br>        print(srange,srange2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 分支选择结构</span><br><span class="line"> - Swift中的swicth结构有一定的优化,其中不需要加break在执行分支后进行跳出,case条件的匹配不仅仅局限于Int类型.可以进行任意类型的匹配.</span><br></pre></td></tr></table></figure>

<pre><code>var ssstr:String = &quot;111&quot;
switch ssstr {
case &quot;111&quot;:
    print(sstr) ///自动break
case &quot;333&quot;:
    print(&quot;333&quot;)
default:
    print(&quot;222&quot;)
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- fallthrough:fallthrough可以使switch语句继续向下执行,不直接跳出</span><br></pre></td></tr></table></figure>

<pre><code>var ssstr:String = &quot;111&quot;
switch ssstr {
case &quot;111&quot;:
    print(sstr) ///自动break
    fallthrough
case &quot;333&quot;:
    print(&quot;333&quot;)
    fallthrough
default:
    print(&quot;222&quot;) /// log 111 333 222
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- guard else 守护语句:作用是只在某个条件成立时才执行相应代码,类似if的效果</span><br></pre></td></tr></table></figure>

<pre><code>func foo(params:Int) {
    if params&gt;0 {
        print(params)
    } else {
        return
    }
}</code></pre><p>   /// guard<br>    func foo2(params:Int) {<br>        /// params &lt;= 0 直接返回<br>        guard params&gt;0 else {<br>            return<br>        }<br>        print(params)<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">### 函数</span><br><span class="line"></span><br><span class="line">#### 函数的基本使用</span><br><span class="line">&amp;ensp;&amp;ensp; Swift中的函数定义需要在最前面增加一个**func**,不过在xcode的语法提示下,申明一个函数变得比较简单,下面是两个特殊点</span><br><span class="line"> - 不定数量函数参数:可以使用...实现不定参数个数的函数.需要注意不定参数的参数类型需要保持一致.</span><br></pre></td></tr></table></figure>

<pre><code>/// params1不定参数,但是类型一致
func foo3(params1:Int ...,params2:String) -&gt; Int {
    var sum:Int = 0;
    for cout in params1 {
        sum += cout
    }
    print(&quot;foo3&quot;,sum)
    return sum
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- Swift中如果是值传递,不能修改参数在函数内部的值.在Swift中类是引用类型,基本数据类型(枚举,结构体,float...)是值类型,如果需要修改值类型的参数,需要添加**inout**关键字,同时引用传递参数</span><br></pre></td></tr></table></figure>

<pre><code>func foo4(params:Int) -&gt; Int {
    params = params+1;  ///不能修改params
    return params
}
/// 正确
func foo4(params:inout Int) -&gt; Int {
    params = params+1;
    return params
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 闭包</span><br><span class="line"> - 闭包可以和OC中的block进行类比,但是Swift中的闭包语法可以进行一定的简化.</span><br></pre></td></tr></table></figure>

<pre><code>func foo4(params:Int) -&gt; Int {
    return params*params
}

let myClosure = {(params:Int)-&gt;Int in
    return params*params
}
foo4(3) /// 9
myClosure(3) /// 9
/// 1、闭包返回值类型可以通过定义自动推断

let myClosure2 = {(params:Int) in
    return params*params
}
myClosure2(3) /// 9</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 闭包作为函数参数</span><br></pre></td></tr></table></figure>

<p>/// sortClosure 作为参数传递,进行数组排序<br>    func mySort(array:inout Array<any>, sortClosure:(Int,Int)-&gt;Bool) -&gt; Array<any> {<br>        for indexI in array.indices {<br>            if indexI == array.count-1 {<br>                break<br>            }<br>            for indexJ in 0 … ((array.count - 1) - indexI - 1) {<br>                if sortClosure(array[indexJ] as! Int, array[indexJ+1] as! Int) {</any></any></p>
<pre><code>            } else {
                array.swapAt(indexJ, indexJ+1)
            }
        }
    }
    return array
}
/// 调用
mySort(array: &amp;tmpArray, sortClosure: {(index:Int,index2:Int) -&gt; Bool in
    return (arrays[index] as!Int) &lt;= (arrays[index2] as!Int)</code></pre><p>   })</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 闭包的写法优化</span><br></pre></td></tr></table></figure>

<p>///省略返回类型,编译器自动通过闭包返回类型推断<br>    mySort(array: &amp;tmpArray, sortClosure: {(index:Int,index2:Int) in<br>        return (arrays[index] as!Int) &lt;= (arrays[index2] as!Int)<br>    })<br>/// 如果闭包只有一行代码,同时闭包作为函数的参数,闭包的return关键字可以省略<br>    mySort(array: &amp;tmpArray, sortClosure: {(index:Int,index2:Int) in<br>        (arrays[index] as!Int) &lt;= (arrays[index2] as!Int)<br>    })<br>/// 当闭包围坐函数的参数时,闭包的参数列表会自动创建一组参数,参数名以$0,$1这样的结构类推,因此<br>    mySort(array: &amp;tmpArray, sortClosure: {<br>        (arrays[$0] as! Int) &lt;= (arrays[$1] as!Int)<br>    })</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 后置闭包</span><br><span class="line">&amp;ensp;&amp;ensp;当函数中的最后一个参数位闭包参数时,可以在调用函数时,将闭包结构脱离函数参数列表,追加在函数尾部.</span><br></pre></td></tr></table></figure>

<pre><code>///后置闭包写法
mySort(array: &amp;tmpArray) {
    (arrays[$0] as! Int) &lt;= (arrays[$1] as!Int)
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;当函数之后一个参数,并且参数时比好类型时,可以用后置闭包的写法省略函数的参数</span><br></pre></td></tr></table></figure>

<p>/// 定义<br>    func foo5(myClosure:(Int,Int)-&gt;Bool){</p>
<pre><code>}</code></pre><p>/// 调用<br>    foo5 {<br>        $0&lt;=$1<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 逃逸闭包和非逃逸闭包</span><br><span class="line">&amp;ensp;&amp;ensp;逃逸闭包指函数内的闭包在函数执行结束后在函数外依然可以执行.非逃逸闭包纸当函数的生命周期结束后,闭包也将被销毁.非逃逸闭包也不可以作为返回值返回.逃逸闭包一般用在异步操作中,比如接口调用之后对于返回结果的回调.</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;闭包类型是Swift中比较特殊的语法,需要多加练习.</span><br><span class="line"></span><br><span class="line">### 运算符重载和枚举</span><br><span class="line"></span><br><span class="line">#### 运算符重载</span><br><span class="line"> - 函数重载,是指参数列表不同,返回值不同的同名函数,OC中没有函数的重载,Swift中可以进行函数的重载</span><br></pre></td></tr></table></figure>

<pre><code>func adds(params1:Int,params2:Int)-&gt;Int {

}
func adds(params1:String,params2:Int)-&gt;String {

}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 运算符重载,Swift从2.x版本后剔除了++运算符,但是通过重载运算符可以自定义相关的方法.</span><br></pre></td></tr></table></figure>

<p>/// 前缀++<br>prefix operator ++<br>prefix func ++(params:Int) -&gt; Int {<br>    var ret = params<br>    ret = ret+1<br>    return ret<br>}<br>/// 中缀运算符重载<br>infix operator ++<br>func ++(params:Int,params2:Int) -&gt; Int  {<br>    return (params * params2)<br>}<br>/// 后缀运算符重载<br>postfix operator ++<br>postfix func ++(params:Int) -&gt; Int {<br>    return params+1<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 枚举的创建和应用</span><br><span class="line">&amp;ensp;&amp;ensp;Swift中枚举的创建支持声明一个原始类型,如果定义为int类型时,如果设置第一个为1,后面的枚举都会自增1.</span><br></pre></td></tr></table></figure>

<p>/// 声明字符枚举<br>enum charEnum:Character {<br>case a = “a”<br>case b = “b”<br>case c = “c”<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;Swift中枚举较为灵活,可以通过自定义枚举实现匹配</span><br></pre></td></tr></table></figure>

<p>enum shape {<br>    case circle(center:(Double,Double),radius:(Double))<br>    case rectangle(center:(Double,Double),width:(Double),height:(Double))<br>    case triangle(point1:(Double,Double),point2:(Double,Double),point3:(Double,Double))<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">然后使用switch语句时根据样式进行匹配.</span><br><span class="line"></span><br><span class="line">### 类和结构体</span><br><span class="line">#### 类和结构体的区别</span><br><span class="line"> - 类中需要定一个初始化方法,进行内部成员的初始化,结构体不需要,结构体会自动生成一个初始化方法在内部</span><br><span class="line"> - 结构是值类型,进行赋值是会进行一份内存的拷贝,修改其中一个,另一个不会影响.类是引用类型,赋值后两份指向同一份内存.</span><br><span class="line"> - 类可以继承,结构体不能继承.</span><br><span class="line"> - Swift中结构体内部可以定义方法.</span><br><span class="line"></span><br><span class="line">#### 类的继承</span><br><span class="line"> - Swift中类可以被继承,实现子类自身所需要的特点.</span><br><span class="line"> - override关键字表示子类中重写父类中的方法.在重写的方法中可以通过super关键字调用父类的实现,然后继续子类的逻辑.</span><br><span class="line"> - final关键字可以修改类的方法,属性,类本身.被修饰后,不可以被子类继承或重写.</span><br><span class="line"></span><br><span class="line">#### 使用场景</span><br><span class="line"> - 结构体:如果成员比较简单,不需要继承,所描述的数据类型需要以复制的形式进行.则使用结构体来定义,否则使用类来定义.</span><br><span class="line"> - Swift中array,dictionary,string,set等类型都是使用struct来定义的.因此进行赋值时都会拷贝一份新的数据.</span><br><span class="line"></span><br><span class="line">### 构造方法的设计和使用</span><br><span class="line">&amp;ensp;&amp;ensp;Swift中的构造方法与OC中的有区别,OC中的构造方法需要返回一个(instanceType)类型,Swift中无返回类型,Swift为了实现类型安全的特性,给构造方法增加了一些原则.Swift中的构造放包括指定构造放和便利构造方法,可失败构造方法和必要构造方法.想通的是在构造子类时需要先构造一个父类.</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;Swift中可以进行属性监听,但是监听在给属性设置初始值和构造方法时豆不会出发,只有在构造完成之后,属性监听才会生效.</span><br></pre></td></tr></table></figure>

<p>class MyClass {<br>    var count:Int = 0 {<br>        willSet {<br>            print(“willSet:count”)<br>        }<br>        didSet {<br>            print(“didSet:count”)<br>        }<br>    }<br>    init(params:Int) {<br>        count = params<br>    }<br>}<br>var objClass = MyClass(params: 5)<br>objClass.count = 3;  ///只有在初始化后赋值才会触发属性监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;对于结构体,可以不用实现其构造方法,编译器默认生成一个构造方法,将属性作为参数.**对于值类型结构,比如结构体,如果自己定义了一个构造方法,那么系统生成的构造方法将会失效**</span><br><span class="line"></span><br><span class="line">#### 指定构造方法和便利构造方法</span><br><span class="line">&amp;ensp;&amp;ensp;指定构造方法(Designnated)不需要任何关键字修饰,便利构造方法需要使用(Convenience)修饰.便利构造方法方便开发者使用.但是也需要遵循一些原则.</span><br><span class="line"> - 子类的指定构造方法中必须调用父类的指定构造方法</span><br><span class="line"> - 便利构造方法中必须调用当前类的其他构造方法</span><br><span class="line"> - 便利构造方法归根结底要调用某个指定构造方法</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;可以这样理解这三个原则,1、子类构造方法需要调用父类的构造方法.2、便利构造方法是为了方便开发这调用,但是便利构造方法最终依赖于指定构造方法.</span><br><span class="line"></span><br><span class="line">#### 构造方法的继承关系</span><br><span class="line"> - 在继承关系中,如果子类没有覆写或者重写任何指定构造方法,则默认子类会继承父类所有的指定构造方法. </span><br><span class="line"> - 如果子类提供了父类的指定构造方法,则子类默认继承父类的便利构造方法.</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;第一个原则说明子类如果自定义了指定构造方法,或者覆写了父类的某个指定构造方法,那么子类不在继承父类所有的指定构造方法.第二个原则说明由于所有的便利构造方法最终都会调用指定构造方法,因此无论子类中定义的便利构造方法与父类是否相同,都是子类独立的构造方法.</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;这里注意下覆写(override)和重载(overload)的概念,覆写是指子类对父类的方法进行重新定义.重载是指方法名相同,参数不同或者返回值不同的方法.</span><br><span class="line"></span><br><span class="line">#### 构造方法的安全行检查</span><br><span class="line">&amp;ensp;&amp;ensp;Swift在类的构造方法中会进行4项安全性检查.</span><br><span class="line"> - 在子类的构造方法中,必须完成当前类所有存储属性的构造,才能调用父类的指定构造方法,这样可以保证构造完成从父类继承下来的存储属性前,本身定义的存储属性也构造完成.</span><br><span class="line"> - 子类中如果要自定父类中的存储属性的值,需要在调用父类的构造方法之后再设置,可以保证在重新赋值时父类的属性已经构造完成.</span><br><span class="line"> - 如果便利构造方法中要重新设置某些存储属性的值,那么需要在调用指定构造方法之后设置,可以保证便利构造方法中的值不会被指定构造方法中的值覆盖.</span><br><span class="line"> - 子类在调用父类构造方法前,不能使用self引用属性,可以保证使用self调用实例本身时,实例已经构造完成.</span><br></pre></td></tr></table></figure>

<p>class subCheck:check {<br>    var subProperty:Int<br>    init() {<br>        /// 原则1调用父类构造方法前,先完成自身属性赋值<br>        subProperty = 1;<br>        super.init(param: 0);<br>        /// 原则2 如果子类对父类属性重新赋值,需要在父类初始化方法之后,保证父类已经存在<br>        property = 2;<br>        /// 原则3完成父类构造方法之后,才能使用self关键字<br>        self.subProperty = 3;<br>    }<br>    convenience init(param1:Int,param2:Int) {<br>        self.init();<br>        /// 原则4 便利构造方法中要修改属性的值需要在指定构造方法之后,防止值被覆盖<br>        subProperty = 3;<br>        property = param2;<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 可失败构造方法和必要构造方法</span><br><span class="line">&amp;ensp;&amp;ensp;Swift为了处理某些可能空的值,引入了optional可选值类型,对于类的构造方法,如果传递的参数不符合要求时,可以让构造方法失败,此时需要使用可失败构造方法的语法.其次,可以设置某些构造方法为必要构造方法,如果类中的某些构造方法被指定为必要构造方法,则其子类必须实现这个方法.必要构造方法使用required关键字修饰.</span><br></pre></td></tr></table></figure>

<p>class reCheck {<br>    var property:Int<br>    /// 可失败构造方法<br>    init?(params:Int) {<br>        guard params&gt;10 else {<br>            return nil<br>        }<br>        property = params;<br>    }<br>    /// 此构造方法必须子类实现<br>    required init(param1:Int,param2:Int) {<br>        property = param2;<br>    }<br>    deinit {<br>        print(“该类被销毁”);<br>    }</p>
<p>}<br>```</p>
<p>&ensp;&ensp;与构造方法相对应的是析构方法.使用deinit标识,当把实例置为nil时,实例会被释放</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"><i class="fa fa-tag"></i> iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/11/29/iOS页面转场动画/" rel="next" title="iOS页面转场动画">
                <i class="fa fa-chevron-left"></i> iOS页面转场动画
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/01/07/如何用OC如何写一个单例/" rel="prev" title=" 如何用OC如何写一个单例">
                 如何用OC如何写一个单例 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Xiaopingpp">
            
              <p class="site-author-name" itemprop="name">Xiaopingpp</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">49</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/SJ110" title="GitHub &rarr; https://github.com/SJ110" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:songjunp@qq.com" title="E-Mail &rarr; mailto:songjunp@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://leetcode-cn.com/u/songjunp/" title="leetcode &rarr; https://leetcode-cn.com/u/songjunp/" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>leetcode</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#量值与基本数据类型"><span class="nav-number">2.</span> <span class="nav-text">量值与基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特殊的基本数据类型"><span class="nav-number">2.1.</span> <span class="nav-text">特殊的基本数据类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符-字符串和集合类型"><span class="nav-number">3.</span> <span class="nav-text">字符,字符串和集合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串类型"><span class="nav-number">3.1.</span> <span class="nav-text">字符串类型</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiaopingpp</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">211k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">3:12</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>