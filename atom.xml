<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaopingpp</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-16T15:53:08.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xiaopingpp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>blog record</title>
    <link href="http://yoursite.com/2020/06/16/blog-record/"/>
    <id>http://yoursite.com/2020/06/16/blog-record/</id>
    <published>2020-06-16T10:32:15.000Z</published>
    <updated>2020-06-16T15:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>现在是2020年6月16日晚23：02，明天是我成为社畜的第一天，本想早几天记录下从武汉毕业到南京这几天心路历程，偷懒到只能在现在写点什么了。在没动手前觉得自己可以写好多东西的，现在就感觉之前所想到的好像都忘记了一样。不过没事，随便记录一下表示自己也是一个有感情的人吧。</p><a id="more"></a> <h3 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h3><p>撒西不理啦，上次写日志还是在好几个月前，说来也惭愧，疫情导致自己一直再找借口不学习。好在从现在开始如果我不去学习只有等着被淘汰，所以我应该会好好学点什么的吧。</p><p>七号晚上到达武汉，在是否能够进校毕业这件事上又给自己弄出了好些问题，好在最后成功进校，完成了算是近年来的第一个小目标吧。见到了那么久都没有见过的同学。虽然又一两个在游戏听到了声音，但是见到总还是觉得很开心。进行了象征性的毕业聚餐。照了几张毕业照，可是好烦啊，为什么在家呆了小半年我又变黑了，淦！</p><p>11号离开了武汉，10和两个好朋友吃了个简单的散伙饭。这两个b是真的见色忘义，为了晚上和女朋友玩直接抛弃我？还好良心发现知道请我吃顿好的（原本这餐饭是该我请的）。那这个问题久跳过吧。</p><p>不知道是不是这段时间来二次元看多了，有时候自己好想学着那些主角的性格做事，好中二! 不过我还是发现了自己确实做不到别人那种地步，毕竟咱还是活在三次元的。有时候知晓自己的性格，不要给别人带去麻烦我觉得是很重要的，我所说的不是搞清楚自己喜欢吃什么，喜欢什么运动。而是在和其他人相处时自己能做的久不要随意使唤他人了。至少目前这是我的观点，当然在好朋友面前这个观点不成立（这也是我的观点，禁止套娃！）。</p><p>都这样了，还是贴一张最后聚餐的照片吧，说到这，我忽然想起对班长说的一句话，比起拍照，我更喜欢用眼睛记录下那些美好的瞬间。我也不清楚这是不是我的真心话，有时候我也幻想自己可以拍一些搞笑二比的照片，但是好像没怎么实现，可能还是我出于对自己在照片中样貌的厌恶吧（也许）。</p><p><img src="/2020/06/16/blog-record/fir.jpg" alt="pic"></p><p>这个b还闭着眼，啧啧。</p><h3 id="chapter2"><a href="#chapter2" class="headerlink" title="chapter2"></a>chapter2</h3><p>到了南京首要任务就是找房子住了，我是真没想到最后为了付房租需要花费我几大千。现在只能寄希望于入职后下个月的工资了。</p><p>反正8到12号这几天走的我怀疑人生就是了。原本在这里有好多想写的，现在要下笔了却又不知道写啥了。有些东西感悟过就行，不过希望真的对于我能起到一点点作用，我现在还记得前段时间自己不断狂立flag，然后狂倒flag的惨烈景象。</p><p>室友比较好相处还是不错的，大家性格都优点大大咧咧，目前看来是这样，还是希望之后能好好相处，不然出啥乱子了面子上还是不太挂得住。希望不要遇到之前脑子想的那些情况，对彼此有意见却一直不说，到了某一天再爆发那就很恐怖了。<br>为了防止那种情况发生，还是要注意下自己的言行，不要或者少做出过激行为，有时候自己会头脑发热搞些屁事出来，我还是承认这一点的。</p><h3 id="chapter3"><a href="#chapter3" class="headerlink" title="chapter3"></a>chapter3</h3><p>哎，又觉得没得说了，哦对了，拍了一张离开宿舍时的照片，还是放一下吧，留个念想，下次再去不知道什么时候了。</p><p><img src="/2020/06/16/blog-record/sec.jpg" alt="pic"></p><p>还有就是和室友做了最后道别了，不，是一次愉快的道别。希望他研究生能够成为大腿吧，以后也许可以抱一抱（\卑微.jpg）。</p><p>所以啊，我觉得有时候一些自己所认为的好朋友还是一起稍微呆一段时间久好好做各自的事情为好。不然总会发现别人性格中的自己厌恶的地方。要是找不到？那也许就是知己吧（我瞎说的）。要说有什么后悔的嘛，感觉很多的来着，但是现在却一条也想不起来了。也许是我又想偷懒了，想睡觉不想写了。</p><p>感觉这四年来对于自己也没啥好总结的，性格应该变了一些，对了后悔就是自己这段时间没有好好看玩一本书了。这原本是我已经培养了快两年的爱好，之后一定要继续下去。</p><p>虽然好多人调侃说今年的愿望是活下去。我也不知道说什么。困难的事请总会来临，但是过了之后感觉也就那样了。所以痛苦的感觉我也记不清了，但是经历的时候是真的痛苦。开心的时候也是真的开心。</p><p>那就祝自己工作上少犯点错。尽快学会自己解决问题吧。 就不用照片镇楼了。之后还得继续更新自己博客哦。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;现在是2020年6月16日晚23：02，明天是我成为社畜的第一天，本想早几天记录下从武汉毕业到南京这几天心路历程，偷懒到只能在现在写点什么了。在没动手前觉得自己可以写好多东西的，现在就感觉之前所想到的好像都忘记了一样。不过没事，随便记录一下表示自己也是一个有感情的人吧。&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/其他/"/>
    
    
    <category term="感悟" scheme="http://yoursite.com/tags/感悟/"/>
    
  </entry>
  
  <entry>
    <title>swift语法基础(四)</title>
    <link href="http://yoursite.com/2020/01/23/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%9B%9B/"/>
    <id>http://yoursite.com/2020/01/23/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%9B%9B/</id>
    <published>2020-01-23T07:12:12.000Z</published>
    <updated>2020-02-07T05:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>swift统一的函数语法非常灵活，可以用来表示任何函数，包括最简单的没有参数名字的c风格函数，到复杂的带局部外部参数名的OC风格参数，参数可以听过默认值，以简化函数调用。参数也可以及当作传入参数，也当作传出参数。也就是说，一旦函数执行，传入的参数值会被修改。</p><p>swift中每一个函数都有一个由函数的参数类型和返回值类型组成的类型。可以把函数类型当作任何其他变量类型处理。这样可以简单的把函数当作别的函数的参数。也可以从其他函数中返回函数。函数定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现封装。</p><a id="more"></a><h4 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h4><p>当定义一个函数时，可以定义一个或多个有名字和类型的值，作为函数的输入，称为参数，也可以定义某种类型的值作为函数执行结束的输出作为返回类型。</p><p>每个函数有一个函数名，用来描述函数执行的任务，使用函数时，用函数名调用。并传给它匹配的输入值（实参），函数的实参必须与函数参数表里参数顺序一致。</p><p>下面是一个 greet函数例子:</p><pre><code>func greet(person: String) -&gt; String {    let greeting = &quot;Hello, &quot; + person + &quot;!&quot;    return greeting}print(greetAgain(person: &quot;Anna&quot;))// 打印“Hello again, Anna!”</code></pre><p>所有这些信息汇总起来称为函数定义，以func作为前缀。 -&gt; 后跟返回类型。</p><h4 id="函数参数与返回值"><a href="#函数参数与返回值" class="headerlink" title="函数参数与返回值"></a>函数参数与返回值</h4><ul><li><p>无参函数</p><p>函数可以没有参数，这个函数就是一个无参数函数。但是函数名后面还是需要圆括号。</p></li><li><p>多参数函数</p></li></ul><p>函数可以有多种输入参数，这些参数被包含在函数的括号中，用逗号分隔。</p><pre><code>func greet(person: String, alreadyGreeted: Bool) -&gt; String {if alreadyGreeted {    return greetAgain(person: person)} else {    return greet(person: person)}}print(greet(person: &quot;Tim&quot;, alreadyGreeted: true))// 打印“Hello again, Tim!”</code></pre><ul><li>无返回值函数</li></ul><p>函数可以没有返回值，如下：</p><pre><code>func greet(person: String) {    print(&quot;Hello, \(person)!&quot;)}greet(person: &quot;Dave&quot;)// 打印“Hello, Dave!”</code></pre><ul><li>多重返回值函数</li></ul><p>可以用元组类型让多个值作为一个复合值从函数中返回。如下:</p><pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int) {var currentMin = array[0]var currentMax = array[0]for value in array[1..&lt;array.count] {    if value &lt; currentMin {        currentMin = value    } else if value &gt; currentMax {        currentMax = value    }}    return (currentMin, currentMax)}</code></pre><p>该函数返回一个包含两个Int的元组，这些值被标记为min和max。</p><pre><code>let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)// 打印“min is -6 and max is 109”</code></pre><p>需要注意的是元组成员不需要在元组从函数中返回时命名。因为名字已经在返回类型中指定了。</p><ul><li>可选元组返回类型</li></ul><p>如果函数返回的元组类型可能整个元组都没有值，可以使用可选的元组作为返回类型反映元组是nil。可以通过在元组类型的右括号后放置一个问号来定义一个可选元组。例如:(Int,Int)?或者 (String,Bool,Int)?</p><p>前面minmax(array:)函数返回一个包含两个Int值的元组，但是函数不会对传入的数组执行任何安全检查，如果array是一个空数组，在执行时会触发错误。所以为了解决这个问题，函数改写为使用可选元组返回类型，当数组为空时返回nil:</p><pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {if array.isEmpty { return nil }var currentMin = array[0]var currentMax = array[0]for value in array[1..&lt;array.count] {    if value &lt; currentMin {        currentMin = value    } else if value &gt; currentMax {        currentMax = value    }}    return (currentMin, currentMax)}</code></pre><ul><li>隐式返回的函数</li></ul><p>如果一个函数的整个函数体是单行表达式，这个函数可以隐式的返回这个表达式。</p><h4 id="函数标签和参数名称"><a href="#函数标签和参数名称" class="headerlink" title="函数标签和参数名称"></a>函数标签和参数名称</h4><p>每个函数都有一个参数标签以及一个参数名称，参数标签在调用函数的时候使用，调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用，默认情况下，函数参数使用参数名称来作为参数标签。</p><ul><li>指定参数标签</li></ul><p>可以在参数名称前指定参数标签，中间用空格分隔:</p><pre><code>func someFunction(argumentLabel parameterName: Int) {// 在函数体内，parameterName 代表参数值}</code></pre><p>一个新版greet例子:</p><pre><code>func greet(person: String, from hometown: String) -&gt; String {return &quot;Hello \(person)!  Glad you could visit from \(hometown).&quot;}print(greet(person: &quot;Bill&quot;, from: &quot;Cupertino&quot;))// 打印“Hello Bill!  Glad you could visit from Cupertino.”</code></pre><p>参数标签能够让函数在调用是更有表达力。</p><ul><li>忽略参数标签</li></ul><p>如果不希望为某个参数添加一个标签，使用下划线代替:</p><pre><code>func someFunction(_ firstParameterName: Int, secondParameterName: Int) { // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值}someFunction(1, secondParameterName: 2)</code></pre><ul><li>默认参数值</li></ul><p>可以在函数体中通过给参数赋值来为任意一个参数定义默认值，默认值被定义后，调用这个函数时可以忽略这个参数。一般将带有默认值的参数放在末尾。</p><ul><li>可变参数</li></ul><p>可变参数可以接受0个或者多个值，函数调用时，可以用可变参数来指定函数参数可以被传入不确定的输入值。在变量类型名后加入(…)表示可变参数。</p><pre><code>func arithmeticMean(_ numbers: Double...) -&gt; Double {var total: Double = 0for number in numbers {    total += number} return total / Double(numbers.count)} //使用可变参数计算任意长度数字的平均数arithmeticMean(1, 2, 3, 4, 5)// 返回 3.0, 是这 5 个数的平均数。arithmeticMean(3, 8.25, 18.75)// 返回 10.0, 是这 3 个数的平均数。</code></pre><p><strong>notice：</strong>一个函数最多由一个可变参数。</p><ul><li>输入输出参数</li></ul><p>如果函数参数是常量，则不能在函数内修改。如果想要修改参数的值，并且想在这些修改在函数调用后任然存在，需要将参数定义为输入输出参数。</p><p>定义一个输入输出参数时，在参数顶以前加<strong>inout</strong>关键字，一个输入输出参数由传入函数的值，这个值被函数修改，然后传出函数。</p><p>只能传递变量给输入输出参数，当传入的参数作为输入输出参数时，需要在参数名前加 &amp;，表示这个值可以被函数修改。 例子如下：</p><pre><code>func swapTwoInts(_ a: inout Int, _ b: inout Int) {    let temporaryA = a    a = b    b = temporaryA}//调用如下var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)// 打印“someInt is now 107, and anotherInt is now 3”</code></pre><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>每个函数都有中特定的函数类型，函数的类型由函数的参数类型和返回类型组成。</p><pre><code>func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {    return a + b}func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int {    return a * b}</code></pre><p>这两个函数的类型为(Int,Int)-&gt;Int</p><pre><code>func printHelloWorld() {    print(&quot;hello, world&quot;)}//函数类型为 ()-&gt; void</code></pre><ul><li>使用函数类型</li></ul><p>使用函数类型可以：定义一个类型为函数的常量或者变量，将适当的函数赋值给他。</p><pre><code>var mathFunction: (Int, Int) -&gt; Int = addTwoInts</code></pre><p>上面代码解读为: 定义一个mathFunction的变量，类型是一个有两个Int的参数，并返回一个Int的函数。让这个新变量指向addTwoInts函数。</p><p>现在可以使用mathFunction调用被复制的函数。</p><pre><code>print(&quot;Result: \(mathFunction(2, 3))&quot;)// Prints &quot;Result: 5&quot;</code></pre><p>也可以将相同类型匹配的不同函数赋值给同一个变量：</p><pre><code>mathFunction = multiplyTwoIntsprint(&quot;Result: \(mathFunction(2, 3))&quot;)// Prints &quot;Result: 6&quot;</code></pre><p>也可以简单写法，使用swift的推断机制，推出变量为函数类型：</p><pre><code>let anotherMathFunction = addTwoInts// anotherMathFunction 被推断为 (Int, Int) -&gt; Int 类型</code></pre><ul><li>函数类型作为参数类型</li></ul><p>使用(Int,Int)-&gt;Int 这样的函数作为另一个函数的参数类型，这样可以将函数的一部分实现留给函数的调用者提供。如下例子：</p><pre><code>func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {print(&quot;Result: \(mathFunction(a, b))&quot;)}printMathResult(addTwoInts, 3, 5)// 打印“Result: 8”</code></pre><p>如上定义了一个 printMathResult(<em>:</em>:_:)函数，有三个参数，第一个参数为函数类型，可以传入任何类型的这个函数。它不关心传入的函数如何实现，只关心传入函数是不是一个正确的类型。</p><ul><li>函数类型作为返回类型</li></ul><p>可以用函数类型作为另一个函数的返回类型，需要做的是在返回箭头(-&gt;)后写一个完成的函数类型，例子如下：</p><pre><code>func stepForward(_ input: Int) -&gt; Int {    return input + 1}func stepBackward(_ input: Int) -&gt; Int {    return input - 1}func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {    return backward ? stepBackward : stepForward}//chooseStepFunction返回类型是(Int)-&gt;(Int),</code></pre><p>现在可以使用如下方式调用该函数:</p><pre><code>var currentValue = 3let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero 现在指向 stepBackward() 函数。</code></pre><p>现在 moveNearToZero是一个函数类型，可以像函数那样使用它:</p><pre><code>print(&quot;Counting to zero:&quot;)// Counting to zero:while currentValue != 0 {    print(&quot;\(currentValue)... &quot;)    currentValue = moveNearerToZero(currentValue)}print(&quot;zero!&quot;)// 3...// 2...// 1...// zero!</code></pre><ul><li>嵌套函数</li></ul><p>函数可以定义在别的函数体中，称为嵌套函数，默认情况下,嵌套函数对外界不可见，但是可以被他们的外围函数调用，一个外围函数可以返回他的某个嵌套函数，使得这个函数可以在其他域中被使用。下面例子chooseStepFunction(backward:) 函数：</p><pre><code>func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {func stepForward(input: Int) -&gt; Int { return input + 1 }func stepBackward(input: Int) -&gt; Int { return input - 1 }return backward ? stepBackward : stepForward}var currentValue = -4let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero now refers to the nested stepForward() functionwhile currentValue != 0 {    print(&quot;\(currentValue)... &quot;)    currentValue = moveNearerToZero(currentValue)}print(&quot;zero!&quot;)// -4...// -3...// -2...// -1...// zero!</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是自包含的函数代码块，可以在代码中被传递和使用。闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。swift会管理在捕获过程中涉及的所有内存操作。前面介绍的全局和嵌套函数实际也是特殊的闭包。闭包采用如下三种形式之一:</p><pre><code>1. 全局函数是一个有名字但不会捕获任何值得闭包2. 嵌套函数是一个有名字并可以捕获其封闭函数域内值得闭包3. 闭包表达式是一个利用轻量级语法所写的可以捕获上写问中变量或常量的匿名闭包。</code></pre><p>swift的闭包表达式风格简单，鼓励在常见场景中进行语法优化，主要优化如下：</p><pre><code>1. 利用上下文推断参数和返回值类型2. 隐式返回单表达式闭包，即表达式闭包可以省略return关键字3. 参数名称缩写4. 尾随闭包语法</code></pre><h4 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h4><p>闭包表达式是一种构建内敛闭包的方式，语法简洁，在保证不丢失它语法清晰明了的同时，闭包表达式提供了几种优化的语法简写形式，下面例子通过对sorted(by:)这个案例的多次迭代改进来展示这个过程：</p><p> swift标准库提供了 sorted(by:)的方法。会基于提供的闭包表达式的判断结果对数组中的值进行排序，一旦完成排序过程，该方法返回一个与就数组大小相同类型的新数组，该数组的元素有着正确的排序顺序，原数组不会被该方法修改。</p><p>sorted(by:)方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔值表明排序顺序。</p><pre><code>let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]func backward(_ s1: String, _ s2: String) -&gt; Bool {    return s1 &gt; s2} //倒序排列var reversedNames = names.sorted(by: backward)// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</code></pre><ul><li>闭包表达式语法</li></ul><p>闭包表达式有如下一般形式:</p><pre><code>{ (parameters) -&gt; return type in    statements}</code></pre><p>闭包表达式参数可以是inout参数，但不能设定默认值，如果命名了可变参数，可以使用可变参数，元组也可以作为参数和返回值。如下是backward函数对应闭包表达式代码：</p><pre><code>reversedNames = names.sorted(by: { (s1: String, s2:     String) -&gt; Bool in        return s1 &gt; s2})</code></pre><p>需要注意的是内敛闭包参数和返回值类型声明与backward(<em>:</em>:)类型声明相同。但在内连闭包表达式中，<strong>函数和返回值类型都写在大括号内而不是大括号外</strong>。<strong>闭包的函数体部分由关键字in</strong>引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。 </p><ul><li>根据上下文推断类型</li></ul><p>sorted(by:)方法的参数是传入的，swift可以推断其参数和返回值类型，sorted被一个字符串数组调用，因此参数必须为(string,string)-&gt;bool类型的函数。这意味者(string,string) 和bool类型不需要作为闭包表达式的一部分，因为所有的类型都可以被正确推断，返回箭头和围绕在参数周围的括号也可以省略：</p><pre><code>reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )//类型推断省略了参数类型以及箭头</code></pre><p>实际上，通过闭包表达式构造的闭包作为参数传递给函数或者方法时，总是可以推断出闭包的参数和返回值类型。因此可以不需要完整的格式构造内联闭包。</p><ul><li>但表达式闭包的隐式返回</li></ul><p>单行表达式闭包可以通过省略return来隐式返回单行表达式的结果。</p><pre><code>reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )</code></pre><ul><li>参数名称缩写</li></ul><p>swift自动为内联闭包提供了参数名称缩写，可以通过$0,$1,$2…来顺序调用闭包参数。</p><p>如果在闭包表达式中使用名称缩写，可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。in关键字也可以省略，因为此时闭包表达式完全由闭包函数体构成。</p><pre><code>reversedNames = names.sorted(by: { $0 &gt; $1 } )</code></pre><ul><li>运算符方法</li></ul><p>swift中的string类型定义了关于大于号(&gt;)的字符串实现，其作为一个函数接受两个string类型的参数并返回bool类型。刚好满足sorted函数的参数要求。因此可以如下:</p><pre><code>reversedNames = names.sorted(by: &gt;)</code></pre><ul><li>尾随闭包</li></ul><p>如果<strong>需要将一个很长的闭包表达式作为最后一个参数传递给函数</strong>，这个闭包替换成尾随闭包的形式效果更好。尾随闭包格式如下：</p><pre><code>    func someFunctionThatTakesAClosure(closure: () -&gt; Void) {    // 函数体部分}// 以下是不使用尾随闭包进行函数调用someFunctionThatTakesAClosure(closure: {    // 闭包主体部分})// 以下是使用尾随闭包进行函数调用someFunctionThatTakesAClosure() {    // 闭包主体部分}</code></pre><p>在闭包表达式语法章节字符串闭包可以作为尾随闭包的形式改写为：</p><pre><code>reversedNames = names.sorted() { $0 &gt; $1 }</code></pre><p>当闭包表达式时函数或者方法的唯一参数，当你使用尾随闭包时，可以省略为如下：</p><pre><code>reversedNames = names.sorted { $0 &gt; $1 } //省略括号</code></pre><p>当闭包非常长不能一行书写时，尾随闭包非常有用。举例来说，下面介绍了如何在map(_:)方法中使用尾随闭包将Int类型数组[16,58,510]转换为包含对应string类型的值的数组。</p><pre><code>let digitNames = [0: &quot;Zero&quot;, 1: &quot;One&quot;, 2: &quot;Two&quot;,   3: &quot;Three&quot;, 4: &quot;Four&quot;,5: &quot;Five&quot;, 6: &quot;Six&quot;, 7: &quot;Seven&quot;, 8: &quot;Eight&quot;, 9: &quot;Nine&quot;]let numbers = [16, 58, 510]</code></pre><p>上述代码创建了一个整型数位和他们英文名映射的字典，和一个转换数组。现在可以通过传递一个尾随闭包给numbers数组的map(_:)方法来创建对应的字符串版本数组。</p><pre><code>let strings = numbers.map {(number) -&gt; String invar number = numbervar output = &quot;&quot;repeat {    output = digitNames[number % 10]! + output    number /= 10} while number &gt; 0return output}// strings 常量被推断为字符串类型数组，即 [String]// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code></pre><p>上述例子中，number为前面定义的局部变量，因此可以在闭包函数体内对其进行修改。闭包表达式指定了返回类型为string。闭包表达式每次调用时创建一个output并返回结果。</p><ul><li>值捕获</li></ul><p>闭包可以在其被定义的上下文中捕获常量或者变量。即使定义这些常量的原作用域已经不存在，但是闭包任然可以在闭包函数体内引用和修改这些值。swift中捕获值得最简单形式是嵌套函数，嵌套函数可以捕获其外部函数得所有参数以及定义得常量和变量。</p><ul><li>闭包是引用类型</li></ul><p>无论是将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或者变量的值设置为对应函数或闭包的引用。这意味着将闭包赋值给两个不同的常量或者变量，两个值都指向同一个闭包。</p><p>逃逸闭包，自动闭包参考<a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/07_closures" target="_blank" rel="noopener">https://swiftgg.gitbook.io/swift/swift-jiao-cheng/07_closures</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h3&gt;&lt;p&gt;swift统一的函数语法非常灵活，可以用来表示任何函数，包括最简单的没有参数名字的c风格函数，到复杂的带局部外部参数名的OC风格参数，参数可以听过默认值，以简化函数调用。参数也可以及当作传入参数，也当作传出参数。也就是说，一旦函数执行，传入的参数值会被修改。&lt;/p&gt;
&lt;p&gt;swift中每一个函数都有一个由函数的参数类型和返回值类型组成的类型。可以把函数类型当作任何其他变量类型处理。这样可以简单的把函数当作别的函数的参数。也可以从其他函数中返回函数。函数定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现封装。&lt;/p&gt;</summary>
    
    
    
    <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
    <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift语法基础(三)</title>
    <link href="http://yoursite.com/2020/01/17/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%B8%89/"/>
    <id>http://yoursite.com/2020/01/17/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%B8%89/</id>
    <published>2020-01-17T04:23:04.000Z</published>
    <updated>2020-01-23T07:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><p>swift使用数组，集合，字典三种基本的集合类型用来存储集合数据，数组是有序数据的集，集合是无序数据的集，字典是无序的键值对的集。</p><p>swift中的数组，集合和字典必须明确其中保存的键和值类型，这样可以防止插入数据类型不一致。</p><ul><li>集合的可变性</li></ul><p>如果创建一个数组，集合或者字典并且把它分配成一个变量，那么这个集合将会是可变的。可以进行增删数据。如果是常量则它的大小和内容都不可变。</p><a id="more"></a> <h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组中相同的值可以出现在一个数组不同位置多次。简单语法为： Array &lt; Element&gt;，Element是这个数组中允许的数据类型，可以使用简单语法[Element]。</p><ul><li>创建空数组</li></ul><p>使用下面语法创建一个空数组：</p><pre><code>var someInts = [Int]()print(&quot;someInts is of type [Int] with \(someInts.count) items.&quot;)// 打印“someInts is of type [Int] with 0 items.”</code></pre><p>如果代码中提供了类型信息，可以使用空数组语句将一个数组改为空数组</p><pre><code>someInts.append(3)// someInts 现在包含一个 Int 值someInts = []// someInts 现在是空数组，但是仍然是 [Int] 类型的。</code></pre><ul><li>创建一个带有默认值的数组</li></ul><p>swift中可以创建特定大小并且所有数据都被默认构造的方法。如下：</p><pre><code>var threeDoubles = Array(repeating: 0.0, count: 3)// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]</code></pre><ul><li>两个数组相加创建一个数组</li></ul><p>可以使用+来组合两个已经存在的相同类型数组，</p><pre><code>var anotherThreeDoubles = Array(repeating: 2.5, count: 3)// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]var sixDoubles = threeDoubles + anotherThreeDoubles// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</code></pre><ul><li>使用数组字面量构造数组</li></ul><p>可以使用数组字面量构造数组，这与C语言类似：</p><pre><code>var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]// shoppingList 已经被构造并且拥有两个初始项。//由于swift的类型推断机制 ，可以这样写：var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]</code></pre><ul><li>访问和修改数组</li></ul><p>可以通过数组的方法和属性来访问和修改数组，或者使用下标</p><pre><code>//使用count属性获取数组数据项数量    print(&quot;The shopping list contains \(shoppingList.count) items.&quot;)// 输出“The shopping list contains 2 items.”（这个数组有2个项）</code></pre><p>使用isEmpty属性检查数组是否为空，使用append(_:)方法哎数组后面增加数据项：</p><pre><code>shoppingList.append(&quot;Flour&quot;)// shoppingList 现在有3个数据项</code></pre><p>使用+=  + 属性进行同类型数组的数据增加</p><pre><code>shoppingList += [&quot;Baking Powder&quot;]// shoppingList 现在有四项了shoppingList += [&quot;Chocolate Spread&quot;, &quot;Cheese&quot;, &quot;Butter&quot;]// shoppingList 现在有七项了</code></pre><p>使用下标语法获取数据项，下标从0开始。注意下标不能溢出。</p><p><strong>还可以使用下标改变一系列的值，即使更新前后的数据量不同，也正确</strong></p><pre><code>shoppingList[4...6] = [&quot;Bananas&quot;, &quot;Apples&quot;]// shoppingList 现在有6项//将三个数据替换为两个数据</code></pre><p>使用insert(_:at:)方法在某个<strong>指定索引值之前</strong>添加数据项</p><pre><code>shoppingList.insert(&quot;Maple Syrup&quot;, at: 0)// shoppingList 现在有7项// 现在是这个列表中的第一项是“Maple Syrup”</code></pre><p>使用remover(at:)方法溢出数组中某一项，并且返回被溢出的数据项</p><pre><code>let mapleSyrup = shoppingList.remove(at: 0)// 索引值为0的数据项被移除</code></pre><p><strong>值得注意的是，数据被溢出后，空出项会被自动填补。</strong></p><p>如果通过是需要每个数据项的值和索引值，使用enumerated()方法遍历数组，enumerated()返回一个由索引值和数据值组成的元组数组。索引下标从0开始：</p><pre><code>for (index, value) in shoppingList.enumerated() {    print(&quot;Item \(String(index + 1)): \(value)&quot;)}// Item 1: Six eggs// Item 2: Milk// Item 3: Flour// Item 4: Baking Powder// Item 5: Bananas</code></pre><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合用来存储相同类型并且没有确定顺序的值，**当集合元素顺序不重要时或者希望确保每个元素只出现依次时可以使用集合。</p><ul><li>集合类型的hash值</li></ul><p>一个类型为了存储在集合中，该类型必须是可hash化的，即该类型必须提供一个方法来计算它的哈希值，哈希值类型是Int，相等的对象hash值必须相同，比如a==b，因此必须使用a.hashvalue==b.hashvalue. swift中所有基本类型都是可hash化的。可以作为集合值得类型或者字典键的类型。没有关联值得枚举成员值默认也是可hash化的。</p><ul><li>集合类型语法</li></ul><p>集合类型被写为Set&lt; Element&gt;，这里Element表示集合中允许存储的类型。</p><ul><li>创建一个空的集合</li></ul><p>可以通过构造器创建一个特定类型的空集合</p><pre><code>var letters = Set&lt;Character&gt;()print(&quot;letters is of type Set&lt;Character&gt; with \(letters.count) items.&quot;)// 打印“letters is of type Set&lt;Character&gt; with 0 items.”</code></pre><p>可以通过上下文提供的类型信息，将一个集合设置为空的集合。</p><pre><code>letters.insert(&quot;a&quot;)// letters 现在含有1个 Character 类型的值letters = []// letters 现在是一个空的 Set，但是它依然是 Set&lt;Character&gt; 类型</code></pre><ul><li>使用数组字面量创建集合</li></ul><p>使用数组字面量来构造集合，与c语言类似</p><pre><code>var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]// favoriteGenres 被构造成含有三个初始值的集合</code></pre><p>由于swift的推断功能，可以无须写出集合类型，根据成员推断出</p><pre><code>var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]</code></pre><ul><li>访问和修改集合</li></ul><p>可以通过集合的属性和方法进行访问和修改</p><p>使用count属性获取集合元素数量。</p><p>使用isEmpty属性检查集合是否为空</p><p>使用insert(_:)插入一个新元素。</p><pre><code>favoriteGenres.insert(&quot;Jazz&quot;)// favoriteGenres 现在包含4个元素</code></pre><p>使用remove属性删除一个元素，如果是该元素存在则返回删除的元素，否则返回nil。可以通过removeAll()方法删除所有元素。</p><pre><code>let removedGenre = favoriteGenres.remove(&quot;Rock&quot;)</code></pre><p>使用contains(_:)方法检察一个集合中是否包含特定的值。返回一个bool值。</p><p>可以在for-in循环中遍历一个集合所有成员：</p><pre><code>for genre in favoriteGenres {    print(&quot;\(genre)&quot;)}</code></pre><p><strong>notice：</strong>swift中Set类型没有确定顺序，为了保证返回一个有序数组，可以使用sorted()方法遍历集合，将元素按字典序排列后遍历。</p><pre><code>for genre in favoriteGenres.sorted() {    print(&quot;\(genre)&quot;)}// Classical// Hip hop// Jazz</code></pre><ul><li>集合操作</li></ul><p>可以使用集合的特性完成一些操作。比如判断两个集合是否全包含，部分包含或者不相交。</p><p>下图描述了集合a和b，以及通过阴影部分显示集合各种操作的结果。</p><p><img src="/2020/01/17/swift语法基础-三/set.png" alt="set"></p><p>如上图：</p><p>使用inertsection(_:)方法根据两个集合的交集创建一个新的集合。</p><p>使用 symmetricDifference(_:) 方法根据两个集合不相交的值创建一个新的集合。</p><p>使用union(_:)方法根据两个集合的所有值创建一个新的集合。</p><p>使用subtracting(_:)方法根据不再一个集合中的值创建一个新的集合。</p><pre><code>let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sorted()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.intersection(evenDigits).sorted()// []oddDigits.subtracting(singleDigitPrimeNumbers).sorted()// [1, 9]oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()// [1, 2, 9]</code></pre><ul><li>集合成员关系和相等</li></ul><p>下图描述了三个集合a,b,c以及通过重叠区域表述集合间共享的元素，a是b的父集合，b是a的子集合。b和c是不相交集合。</p><p><img src="/2020/01/17/swift语法基础-三/set2.png" alt="set2"></p><p>如上图：<br>使用 == 判断两个集合<strong>包含的值</strong>是否相同</p><p>使用isSubset(of:)方法判断一个集合中的所有值是否也被包含在另外一个集合中。</p><p>使用isSuperset(of:)方法判断一个集合是否包含另外一个集合所有值。</p><p>使用isStrictSubset(of:)或者isStrictSuperset(of:)方法判断一个集合是否是另外一个集合子集合或者父集合并且两个集合并不相等。</p><pre><code>let houseAnimals: Set = [&quot;🐶&quot;, &quot;🐱&quot;]let farmAnimals: Set = [&quot;🐮&quot;, &quot;🐔&quot;, &quot;🐑&quot;, &quot;🐶&quot;, &quot;🐱&quot;]let cityAnimals: Set = [&quot;🐦&quot;, &quot;🐭&quot;]houseAnimals.isSubset(of: farmAnimals)// truefarmAnimals.isSuperset(of: houseAnimals)// truefarmAnimals.isDisjoint(with: cityAnimals)// true</code></pre><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典是一种无序的集合，存储的是键值对间的关系，所有键和值的类型需要相同。一个key对应一个value。</p><ul><li>字典简单语法</li></ul><p>使用Dictionary&lt;key,value&gt;定义。也可以使用 [key:value]这样的简化定义。</p><ul><li>创建一个空字典</li></ul><p>使用类似数组的方式创建一个空字典</p><pre><code>var namesOfIntegers = [Int: String]()// namesOfIntegers 是一个空的 [Int: String] 字典</code></pre><p>如果上下文已经提供了类型信息，可以使用字面量来创建一个空字典，记作[:]</p><pre><code>namesOfIntegers[16] = &quot;sixteen&quot;// namesOfIntegers 现在包含一个键值对namesOfIntegers = [:]// namesOfIntegers 又成为了一个 [Int: String] 类型的空字典</code></pre><ul><li>使用字典字面量创建字典</li></ul><p>这个方法与之前创建数组类似：</p><pre><code>var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]//简化版var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]</code></pre><ul><li>访问和修改字典</li></ul><p>使用只读的count属性获取字典的数据项数量</p><p>使用isEmpty属性检查字典是否为空</p><p>使用下标语法给字典增加新的数据项。</p><pre><code>airports[&quot;LHR&quot;] = &quot;London&quot;// airports 字典现在有三个数据项</code></pre><p>使用updataeValue(_:forkey:)方法可以更新特定键值对的值。<strong>这个方法会返回更新前的value值</strong>，</p><pre><code>if let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUB&quot;) {    print(&quot;The old value for DUB was \(oldValue).&quot;)}// 输出“The old value for DUB was Dublin.”</code></pre><p>使用removeValue(forkey:)方法在字典中移除键值对。这个方法在键值对存在时会返回被移除的值或者不存在时返回nil。</p><ul><li>字典遍历</li></ul><p>使用for-in遍历某个字典，每个数据项都已键值对形式返回，可以使用临时常量或者变量分解这些元组。</p><pre><code>for (airportCode, airportName) in airports {    print(&quot;\(airportCode): \(airportName)&quot;)}// YYZ: Toronto Pearson// LHR: London Heathrow//访问key属性for airportCode in airports.keys {    print(&quot;Airport code: \(airportCode)&quot;)}// Airport code: YYZ// Airport code: LHR//访问value属性for airportName in airports.values {    print(&quot;Airport name: \(airportName)&quot;)}// Airport name: Toronto Pearson// Airport name: London Heathrow</code></pre><p>如果需要字典的键集合或者值集合。可以使用如下方法构建一个新数组：</p><pre><code>let airportCodes = [String](airports.keys)// airportCodes 是 [&quot;YYZ&quot;, &quot;LHR&quot;]let airportNames = [String](airports.values)// airportNames 是 [&quot;Toronto Pearson&quot;, &quot;London Heathrow&quot;]</code></pre><p>需要有序遍历字典，可以使用sorted()方法。</p><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>swift提供了多种控制流结构，包括while， if，guard，switch，break，countinue，for-in。</p><h4 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h4><p>使用for-in遍历集合中所有元素，或者某个范围内元素</p><pre><code>let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]for name in names {    print(&quot;Hello, \(name)!&quot;)}// Hello, Anna!// Hello, Alex!// Hello, Brian!// Hello, Jack!</code></pre><p>可以限定范围：</p><pre><code>for index in 1...5 {        print(&quot;\(index) times 5 is \(index * 5)&quot;)}// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25</code></pre><p>如果不需要区间内的每一项，可以使用_忽略：</p><pre><code>let base = 3let power = 10var answer = 1for _ in 1...power {    answer *= base}print(&quot;\(base) to the power of \(power) is \(answer)&quot;)// 输出“3 to the power of 10 is 59049”</code></pre><p>使用stride(from:through:by),可以遍历某一个间隔</p><pre><code>let hours = 12let hourInterval = 3for tickMark in stride(from: 3, through: hours, by: hourInterval) {    // 每3小时渲染一个刻度线（3, 6, 9, 12）}</code></pre><h4 id="while循环和-Repeat-While"><a href="#while循环和-Repeat-While" class="headerlink" title="while循环和 Repeat-While"></a>while循环和 Repeat-While</h4><p>while循环，每次在循环开始时计算条件是否满足。</p><p>repeat-while循环，每次在循环结束时计算条件是否满足。</p><h4 id="if语句和switch语句"><a href="#if语句和switch语句" class="headerlink" title="if语句和switch语句"></a>if语句和switch语句</h4><p>swift中的if使用和c语言中一致。</p><p>switch尝试把某个值与若干个case匹配i，匹配成功时执行相应代码。执行完相对应的case语句后不需要break可以自行跳出。</p><p><strong>notice：</strong>每个case语句必须包含至少一条语句。</p><p>swift中的case分支可以是一个值区间：</p><pre><code>let approximateCount = 62let countedThings = &quot;moons orbiting Saturn&quot;let naturalCount: Stringswitch approximateCount {case 0:    naturalCount = &quot;no&quot;case 1..&lt;5:    naturalCount = &quot;a few&quot;case 5..&lt;12:    naturalCount = &quot;several&quot;case 12..&lt;100:    naturalCount = &quot;dozens of&quot;case 100..&lt;1000:    naturalCount = &quot;hundreds of&quot;default:    naturalCount = &quot;many&quot;}print(&quot;There are \(naturalCount) \(countedThings).&quot;)// 输出“There are dozens of moons orbiting Saturn.”</code></pre><p>可以使用元组在同一个switch语句中测试多个值：</p><pre><code>let somePoint = (1, 1)switch somePoint {case (0, 0):    print(&quot;\(somePoint) is at the origin&quot;)case (_, 0):    print(&quot;\(somePoint) is on the x-axis&quot;)case (0, _):    print(&quot;\(somePoint) is on the y-axis&quot;)case (-2...2, -2...2):    print(&quot;\(somePoint) is inside the box&quot;)default:    print(&quot;\(somePoint) is outside of the box&quot;)}// 输出“(1, 1) is inside the box”</code></pre><ul><li>值绑定</li></ul><p>case分支允许将匹配的值声明为临时变量或者常量，并且允许在case分支内使用。这成为值绑定。</p><pre><code>let anotherPoint = (2, 0)switch anotherPoint {case (let x, 0):    print(&quot;on the x-axis with an x value of \(x)&quot;)case (0, let y):    print(&quot;on the y-axis with a y value of \(y)&quot;)case let (x, y):    print(&quot;somewhere else at (\(x), \(y))&quot;)}//此处最后一个case可以匹配所有剩余情况    // 输出“on the x-axis with an x value of 2”</code></pre><ul><li>where</li></ul><p>case分支可以使用<strong>where</strong>关键字来判断额外条件</p><pre><code>let yetAnotherPoint = (1, -1)switch yetAnotherPoint {case let (x, y) where x == y:    print(&quot;(\(x), \(y)) is on the line x == y&quot;)case let (x, y) where x == -y:    print(&quot;(\(x), \(y)) is on the line x == -y&quot;)case let (x, y):    print(&quot;(\(x), \(y)) is just some arbitrary point&quot;)}// 输出“(1, -1) is on the line x == -y”</code></pre><ul><li>复合型case</li></ul><p>当多个条件可以使用同一种方法来处理时，可以将几种可能放在一个case后面，用逗号隔开。</p><pre><code>let someCharacter: Character = &quot;e&quot;switch someCharacter {case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;:    print(&quot;\(someCharacter) is a vowel&quot;)case &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;,     &quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;:    print(&quot;\(someCharacter) is a consonant&quot;)default:    print(&quot;\(someCharacter) is not a vowel or a consonant&quot;)}// 输出“e is a vowel”</code></pre><h4 id="控制转移语句"><a href="#控制转移语句" class="headerlink" title="控制转移语句"></a>控制转移语句</h4><ul><li>continue</li></ul><p>告诉循环体立刻停止本次循环，开始下一次循环。</p><ul><li>break</li></ul><p>立刻结束整个控制流的执行。</p><ul><li><p>Fallthrough<br>fallthrough 简单地使代码继续连接到下一个 case 中的代码，这和 C 语言标准中的 switch 语句特性是一样的。</p><p>  let integerToDescribe = 5<br>  var description = “The number (integerToDescribe) is”<br>  switch integerToDescribe {<br>  case 2, 3, 5, 7, 11, 13, 17, 19:</p><pre><code>description += &quot; a prime number, and also&quot;fallthrough</code></pre><p>  default:</p><pre><code>description += &quot; an integer.&quot;</code></pre><p>  }<br>  print(description)<br>  // 输出“The number 5 is a prime number, and also an integer.”</p></li><li><p>带标签的语句和guard</p></li></ul><p>参考此处：</p><p><a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/05_control_flow" target="_blank" rel="noopener">https://swiftgg.gitbook.io/swift/swift-jiao-cheng/05_control_flow</a></p><ul><li>检测API可用性</li></ul><p>swift内置支持API可用性，可以确保我们不会在当前部署机器上使用不可用API。</p><pre><code>if #available(iOS 10, macOS 10.12, *) {// 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API} else {    // 使用先前版本的 iOS 和 macOS 的 API}</code></pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;集合类型&quot;&gt;&lt;a href=&quot;#集合类型&quot; class=&quot;headerlink&quot; title=&quot;集合类型&quot;&gt;&lt;/a&gt;集合类型&lt;/h3&gt;&lt;p&gt;swift使用数组，集合，字典三种基本的集合类型用来存储集合数据，数组是有序数据的集，集合是无序数据的集，字典是无序的键值对的集。&lt;/p&gt;
&lt;p&gt;swift中的数组，集合和字典必须明确其中保存的键和值类型，这样可以防止插入数据类型不一致。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集合的可变性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果创建一个数组，集合或者字典并且把它分配成一个变量，那么这个集合将会是可变的。可以进行增删数据。如果是常量则它的大小和内容都不可变。&lt;/p&gt;</summary>
    
    
    
    <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
    <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift语法基础(二)</title>
    <link href="http://yoursite.com/2020/01/15/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/01/15/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%BA%8C/</id>
    <published>2020-01-15T05:17:45.000Z</published>
    <updated>2020-01-17T04:20:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h3><p>swift中包含了C中所有的基础数据类型，Int，Double，Float，Bool，String。还提供了三种基本的集合类型，Array，Set，Dictionary。参考集合类型部分。</p><p>在swift中广泛使用值不可变的变量即常量，在swift中，如果你要处理的值不需要改变，那使用常量可使代码更加安全。</p><p>swift中还增加了高阶数据类型比如元组（Tuple），元组可以创建或者传递一组数据。作为一组返回值时，可以使用一个元组返回多个值。swift增加了可选类型，可选表示 “那儿有一个值，并且它等于 x ” 或者 “那儿没有值” 。</p><p>swift时一门类型安全的语言，这意味着swift可以让你清楚地知道值得类型。</p><a id="more"></a> <h4 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h4><p>常量和变量必须在使用前声明，使用var声明变量，使用let声明常量。</p><pre><code>let maximumNumberOfLoginAttempts = 10var currentLoginAttempt = 0</code></pre><p>可以在一行中声明多个常量或者变量，使用逗号隔开</p><pre><code>var x = 0.0, y = 0.0, z = 0.0</code></pre><h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><p>当声明得常量或者变量时可以加上<em>类型注解</em>，说明要存储得值的类型。格式为：</p><pre><code>var welcomeMessage: StringwelcomeMessage = &quot;Hello&quot;</code></pre><p>可以在一行中定义多个同样类型的变量，使用逗号分隔，在最后一个变量名之后添加类型注解：</p><pre><code>var red, green, blue: Double//一般来说很少使用类型注解，在声明常量或者变量的时候赋给了初值，编译器可以推断出类型。</code></pre><p>常量和变量名不能包含数学符号，箭头，保留的Unicode码位，连线与制表符.也不能以数字开头。</p><h4 id="输出常量和变量"><a href="#输出常量和变量" class="headerlink" title="输出常量和变量"></a>输出常量和变量</h4><p>使用print(_:separator:terminator:) 函数来输出当前常量或变量的值:print是一个用来输出一个或者多个值到适当输出区的全局函数，输出内容到console上，默认情况下，该函数通过添加换行符来结束当前行，如果不想换行，可以传递空字符串给terminator，比如：print(someValue, terminator:””)。</p><p>也可以使用 \ ()的方式将字符串进行转义。</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>swift中的注释和c语言中注释相似， 使用双斜杠。多行注释也相同。</p><p>swift并不要求在每条语句结尾处使用分号，也可以添加分号。</p><h4 id="整数，整数范围"><a href="#整数，整数范围" class="headerlink" title="整数，整数范围"></a>整数，整数范围</h4><p>可以使用不同整数类型的min和max属性来获取对应类型的最小值和最大值</p><pre><code>let minValue = UInt8.min  // minValue 为 0，是 UInt8 类型let maxValue = UInt8.max  // maxValue 为 255，是 UInt8 类型</code></pre><p>Int：在32位平台上与Int32长度相同，在64位平台上与Int64相同</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数类型比整数类型表示范围更大，Double表示64位浮点数，Float表示32位浮点数。</p><h4 id="类型安全和类型推断"><a href="#类型安全和类型推断" class="headerlink" title="类型安全和类型推断"></a>类型安全和类型推断</h4><p>Swift 是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个 String，你绝对不可能不小心传进去一个 Int。因此会在编译时进行类型检查。</p><p>如果表达式中同时出现了整数和浮点数，会被推断为Double类型：</p><pre><code>let anotherPi = 3 + 0.14159// anotherPi 会被推测为 Double 类型</code></pre><h4 id="数值型字面量"><a href="#数值型字面量" class="headerlink" title="数值型字面量"></a>数值型字面量</h4><ul><li><p>一个十进制数，没有前缀</p></li><li><p>一个二进制数，前缀0b</p></li><li><p>一个八进制数，前缀0o</p></li><li><p>一个十六进制数，前缀0x</p><p>  let decimalInteger = 17<br>  let binaryInteger = 0b10001       // 二进制的17<br>  let octalInteger = 0o21           // 八进制的17<br>  let hexadecimalInteger = 0x11     // 十六进制的17</p></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>不同类型的变量和常量如果超过范围编译器会报错</p><pre><code>let cannotBeNegative: UInt8 = -1// UInt8 类型不能存储负数，所以会报错let tooBig: Int8 = Int8.max + 1// Int8 类型不能存储超过最大值的数，所以会报错</code></pre><p>要将一种数字类型转换为另一种。要用当前值来初始化一个期望类型的新数字。如下：</p><pre><code>let twoThousand: UInt16 = 2_000let one: UInt8 = 1//UInt8和UInt16不能直接计算，需要转换let twoThousandAndOne = twoThousand + UInt16(one)</code></pre><p>SomeType(ofInitialValue)调用swift构造器并传入一个一个初值的默认方法。</p><ul><li><p>整数和浮点数转换<br>整数和浮点数的转换必须显式指定类型：</p><pre><code>let three = 3let pointOneFourOneFiveNine = 0.14159let pi = Double(three) + pointOneFourOneFiveNine// pi 等于 3.14159，所以被推测为 Double 类型，如果不进行转化无法相加</code></pre></li><li><p>浮点数到整数<br>浮点数到整数的转换会阶段小数部分。 </p><pre><code>let pi=3.14159let integerPi = Int(pi)    // integerPi 等于 3，所以被推测为 Int 类型</code></pre></li></ul><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名(type aliases)就是给现有类型定义另一个名字，使用关键字<strong>typealias</strong>：</p><pre><code>typealias AudioSample = UInt16var maxAmplitudeFound = AudioSample.min// maxAmplitudeFound 现在是 0</code></pre><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>Bool值包括true和false。在if判断和控制流作为条件。需要注意的是，当编写条件语句时，如果使用非Bool值则会报错</p><pre><code>let i = 1if i { //i不是布尔值// 这个例子不会通过编译，会报错}let i = 1if i == 1 {  //i==1是布尔值// 这个例子会编译成功}    </code></pre><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组是把多个值组成一个复合值。元组内的值可以是任意类型，<strong>并不要求是相同类型</strong>，如下http状态码：</p><pre><code>let http404Error = (404, &quot;Not Found&quot;)// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)</code></pre><p>元组可以是两个或两个以上类型的组合，比如(Int,Int,Double)。<br>可以将一个元组的内容分解为单独的常量或者变量，就可以正常使用了。</p><pre><code>let (statusCode, statusMessage) = http404Errorprint(&quot;The status code is \(statusCode)&quot;)// 输出“The status code is 404”print(&quot;The status message is \(statusMessage)&quot;)// 输出“The status message is Not Found”</code></pre><p>如果只需要其中一部分元组，分解的时候可以把忽略的部分用下划线(_)标记：</p><pre><code>let (justTheStatusCode, _) = http404Errorprint(&quot;The status code is \(justTheStatusCode)&quot;)// 输出“The status code is 404”</code></pre><p>也可以通过下标访问元组中的某个元素，下标从0开始：</p><pre><code>print(&quot;The status code is \(http404Error.0)&quot;)// 输出“The status code is 404”print(&quot;The status message is \(http404Error.1)&quot;)// 输出“The status message is Not Found”</code></pre><p>给元组中的元素命名后，可以通过名字获取元素的值：</p><pre><code>let http200Status = (statusCode: 200, description: &quot;OK&quot;)//元组命名print(&quot;The status code is \(http200Status.statusCode)&quot;)// 输出“The status code is 200”print(&quot;The status message is \(http200Status.description)&quot;)// 输出“The status message is OK”</code></pre><h4 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h4><p>使用可选类型来处理值可能缺失的情况，可选类型表示两种可能，可以解析可选类型访问这个值， 或者根本没有值。</p><pre><code>let possibleNumber = &quot;123&quot;let convertedNumber = Int(possibleNumber)// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;</code></pre><p>上述String转Int可能失败，因此返回一个可选类型(optional)Int。也即?Int</p><pre><code>var serverResponseCode: Int? = 404// serverResponseCode 包含一个可选的 Int 值 404serverResponseCode = nil// serverResponseCode 现在不包含值    //nil不能用于非可选的常量和变量，如果代码中由常量或者变量需要处理值缺失的情况，声明为可选类型。var surveyAnswer: String?// surveyAnswer 被自动设置为 nil</code></pre><h4 id="if语句以及强制解析"><a href="#if语句以及强制解析" class="headerlink" title="if语句以及强制解析"></a>if语句以及强制解析</h4><p>可以使用if语句和nil比较来判断一个可选值是否包含值，使用==或者!=来判断。 如果可选类型有值，不等于nil：</p><pre><code>if convertedNumber != nil {print(&quot;convertedNumber contains some integer value.&quot;)}// 输出“convertedNumber contains some integer value.”</code></pre><p>-可选绑定<br>使用可选绑定来判断可选类型是否包含值，如果包含就赋值给一个临时常量，如下： </p><pre><code>if let actualNumber = Int(possibleNumber) {print(&quot;\&apos;\(possibleNumber)\&apos; has an integer value of \(actualNumber)&quot;)} else {print(&quot;\&apos;\(possibleNumber)\&apos; could not be converted to an integer&quot;)}// 输出“&apos;123&apos; has an integer value of 123”</code></pre><p><strong>notice：</strong>在if条件句中使用常量或者变量创建一个可选绑定，仅在if条件句的body中有效。</p><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><p>运算符是检查，改变，合并值得特殊符号或者短语。swift支持大部分标准C的运算符，且为了减少常见编码错误进行了部分改进，如：赋值符不再由返回值。算术运算符的结果会被检测并禁止值溢出，以此来避免变量大于或者小于所能表示范围导致的异常。</p><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><pre><code>let b = 10var a = 5a = b// a 现在等于 10</code></pre><p>如果赋值的右边是一个多元组，它的元素可以马上分解成多个常量或者变量：</p><pre><code>let (x, y) = (1, 2)// 现在 x 等于 1，y 等于 2</code></pre><p><strong>notice：</strong>swift赋值操作不返回任何值，因此</p><pre><code>if x = y {// 此句错误，因为 x = y 并不返回任何值}    </code></pre><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>算术运算符除了基本数据类型的运算外，也可用于String的拼接：</p><pre><code>&quot;hello, &quot; + &quot;world&quot;  // 等于 &quot;hello, world&quot;</code></pre><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>所有标准C中的比较运算符都可以在swift中使用。比较运算符多用于if条件语句。</p><p>如果两个元组的元素相同且长度相同，就可以进行比较，比较元组大小会按照从左到右，逐值比较的方式，直到两个值不等停止。</p><pre><code>//元组比较(1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;)   // true，因为 1 小于 2(3, &quot;apple&quot;) &lt; (3, &quot;bird&quot;)    // true，因为 3 等于 3，但是 apple 小于 bird(4, &quot;dog&quot;) == (4, &quot;dog&quot;)      // true，因为 4 等于 4，dog 等于 dog</code></pre><p><strong>notice：</strong>如果元组中包含有Bool类型时不可以进行比较，</p><pre><code>(&quot;blue&quot;, -1) &lt; (&quot;purple&quot;, 1)       // 正常，比较的结果为 true(&quot;blue&quot;, false) &lt; (&quot;purple&quot;, true) // 错误，因为 &lt; 不能比较布尔类型</code></pre><h4 id="空合运算符-Nil-Coalescing-Operator"><a href="#空合运算符-Nil-Coalescing-Operator" class="headerlink" title="空合运算符(Nil Coalescing Operator)"></a>空合运算符(Nil Coalescing Operator)</h4><p>空合运算符(a??b)将对可选类型a进行空判断，如果a包含一个值就进行解包，否则返回一个默认值b。表达式a必须时Optional类型，默认值b要合a存储值类型一致。</p><pre><code>let defaultColorName = &quot;red&quot;var userDefinedColorName: String?   //默认值为 nilvar colorNameToUse = userDefinedColorName ?? defaultColorName// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 &quot;red&quot;</code></pre><h4 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h4><p>swift提供了几种方便表达一个区间的区间运算符</p><ul><li><p>闭区间  (a…b)  定义一个从a到b的闭区间 </p></li><li><p>半开区间 (a..&lt;b) 定义一个从a到b但不包括b的区间，</p></li><li><p>单侧区间 闭区间右另一个表达形式，可以表达往一侧无线延申的区间，</p><pre><code>let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]for name in names[2...] {    print(name)}// Brian// Jackfor name in names[...2] {    print(name)}// Anna// Alex// Brian</code></pre><p>半开区间也有单侧表达形式：</p><pre><code>for name in names[..&lt;2] {    print(name)}// Anna// Alex</code></pre></li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符与c语言中相同，且&amp;&amp; 和|| 都是左结合的运算符，意味着多元逻辑操作从左开始计算，也可以使用括号标明优先级。</p><h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><p>字符串是一系列字符的集合，swift中使用String类型来表示，String中内容的访问可以使用Character值的集合。</p><p>swift中的String和Character类型提供了一种快速且兼容Unicode的方式来处理代码中的文本。</p><h4 id="多行字符串字面量"><a href="#多行字符串字面量" class="headerlink" title="多行字符串字面量"></a>多行字符串字面量</h4><p>如果需要一个字符串是跨越多行的，使用三个双引号包裹的文本字符集：</p><pre><code>let quotation = &quot;&quot;&quot;The White Rabbit put on his spectacles.  &quot;Where shall I begin,please your Majesty?&quot; he asked.&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go ontill you come to the end; then stop.&quot;&quot;&quot;&quot;</code></pre><p>多行字符串在”””包围中。</p><h4 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h4><p>要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个String实例</p><pre><code>var emptyString = &quot;&quot;               // 空字符串字面量var anotherEmptyString = String()  // 初始化方法// 两个字符串均为空并等价。</code></pre><p>通过Bool类型的isEmpty判断字符串是否为空</p><pre><code>if emptyString.isEmpty {    print(&quot;Nothing to see here&quot;)}// 打印输出：“Nothing to see here”</code></pre><h4 id="字符串可变性"><a href="#字符串可变性" class="headerlink" title="字符串可变性"></a>字符串可变性</h4><p>可以通过将一个特定字符串分配给变量对其进行修改，也可以分配一个常量来保证字符串不被修改。</p><h4 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h4><p><strong>在swift中，如果创建一个新的字符串，那么当其进行常量，变量赋值或者在函数中传递时，会进行值拷贝，都会对已有字符串创建新副本，并对该新副本而非原始字符串进行传递或者赋值操作。</strong></p><p>下面例子中使用for-in循环打印字符串中每个字符</p><pre><code>for character in &quot;Dog!🐶&quot; {    print(character)}// D// o// g// !// 🐶</code></pre><p>另外，通过标明一个Character类型并用字符字面量自行赋值，可以建立一个独立的字符常量或者变量。</p><pre><code>let exclamationMark: Character = &quot;!&quot;//创建一个字符</code></pre><p>字符串可以通过传递一个Character类型的数组作为自变量来初始化：</p><pre><code>let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;🐱&quot;]let catString = String(catCharacters)print(catString)// 打印输出：“Cat!🐱”</code></pre><p>字符串可以进行连接，这与c语言相同。使用+ ，+=， append进行字符串连接。</p><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>Unicode是一个用于在不同书写系统中对文本进行编码、表示和处理的国际标准。它使你可以用标准格式表示来自任意语言几乎所有的字符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。Swift 的 String 和 Character 类型是完全兼容 Unicode 标准的。</p><h4 id="计算字符数量"><a href="#计算字符数量" class="headerlink" title="计算字符数量"></a>计算字符数量</h4><p>使用count属性获取字符串中Character的个数。可以通过下标来访问和修改字符串。</p><ul><li>字符串索引 每一个String值都有一个关联的索引类型，String.Index,它对应字符串每个character的位置。<strong>不同的字符可能占用不同数量的内存空间，因此不可以使用integer来索引。</strong></li></ul><p><strong>使用startIndex获取String的第一个character的索引，使用endIndex获取最后一个character的下一位置索引。(和C++迭代器类似)。</strong>如果String是空串，straightIndex和endIndex是相等的。</p><p>使用index(before:) 或者index(after:)方法，可以立即得到前面一个或者后面一个索引。 可以调用index(someString:offsetBy:)方法获取对应偏移量的索引。</p><pre><code>let greeting = &quot;Guten Tag!&quot;greeting[greeting.startIndex]// Ggreeting[greeting.index(before: greeting.endIndex)]// !greeting[greeting.index(after: greeting.startIndex)]// ulet index = greeting.index(greeting.startIndex, offsetBy: 7) //获取偏移下标greeting[index]// a</code></pre><p>获取越界的索引时会报错。</p><ul><li><p>使用indices属性创建一个包含全部索引的范围，用来访问字符串中的单个字符。</p><pre><code>for index in greeting.indices {       print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)}// 打印输出“G u t e n   T a g ! ”</code></pre></li><li><p>插入和删除</p></li></ul><p>调用 insert(_:at:)方法可以在一个字符串的指定索引插入一个<strong>字符</strong>。调用insert(contentsOf:at:)方法可以在一个字符串指定索引插入一个<strong>段字符串</strong></p><pre><code>var welcome = &quot;hello&quot;welcome.insert(&quot;!&quot;, at: welcome.endIndex)// welcome 变量现在等于 &quot;hello!&quot;welcome.insert(contentsOf:&quot; there&quot;, at: welcome.index(before: welcome.endIndex))// welcome 变量现在等于 &quot;hello there!&quot;</code></pre><p>调用remove(at:)可以在一个字符串的指定索引删除一个<strong>字符</strong>。调用removerSubrange(_:)可以在一个字符串的指定索引删除一个<strong>子字符串</strong></p><pre><code>welcome.remove(at: welcome.index(before: welcome.endIndex))// welcome 现在等于 &quot;hello there&quot;let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndexwelcome.removeSubrange(range)// welcome 现在等于 &quot;hello&quot;</code></pre><ul><li>子字符串</li></ul><p>当从字符串中获取一个子串可以使用prefix(_:)方法。就可以得到一个subString实例。 subString中的绝大部分函数和String一样，但是如果需要长时间保存字符串时，使用subString转化为string的方法。</p><pre><code>let greeting = &quot;Hello, world!&quot;let index = greeting.firstIndex(of: &quot;,&quot;) ?? greeting.endIndexlet beginning = greeting[..&lt;index]// beginning 的值为 &quot;Hello&quot;// 把结果转化为 String 以便长期存储。let newString = String(beginning)</code></pre><ul><li>String 和subString的区别<br>subString可以重用原String的内存空间，或者另一个subString的空间。String也有同样优化，但是如果两个String共享内存的话，那么他们相等。</li></ul><p><img src="/2020/01/15/swift语法基础-二/string.png" alt="string"></p><p>如图所示：下方String是重新申请一块内存存放的。而subString和原来String共享一块内存空间。</p><h4 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h4><p>swift提供了三种方式比较文本值，字符串字符相等，前缀相等，后缀相等。</p><ul><li><p>字符/字符串相等<br>可以使用==和!=操作符</p><pre><code> let quotation = &quot;We&apos;re a lot alike, you and I.&quot;let sameQuotation = &quot;We&apos;re a lot alike, you and I.&quot;if quotation == sameQuotation {    print(&quot;These two strings are considered equal&quot;)}// 打印输出“These two strings are considered equal”</code></pre></li><li><p>前缀/后缀相等<br>通过调用hasPrefix(<em>:)，hasSuffix(</em>:)检查字符串是否拥有特定的前缀和后缀。 两个方法接受一个String参数，返回一个bool值。</p></li></ul><h4 id="字符串的unicode表示"><a href="#字符串的unicode表示" class="headerlink" title="字符串的unicode表示"></a>字符串的unicode表示</h4><p>当一个 Unicode 字符串被写进文本文件或者其他储存时，字符串中的 Unicode 标量会用 Unicode 定义的几种 编码格式（encoding forms）编码。每一个字符串中的小块编码都被称 代码单元（code units）。这些包括 UTF-8 编码格式（编码字符串为 8 位的代码单元）， UTF-16 编码格式（编码字符串位 16 位的代码单元），以及 UTF-32 编码格式（编码字符串32位的代码单元）。</p><p>UTF8，UTF16,UTF32表示参考</p><p><a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/03_strings_and_characters" target="_blank" rel="noopener">https://swiftgg.gitbook.io/swift/swift-jiao-cheng/03_strings_and_characters</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;基础部分&quot;&gt;&lt;a href=&quot;#基础部分&quot; class=&quot;headerlink&quot; title=&quot;基础部分&quot;&gt;&lt;/a&gt;基础部分&lt;/h3&gt;&lt;p&gt;swift中包含了C中所有的基础数据类型，Int，Double，Float，Bool，String。还提供了三种基本的集合类型，Array，Set，Dictionary。参考集合类型部分。&lt;/p&gt;
&lt;p&gt;在swift中广泛使用值不可变的变量即常量，在swift中，如果你要处理的值不需要改变，那使用常量可使代码更加安全。&lt;/p&gt;
&lt;p&gt;swift中还增加了高阶数据类型比如元组（Tuple），元组可以创建或者传递一组数据。作为一组返回值时，可以使用一个元组返回多个值。swift增加了可选类型，可选表示 “那儿有一个值，并且它等于 x ” 或者 “那儿没有值” 。&lt;/p&gt;
&lt;p&gt;swift时一门类型安全的语言，这意味着swift可以让你清楚地知道值得类型。&lt;/p&gt;</summary>
    
    
    
    <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
    <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift语法基础(一)</title>
    <link href="http://yoursite.com/2020/01/14/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%B8%80/"/>
    <id>http://yoursite.com/2020/01/14/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%B8%80/</id>
    <published>2020-01-14T05:42:19.000Z</published>
    <updated>2020-01-15T05:15:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>寒假开始了1周了，终于也是咸鱼了一周，在今天开始学点东西，既然之后要做ios开发的话，就打算学点swift。整个周期大概20天，先整体看一遍swift的语法，然后去leetcode刷题。因为是windows系统，所以这其中可能会有一些问题。不过只要有开头的话，后面慢慢来就行了。</p><a id="more"></a> <h3 id="swift初见"><a href="#swift初见" class="headerlink" title="swift初见"></a>swift初见</h3><h4 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h4><p> 1.使用let声明常量，使用var来声明变量，常量和变量定义和c语言中一样，常量只能赋值一次。变量可以多次赋值。<strong>可以不用明确的声明类型，这可以由编译器自动判断其类型。</strong>但是如果在申明时没有提供足够的信息表现出类型，需要如下表现：</p><pre><code>//变量和常量var myVariable = 42myVariable = 50let myConstant = 42//类型let implicitInteger = 70let implicitDouble = 70.0let explicitDouble: Double = 70</code></pre><p>2.一个变量或者常量的值类型时保持不变的，如果需要类型转换，请显示进行。</p><pre><code>let label = &quot;The width is&quot;let width = 94let widthLabel = label + String(width)//widthLabel = &quot;The width is 94&quot;</code></pre><p>上面例子中将 整形转化为String,还有一种更简单的值转化为字符串的方式： 把值写道括号中，在括号前加一个反斜杠。</p><pre><code>let apples = 3let oranges = 5let appleSummary = &quot;I have \(apples) apples.&quot;//  &quot;I have 3 apples&quot;let fruitSummary = &quot;I have \(apples + oranges) pieces of fruit.&quot;//  &quot;I have 8 pieces of fruit&quot;</code></pre><p>使用三分双引号来包含多行字符串内容，<strong>每行行首的缩进会被去除</strong>，知道和结尾双引号相互匹配。</p><pre><code>let quotation = &quot;&quot;&quot;I said &quot;I have \(apples) apples.&quot;And then I said &quot;I have \(apples + oranges) pieces of fruit.&quot;&quot;&quot;&quot;//一段三行的String</code></pre><p>3.和c语言类似，使用[]创建数组和字典，使用下标或者key来访问元素，<strong>最后一个元素后面语序有个逗号。</strong></p><pre><code>var shoppingList = [&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;]shoppingList[1] = &quot;bottle of water&quot;//通过下表访问数组var occupations = [&quot;Malcolm&quot;: &quot;Captain&quot;,&quot;Kaylee&quot;: &quot;Mechanic&quot;,]occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot;//通过key访问数组shoppingList.append(&quot;blue paint&quot;)//使用append添加元素</code></pre><p>下面是数组或者字典的创建</p><pre><code>let emptyArray = [String]() //数组let emptyDictionary = [String: Float]() //字典</code></pre><p>如前所述，如果可以推断出是数组或者字典，也可以如下声明：</p><pre><code>var shoppingList = []var occupations = [:]</code></pre><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><p>使用<strong>if</strong>和<strong>switch</strong>来进行条件操作，使用<strong>for-in</strong>，<strong>while</strong>，<strong>repeat-while</strong>来进行循环，包裹条件和循环变量的括号可以省略，但是条件或者循环体的大括号是必须的。</p><p>1.在if语句中，条件表达式必须为一个布尔式。可选值：可选值是一个具体的值或者说是nil表示值缺失。在类型后面加一个问号标记这个变量的值是可选的。</p><pre><code>var optionalName: String? = &quot;John Appleseed&quot;var greeting = &quot;Hello!&quot;if let name = optionalName {    greeting = &quot;Hello, \(name)&quot;}//如果常量name！=nil，执行if条件</code></pre><p>使用<strong>？？</strong>来提供一个默认值，如果可选值缺失，可以使用默认值来代替</p><pre><code>let nickName: String? = nillet fullName: String = &quot;John Appleseed&quot;let informalGreeting = &quot;Hi \(nickName ?? fullName)&quot;//nickname值缺失，使用fullname informalGreeeting=&quot;HI john appleseed&quot;</code></pre><p>2.运行switch语句时，在switch中匹配到case语句后会直接推出，所以不必加上break，但是default需要特别注意。</p><p>3.使用<strong>for-in</strong>来遍历字典，需要一对变量来表示每个键值对，字典时一个无序的集合，所以他们的键和值以任意顺序迭代结束。</p><pre><code>let interestingNumbers = [&quot;Prime&quot;: [2, 3, 5, 7, 11, 13],&quot;Fibonacci&quot;: [1, 1, 2, 3, 5, 8],&quot;Square&quot;: [1, 4, 9, 16, 25],]var largest = 0for (kind, numbers) in interestingNumbers {//kind 和number表示一个键值对     for number in numbers {//number指向numbers的每一个成员        if number &gt; largest {            largest = number        }    }}print(largest)</code></pre><p>while的使用和c语言中一致，但是作为条件的括号可以省略。</p><p>在循环中使用..&lt;表示下标范围。</p><pre><code>var total = 0for i in 0..&lt;4 {total += i}print(total)</code></pre><p>使用 <strong>..&lt;</strong> 创建的范围不包含上界，如果想包含的话需要使用 <strong>…</strong>。</p><h4 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h4><p>1.使用 func 来声明一个函数，使用名字和参数来调用函数。使用 -&gt; 来指定函数返回值的类型。</p><pre><code>//函数调用func greet(person: String, day: String) -&gt; String {return &quot;Hello \(person), today is \(day).&quot;}greet(person:&quot;Bob&quot;, day: &quot;Tuesday&quot;)</code></pre><p>2.使用元组来生成复合值，让一个函数返回多个值，改元组的元素可以用名称或者数字来获取。<br>   //返回值为复合值<br>    func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) {<br>    var min = scores[0]<br>    var max = scores[0]<br>    var sum = 0</p><pre><code>for score in scores {    if score &gt; max {        max = score    } else if score &lt; min {        min = score    }    sum += score}return (min, max, sum)}    let statistics = calculateStatistics(scores:[5, 3, 100, 3, 9])//两种方式访问sumprint(statistics.sum)print(statistics.2)</code></pre><p>3.函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。</p><pre><code>func returnFifteen() -&gt; Int {var y = 10func add() { //函数没有返回值    y += 5}add()return y}returnFifteen()</code></pre><p>函数实际上是一种特殊的闭包，它是一段能之后被调用的代码，闭包中的代码能访问闭包作用于中的变量和函数。即使闭包是在一个不同的作用域被执行的，可以使用{}来创建一个匿名闭包，使用in将参数和返回值类型的声明与闭包函数体进行分离。</p><h4 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h4><p>1.使用class和类名创建一个类，类中属性和的声明和常量变量的声明一样。唯一的区别是他们的上下文是类。</p><pre><code>//创建一个类class Shape {var numberOfSides = 0func simpleDescription() -&gt; String {    return &quot;A shape with \(numberOfSides) sides.&quot;}}</code></pre><p>创建一个类的实例，在类名后面加上括号。使用如下方法访问实例的属性和方法。</p><pre><code>var shape = Shape()shape.numberOfSides = 7var shapeDescription = shape.simpleDescription()</code></pre><p>2.在类中加入构造函数，使用init来创建一个构造器。</p><pre><code>class NamedShape {    var numberOfSides: Int = 0    var name: String    init(name: String) {        self.name = name    }    func simpleDescription() -&gt; String {        return &quot;A shape with \(numberOfSides) sides.&quot;    }}</code></pre><p>注意self用来区别实例变量name和构造器参数name，当创建实例的时候，像传入参数一样给类传入构造器的参数，每个属性都需要赋值。</p><p>3.使用deinit来创建一个析构函数。</p><p>4.子类的定义方法是在其类名后面加上父类的名字，使用冒号分隔。子类如果要重写父类的方法的话，需要使用override标记，编译器会检测override标记的方法是否确实在父类中。</p><pre><code>class Square: NamedShape {var sideLength: Doubleinit(sideLength: Double, name: String) {    self.sideLength = sideLength    super.init(name: name)    numberOfSides = 4}func area() -&gt;  Double {    return sideLength * sideLength}//重写父类方法override func simpleDescription() -&gt; String {    return &quot;A square with sides of length \(sideLength).&quot;}}let test = Square(sideLength: 5.2, name: &quot;my test square&quot;)test.area()test.simpleDescription()</code></pre><h4 id="枚举和结构体"><a href="#枚举和结构体" class="headerlink" title="枚举和结构体"></a>枚举和结构体</h4><p>使用enum来创建一个枚举，枚举可以包含方法。</p><pre><code>enum Rank: Int {case ace = 1case two, three, four, five, six, seven, eight, nine, tencase jack, queen, kingfunc simpleDescription() -&gt; String {    switch self {    case .ace:        return &quot;ace&quot;    case .jack:        return &quot;jack&quot;    case .queen:        return &quot;queen&quot;    case .king:        return &quot;king&quot;    default:        return String(self.rawValue)    }}}let ace = Rank.acelet aceRawValue = ace.rawValue</code></pre><p>上面例子中，使用rawValue属性来访问下一个枚举成员的值。</p><p>使用struct创建一个结构体。结构体和类由很多先攻的地方，包括方法和构造器，他们最大的区别是结构体是传值，类是传引用。</p><pre><code>struct Card {var rank: Rankvar suit: Suitfunc simpleDescription() -&gt; String {    return &quot;The \(rank.simpleDescription()) of \(suit.simpleDescription())&quot;}}//值传递let threeOfSpades = Card(rank: .three, suit: .spades)let threeOfSpadesDescription = threeOfSpades.simpleDescription()</code></pre><h4 id="协议和扩展"><a href="#协议和扩展" class="headerlink" title="协议和扩展"></a>协议和扩展</h4><p>使用protocol来声明一个协议</p><pre><code>protocol ExampleProtocol {    var simpleDescription: String { get }    mutating func adjust()}</code></pre><p>类，枚举和结构体都可以遵循协议。</p><pre><code>   //类继承协议class SimpleClass: ExampleProtocol {var simpleDescription: String = &quot;A very simple class.&quot;var anotherProperty: Int = 69105func adjust() {    simpleDescription += &quot;  Now 100% adjusted.&quot;}}var a = SimpleClass()a.adjust()let aDescription = a.simpleDescription//结构继承协议struct SimpleStructure: ExampleProtocol {var simpleDescription: String = &quot;A simple structure&quot;mutating func adjust() {    simpleDescription += &quot; (adjusted)&quot;}}var b = SimpleStructure()b.adjust()let bDescription = b.simpleDescription</code></pre><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>在尖括号中写一个名字来创建一个泛型函数或者类型</p><pre><code>func makeArray&lt;Item&gt;(repeating item: Item, numberOfTimes: Int) -&gt; [Item] {var result = [Item]()for _ in 0..&lt;numberOfTimes {    result.append(item)}return result}makeArray(repeating: &quot;knock&quot;, numberOfTimes: 4)</code></pre><p>也可以创建泛型函数，方法，类，枚举和结构体。</p><pre><code>// 重新实现 Swift 标准库中的可选类型enum OptionalValue&lt;Wrapped&gt; {case nonecase some(Wrapped)}var possibleInteger: OptionalValue&lt;Int&gt; = .nonepossibleInteger = .some(100)    </code></pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;寒假开始了1周了，终于也是咸鱼了一周，在今天开始学点东西，既然之后要做ios开发的话，就打算学点swift。整个周期大概20天，先整体看一遍swift的语法，然后去leetcode刷题。因为是windows系统，所以这其中可能会有一些问题。不过只要有开头的话，后面慢慢来就行了。&lt;/p&gt;</summary>
    
    
    
    <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
    <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>B+树</title>
    <link href="http://yoursite.com/2019/12/10/B-%E6%A0%91/"/>
    <id>http://yoursite.com/2019/12/10/B-%E6%A0%91/</id>
    <published>2019-12-10T13:15:25.000Z</published>
    <updated>2019-12-22T01:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近需要完成一个构造数据库的索引的实验，实验要求使用B+树做索引结构，因为对于B+树不够了解，所以先复习一下B+树的特性在进行下一步。对于B+树，这篇文章讲的很好。<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/8729425.html</a></p><a id="more"></a> <h3 id="B-树结构特点"><a href="#B-树结构特点" class="headerlink" title="B+树结构特点"></a>B+树结构特点</h3><p>B+tree是应文件系统所需而产生的一种B树的变形树，一棵m阶的B+树的特点：1.有n棵子树的节点中含有n个关键字。2.所有的叶子节点中包含了全部的关键字信息，及指向含有这些关键字记录的指针，且叶子节点本身依关键字的大小自小到大顺序链接。 3.所有的非叶子节点可以堪称是索引部分，节点中仅含有其子树根结点中最大（或最小）关键字。4.B+树的有效内容均在叶子节点。所有叶子节点中有志向兄弟节点的指针5.B+树的头指针有两个，一个指向根节点，一个指向关键字最小的元素,因此B+树有两种遍历方式。从根节点开始随机查询。从最小关键字顺序查询。</p><h3 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h3><p>和其他树形结构一样，B+树也支持插入，删除，遍历等操作。在经过前面两周对B+树的了解后，我认为B+树中最难的应该是元素插入。相对简单的是元素遍历。当然这也是建立在B+树数据结构中具有良好的遍历字段的情况下的。作为同一种数据结构可以不断的修改内部的结构特点，根据实际需要，使得可以方便完成自己的需求。</p><p>现在先讲以下B+树的插入：首先假定B+树每一个节点中可以最多可以包含2m个元素，因此对于任意节点来说，不能少于m个元素。对于每一次插入元素，必须遍历b+树的叶子节点，因为叶子中存放的才是有效的元素，在非叶子节点中都是对于叶子节点的索引。这也使得b+树在节点有序的同时，所有叶子节点元素都是有序的。</p><p>元素插入分如下情况: 1.节点中元素个数满足m&lt;nodes&lt;2m-1,插入元素后直接返回。 2.节点元素有2m-1个，插入后由于节点满（这里可以根据实际情况决定最多放2m还是2m-1个）。需要进行节点分裂，节点分裂会产生新的节点，同时也会产生新的由父节点指向该节点的索引。此时需要从当前节点向根节点遍历，修改父节点的索引。</p><ul><li>eg1</li></ul><p><img src="/2019/12/10/B-树/insert1.png" alt="insert1"></p><p>在此时的树中55，则插入元素后直接返回。</p><ul><li>eg2<br>若在刚才的树中依次插入元素13，21，40，则会造成节点分裂叶子节点分开，同时更新父节点索引，如下图</li></ul><p><img src="/2019/12/10/B-树/insert2.png" alt="insert2"></p><p>如果不断插入元素导致非叶子节点也到达满的情况。按照叶子节点的分裂情况处理即可。</p><h3 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h3><p>B+树的删除就相对来说比较困难了，如果删除元素后节点数满足m&lt;nodes&lt;2m,则可以直接返回，否则需要进行修改。</p><p>B+树的删除分如下情况。 1.删除后节点元素个数满足m&lt;nodes&lt;2m,直接返回。但是如果删除的式节点中的第一个元素，则需要视情况更新索引。 2.删除后节点元素小于m，则考虑向左边或者右边借一个元素进行合并。 3.在2的条件下，左边叶子节点元素个数满足条件，则分一个给右边节点，同时因为元素的有序性，分给右边的元素占据第一个，所以需要更新当前节点索引。 4.在2的情况下，如果左节点不满足，则向右边节点借一个，如果右边节点满足，分出一个元素，同时需要更新右边节点的索引。 5. 如果3 4都不满足，则需要进行节点合并，与哪边合并都可以，此时需要删除父节点的一个索引。</p><p>总体来看，删除操作略微复杂。</p><ul><li>eg1</li></ul><p><img src="/2019/12/10/B-树/del1.png" alt="del1"></p><p>此时删除元素22后，可以直接返回</p><p><img src="/2019/12/10/B-树/del2.png" alt="del2"></p><ul><li>eg2<br>删除22后，删除15,结果如下。</li></ul><p><img src="/2019/12/10/B-树/del3.png" alt="del3"></p><p>此时需要借元素，同时更新索引</p><p><img src="/2019/12/10/B-树/del4.png" alt="del4"></p><ul><li>eg3</li></ul><p>现在删除元素7，则需要进行节点合并，由于删除的7式一个索引，则也需要更新索引。</p><p><img src="/2019/12/10/B-树/del5.png" alt="del5"></p><p>合并后如下：</p><p><img src="/2019/12/10/B-树/del6.png" alt="del6"></p><p>由于更新后的父节点只有一个索引不满足条件，则该节点也需要合并，最后如下</p><p><img src="/2019/12/10/B-树/del7.png" alt="del7"></p><h3 id="B-树的遍历"><a href="#B-树的遍历" class="headerlink" title="B+树的遍历"></a>B+树的遍历</h3><p>B+树可以分两种遍历方式，可以从根节点进行遍历，页可以根据需要，适当修改节点数据结构，直接从最左边叶子节点遍历，两种情况都比较简单，第一种是O(logn）的复杂度，第二种是O(n)的复杂度。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>B+树整体操作如上述，当遇到问题时，其实一种数据结构有时候并不是那么高深莫测，它只是通过某些变形而已，需要结合实际情况，考虑所学的基本知识进行变通。尤其是对基础知识牢固把握时很重要的。并没有很难得知识点，都是通过基础一点点得变化而来。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近需要完成一个构造数据库的索引的实验，实验要求使用B+树做索引结构，因为对于B+树不够了解，所以先复习一下B+树的特性在进行下一步。对于B+树，这篇文章讲的很好。&lt;a href=&quot;https://www.cnblogs.com/nullzx/p/8729425.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/nullzx/p/8729425.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/数据结构/"/>
    
    
    <category term="数据结构" scheme="http://yoursite.com/tags/数据结构/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学知识点整理（二）</title>
    <link href="http://yoursite.com/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2019-12-06T04:25:47.000Z</published>
    <updated>2020-01-14T08:11:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="造型技术"><a href="#造型技术" class="headerlink" title="造型技术"></a>造型技术</h3><h4 id="实体模型的三类表示"><a href="#实体模型的三类表示" class="headerlink" title="实体模型的三类表示"></a>实体模型的三类表示</h4><p> 边界表示：即用一组曲面来描述物体，这些曲面氛围内部和外部，边界表示具体又包括多边形表面模型和扫描表示两种。</p><p> 构造实体几何表示：它将实体表示成立方体，长方体，圆柱体，圆锥体等基本体素的组合，可以采用并交差等运算构造新的形体。</p><p> 空间分割表示：用来表示物体的内部性质，将包含物体的空间区域分成一组小的，非重叠的，连续实体。</p><a id="more"></a> <ul><li><p>边界表示最普遍的方式是多边形表面模型，使用一组包围物体内部的平面<strong>多边形</strong>描述物体。多边形的平面包括两个面，内侧面和外侧面。一般来说，法向量方向指向物体外部，当多边形顶点序列指定后，它满足右手定则。多边形网格可以有两种，三角形带或者四边形网格。（多边形的点多余三个，多边形可能不再同一个平面上）</p></li><li><p>扫描转换法：将空间中的一个点，一条边或一个面沿着某一路径扫描时，所形成的轨迹定义为一个一维的二维的或三维的实体。旋转扫描时一种常用扫描方式</p></li><li><p>粒子系统描述非规则造型：是一组分散，微小的物体，这些微小物理大小和形状随时间变化。使用粒子系统描绘活=火，爆炸，落叶，云雾，雪等景象和视觉效果。  粒子系统的两个要素：粒子本身的造型，粒子的运动方式。 生成过程：模拟多个粒子及其运动过程。要实现这种粒子效果，需要连续不断的产生新粒子，并且让旧粒子逐渐消亡。</p></li><li><p>分形几何，以非整数的形式填充空间的形态特征，具有自像性。特点：不规则，从远距离上看时处处不规则的。 自相似：不同尺度上看，图形的规则性是相同的。</p></li></ul><h3 id="观察与变换"><a href="#观察与变换" class="headerlink" title="观察与变换"></a>观察与变换</h3><p>在观察坐标系中的运动包括平移，旋转，比例，对称，错切。通过这些变换后可以产生新的图形。</p><ul><li><p>平移：将一个点从一个位置移动到另一个位置的重定位过程，不会产生形变的变换。</p></li><li><p>比例：对p点相对于坐标原点沿x轴放缩m倍，沿y放缩n倍。</p></li><li><p>旋转：将点p绕坐标原点转动一个角度得到一个新的点的过程。 </p></li><li><p>对称：将原图形关于对称轴变换后的图形。</p></li><li><p>错切：用于产生弹性物体的变形处理。</p></li></ul><p>齐次坐标的引入：方便多种变换的进行。</p><h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p>平行投影：投影中心在无穷远处，投影的图形就是平行投影。<br>透视投影：投影中心距离投影平面的距离是有限的就是透视投影。</p><h3 id="裁剪与屏幕映射"><a href="#裁剪与屏幕映射" class="headerlink" title="裁剪与屏幕映射"></a>裁剪与屏幕映射</h3><p>只有经过裁剪后在观察空间内部的物体才能被映射到屏幕上。映射到屏幕上还需要进行一定的平移，旋转的操作。因为观察坐标系的坐标位置和屏幕坐标系有一些的区别。屏幕映射在可编程管线中是固定部分，因此计算都由GPU完成。</p><h3 id="phong光照模型"><a href="#phong光照模型" class="headerlink" title="phong光照模型"></a>phong光照模型</h3><p>自然界中的光照是极其复杂的，为了进行模拟，进行了一定的简化，其中phong模型中的光照来源于三种光：环境光，漫反射光，镜面反射光。<br>1.环境光：模拟全局光照中间接光照的影响，即来自其他物体的反射光。2.漫反射光：模拟片段法向量与光源方向向量夹角间的关系，漫反射光使得物体上与光纤方向越接近的片段能从光源出获得更多亮度。3.镜面反射光：模拟模型表面上的两点，如果观察方向与光线方向间的夹角越小，表示受反射光影响越大。其效果就是使得我们能够看到高光点。 phong模型就是以上三种光的计算叠加，可以模拟现实中的光照。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;造型技术&quot;&gt;&lt;a href=&quot;#造型技术&quot; class=&quot;headerlink&quot; title=&quot;造型技术&quot;&gt;&lt;/a&gt;造型技术&lt;/h3&gt;&lt;h4 id=&quot;实体模型的三类表示&quot;&gt;&lt;a href=&quot;#实体模型的三类表示&quot; class=&quot;headerlink&quot; title=&quot;实体模型的三类表示&quot;&gt;&lt;/a&gt;实体模型的三类表示&lt;/h4&gt;&lt;p&gt; 边界表示：即用一组曲面来描述物体，这些曲面氛围内部和外部，边界表示具体又包括多边形表面模型和扫描表示两种。&lt;/p&gt;
&lt;p&gt; 构造实体几何表示：它将实体表示成立方体，长方体，圆柱体，圆锥体等基本体素的组合，可以采用并交差等运算构造新的形体。&lt;/p&gt;
&lt;p&gt; 空间分割表示：用来表示物体的内部性质，将包含物体的空间区域分成一组小的，非重叠的，连续实体。&lt;/p&gt;</summary>
    
    
    
    <category term="openGL" scheme="http://yoursite.com/categories/openGL/"/>
    
    
    <category term="openGL" scheme="http://yoursite.com/tags/openGL/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学知识点整理（一）</title>
    <link href="http://yoursite.com/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2019-11-26T07:18:26.000Z</published>
    <updated>2019-12-06T04:19:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>整理一下这学期的课程《计算机图形学》的知识点。，课程内容来自中国大学生慕课-&gt;计算机图形学-&gt;华中科技大学</p><a id="more"></a> <h3 id="可编程渲染管线"><a href="#可编程渲染管线" class="headerlink" title="可编程渲染管线"></a>可编程渲染管线</h3><ul><li><p>可编程渲染管线在流水中的三个阶段包括如下：<br>应用程序阶段(1.图元顶点数据 2.摄像机位置 3.光照纹理等)-&gt;几何阶段（1.变换和投影后的点 2.颜色 3.纹理）-&gt;光栅化阶段（输出刀屏幕的各个像素的颜色值）。 一个物体要在荧幕上显示就需要经历上述过程。</p></li><li><p>在计算机图形学中输入的是一段结构特征数据，输出则是图形信号。比如一条直线为例：输入是直线的方程，输出则是屏幕上<strong>最接近</strong>在直线方程的像素点集合。</p></li><li><p>图形显示子系统结构 1.帧缓冲存储器（帧缓存）：一块用来存储颜色或者灰度值的存储空间 2.显示控制器，用于显示帧缓存中的数据。从计算机的组成结构中，最初显示控制器和帧缓存不在相同部件中，由于数据需要通过总线传输，因此在图形显示时需要从主存取数据再到视频显示控制器进行显示，这样需要占用总线，增加了负担。同时数据进行显示时需要扫描转换的，因此就加重了cpu的负担。后来随着技术的发展，将帧缓存，cpu中用于计算图形显示计算的部分组合在一起形成了图形处理器。也就是现在说的显卡（独立显卡）。显卡中最主要的部件就是GPU</p></li><li><p>应用程序阶段和几何阶段：应用程序阶段主要是由cpu完成计算的。几何阶段包括：1.顶点着色器 2.几何，曲面着色器 3.裁剪 4.屏幕映射。</p><p>  顶点着色器完成模型变换，视图变换，顶点着色（确定顶点上的材质的光照效果）。 </p><p>  几何曲面着色器完成顶点的增删，进行曲面细分。</p><p>  裁剪主要完成将几何图形投影刀一个规范化的空间中。判断可见性。</p></li><li><p>光栅化阶段 1.三角形的设置 2.三角形的遍历 3.片元着色器 4.片元操作。在遍历时通过插值得到许多图形的信息。这部分是固定的，由GPU完成。 片元着色则是将前面过程计算的数据进行图形的着色。 片元操作将帧缓存中的数据进行融合计算。最后才会得到每个帧缓存中每个像素点的颜色值。</p></li></ul><h3 id="着色器语言"><a href="#着色器语言" class="headerlink" title="着色器语言"></a>着色器语言</h3><ul><li><p>openGL着色器语言 GLSL。着色器语言的代码以文本的形式保存，不通过cpu编译，在程序运行时通过显卡进行翻译。</p><p>  openGL中使用着色器的流程： 1.创建着色器对象 2.源码关联到着色器对象 3.编译着色器 4.创建程序对象 5.着色器对象关联到程序对象</p></li></ul><ul><li><p>GLSL中的数据类型： 标量（int, uint float ..）  矢量(vec4 a=vec4(1.0,2.0,3.0,4.0)..) 矩阵(mat2 m=mat2(1.0,2.0,3.0,4.0) 是一个2*2矩阵)  结构和数组     </p></li><li><p>EBO VBO VAO</p><p>  EBO(element buffer object)索引缓冲区对象，是为了解决同一个顶点多洗重复调用的问题，可以减少内存空间浪费，提高执行效率。当需要使用重复的顶点时，通过顶点的位置索引来调用顶点，而不是对重复的顶点信息重复记录，重复调用。 </p><p>  VBO（vertex buffer object）顶点缓冲区对象，是在显卡中开辟一块内存缓冲区，用于存储顶点的各类属性信息，如顶点坐标，顶点法向量，顶点颜色数据等。在渲染时，可以直接从VBO中取出顶点的各类属性数据，由于VBO在显存而不是在内存中，不需要从CPU传输数据，处理效率更高。 所以可以理解为VBO就是显存中的一个存储区域，可以保持大量的顶点属性信息。并且可以开辟很多个VBO，每个VBO在OpenGL中有它的唯一标识ID，这个ID对应着具体的VBO的显存地址，通过这个ID可以对特定的VBO内的数据进行存取操作。</p><p>  VAO(vertex array object)顶点数组对象。每次绘制模型之前需要绑定顶点的所有信息，当数据量很大时，重复这样的动作变得非常麻烦。VAO可以把这些所有的配置都存储在一个对象中，每次绘制模型时，只需要绑定这个VAO对象就可以了。 VAO是一个保存了所有顶点数据属性的状态结合，它存储了顶点数据的格式以及顶点数据所需的VBO对象的引用。 </p></li><li><p>实验环境搭建，参考中国大学生慕课课程中视频讲解环境搭建过程。<a href="https://www.icourse163.org/course/0809HUST055-1003636001?utm_campaign=share&utm_medium=androidShare&utm_source=" target="_blank" rel="noopener">https://www.icourse163.org/course/0809HUST055-1003636001?utm_campaign=share&amp;utm_medium=androidShare&amp;utm_source=</a></p></li><li><p>椭圆的扫描转换算法：Bresenham算法 1.输入椭圆的长半轴a和短半轴b。 2.计算初值 d=b^2+a^2(-b+0.25),x=0,y=b; 3. 绘制（x,y）的三个对称点。4 判断d符号，根据中点推导更新下一步的x和y 5.根据不等式 2a^2(y-0.5)&gt;2b^2(x+1)判断是否在上半部分，是则重复3，4.否则转6 6. 进入下半部分，计算下部分d的初值。7.绘制（x,y）的三个对称点。 8.判断d的符号，根据中点推到下一步的x和y取值。 9. 当y&gt;0时继续执行，否则画完整个椭圆。</p><p>其中需要注意两个问题：1.判断何时从上半部分转到下半部分（即当法向量斜率小于1时进行转换，计算相邻取的两个点的斜率即可判断） 2.刚转入下半部分时，计算下半部分中点的初值。</p></li><li><p>多边形区域填充算法（对有多个顶点组成的多边形内部进行区域填充）： x-扫描线算法：1.确定多变形占有的最大扫描线数，得到多边形顶点的最大值和最小值。2.从ymin到ymax每次用一条扫描线填充 3.填充的步骤：a.求交 b.排序 c.交点配对 d.区间填色  </p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;整理一下这学期的课程《计算机图形学》的知识点。，课程内容来自中国大学生慕课-&amp;gt;计算机图形学-&amp;gt;华中科技大学&lt;/p&gt;</summary>
    
    
    
    <category term="openGL" scheme="http://yoursite.com/categories/openGL/"/>
    
    
    <category term="openGL" scheme="http://yoursite.com/tags/openGL/"/>
    
  </entry>
  
  <entry>
    <title>四月是你的谎言 ×，四月是你的ppt √</title>
    <link href="http://yoursite.com/2019/10/23/%E5%9B%9B%E6%9C%88%E6%98%AF%E4%BD%A0%E7%9A%84%E8%B0%8E%E8%A8%80-%C3%97%EF%BC%8C%E5%9B%9B%E6%9C%88%E6%98%AF%E4%BD%A0%E7%9A%84ppt-%E2%88%9A/"/>
    <id>http://yoursite.com/2019/10/23/%E5%9B%9B%E6%9C%88%E6%98%AF%E4%BD%A0%E7%9A%84%E8%B0%8E%E8%A8%80-%C3%97%EF%BC%8C%E5%9B%9B%E6%9C%88%E6%98%AF%E4%BD%A0%E7%9A%84ppt-%E2%88%9A/</id>
    <published>2019-10-23T13:49:17.000Z</published>
    <updated>2019-10-23T14:31:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>终于在火车上补完了自己早就想看的四谎，虽然在火车上观看感受不是那么好，但是还是好多次差点落泪了，真的是猛男必备番。直接一张熏的治愈微笑镇楼</p><p><img src="/2019/10/23/四月是你的谎言-×，四月是你的ppt-√/sh.jpg" alt="xun"></p><a id="more"></a> <p>火车8小时57分钟，从上车开始看，看完之后自己放飞一会思想就下车了，时间也刚好。不过体验不是很好，以后有机会再刷一遍吧。</p><h3 id="yy-amp-amp-废话"><a href="#yy-amp-amp-废话" class="headerlink" title="yy &amp;&amp; 废话"></a>yy &amp;&amp; 废话</h3><p>看完这么好的一部番还是要写点啥，不然感觉挺浪费的。虽然吐槽了其中有很多ppt，但是遮不住这个不落俗套的故事，当然也许这也是很多番的常规套路，只不过我level还比较低看不出来而已。但是那句 “我喜欢了你十年，却用整个四月编织了一个不爱你的谎言”真的到了结尾才让人如此恸哭。</p><p>一个人的言行有时候会影响到别人在这里面也是体现的淋漓尽致。熏那种有时候有点泼但大多数时间又很温柔的性格在现实中有很多这样的人。哎，我这匮乏的语言，真不知道该怎么描述。心里的想法总是不能很好的写出来真的很烦。不过还是继续。最直观的体验是一颗炽热的心真的可以挽救一个在痛苦边缘不断挣扎的人。这无论对于公生还是熏都是如此。熏拯救了公生，公生也拯救了熏。（即使希望渺茫也无所谓，所以大家也都嚷着要寄刀片嘛）所谓的“友人A”不过也是个谎言罢了。 最后那句“我是否住进你的心里了呢？–连鞋也没脱就住进来了。”真的很想哭。很多感人的地方，我也不想用自己匮乏的语言去描绘，只会徒增笔墨而已。</p><p>但是，这样的人真的很难遇见(也许是我没有遇见而已)。像椿和学长似乎才是更贴近现实。弹幕里很多人说“青梅竹马比不过天降少女”还是什么的，我觉得这其实只是这部剧为了增加那种冲击感而设定的。故事想要表达一种相互拯救，互相依存（类似声之形），建立在这样的故事背景下当然更能引发观众的共鸣。椿很好，她和熏一样好，只不过故事主角是熏而已。喜欢一个人没有错，更何况是一个从小到大的玩伴。我不知道如何描述，反正椿也是很可怜的。不过也更现实。我们不过是羡慕像公生和熏那般的爱情罢了。如此治愈的笑容谁不愿意守护呢！但是这部剧的主旨还是之前所说那样，相互拯救，相互依存。这个世界本身就是自私的，能有一个人如此为尔，此生无憾。这样的人很难遇见，所以我们大多数人都是将自己的那种想法寄托了而已。不过，这也正是我喜欢她的原因啊。</p><p>当然，阿渡也是梦寐以求的中国好基友呢~</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;终于在火车上补完了自己早就想看的四谎，虽然在火车上观看感受不是那么好，但是还是好多次差点落泪了，真的是猛男必备番。直接一张熏的治愈微笑镇楼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/10/23/四月是你的谎言-×，四月是你的ppt-√/sh.jpg&quot; alt=&quot;xun&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/其他/"/>
    
    
    <category term="感悟" scheme="http://yoursite.com/tags/感悟/"/>
    
  </entry>
  
  <entry>
    <title>好文搜集</title>
    <link href="http://yoursite.com/2019/10/19/%E5%A5%BD%E6%96%87%E6%90%9C%E9%9B%86/"/>
    <id>http://yoursite.com/2019/10/19/%E5%A5%BD%E6%96%87%E6%90%9C%E9%9B%86/</id>
    <published>2019-10-19T02:00:47.000Z</published>
    <updated>2019-12-22T01:34:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>有时候会看到一些很好的文章，博客，github仓库这样的好东西，可能github仓库还可以fork一些，但是这些好文章都在放在浏览器常用栏里面还是太杂了，所以就打算专门用一篇博客存放这些文章的链接，以后用到的时候直接查会方便一些。如果有任何侵犯原作者权力，请联系我删除，谢谢。</p><a id="more"></a> <p>一篇写的很好的关于<strong>回调函数使用</strong>的文章<br><a href="https://blog.csdn.net/qq_31930499/article/details/80654472" target="_blank" rel="noopener">https://blog.csdn.net/qq_31930499/article/details/80654472</a></p><p>一个很厉害的知乎博主，上面有很多有取的东西。<br><a href="https://zhuanlan.zhihu.com/milocode" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/milocode</a></p><p>一篇写的很好的关于B+树插入和删除的博客。<br><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/8729425.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;有时候会看到一些很好的文章，博客，github仓库这样的好东西，可能github仓库还可以fork一些，但是这些好文章都在放在浏览器常用栏里面还是太杂了，所以就打算专门用一篇博客存放这些文章的链接，以后用到的时候直接查会方便一些。如果有任何侵犯原作者权力，请联系我删除，谢谢。&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/其他/"/>
    
    
    <category term="其他" scheme="http://yoursite.com/tags/其他/"/>
    
  </entry>
  
  <entry>
    <title>过分崎岖的秋招之路</title>
    <link href="http://yoursite.com/2019/10/17/%E8%BF%87%E5%88%86%E5%B4%8E%E5%B2%96%E7%9A%84%E7%A7%8B%E6%8B%9B%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/10/17/%E8%BF%87%E5%88%86%E5%B4%8E%E5%B2%96%E7%9A%84%E7%A7%8B%E6%8B%9B%E4%B9%8B%E8%B7%AF/</id>
    <published>2019-10-17T02:15:53.000Z</published>
    <updated>2019-10-17T03:00:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>眼看秋招即将结束，自己也终于在这个1个多月的煎熬后收获了offer，但是这算不算满意的offer呢？其实我似乎一开始就没在心里给自己定一个特别的目标，但应该还是有的，就是希望工作的环境好点，同事间关系能够简单点。这也是自己之前特别想去morning star这家外企的原因了。 在我看来工资是很重要，但是如果可以给我一个舒服的环境工资就显得较为苍白了（表面苍白）。既然现在已经基本确定了。那就必须要向前看了。</p><a id="more"></a> <p>最后决定的目的地除了离家远点，以后可能周围朋友更少了点，其他的，在现在的我看来还是不错的。挺好的平台，至少我认为对于自己的发展不会太差。仍然记得当时面试官问着问着我问题最后自己直接想出了一个他也突然不知道怎么解决的问题。（也许他知道答案，但是和他一起讨论真的感觉挺不错的。），再想到后面和hr的交谈，给我的关于面试方面的几点建议，都对我挺有帮助的，这也对我我后来在其他几家企业面试带来了帮助。其实当时面试完心里也觉得希望加入这里了。只不过因为自己在当时的环境下因为处处碰壁，感觉自己一无是处，所以不敢报太大希望。不过结局是好的就行了。</p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>一开始本来是想写下自己这一个多月的心路变化的，但是我感觉当时虽然很难受，有多难受呢，也不好描绘，反正总有人和我差不多的经历，就是那种感觉。 但是现在想想，过都过去了，这些感觉就直接放那吧，不如思考下之后该干嘛。 也咸鱼了好几天了，看着考研的室友每天七点出门，再看看自己，还是挺羞愧的。废话也不多说了，直接拟定自己的一个大概计划吧。</p><h3 id="干点啥"><a href="#干点啥" class="headerlink" title="干点啥"></a>干点啥</h3><p>这似乎和标题不太相关，但是我真不想写什么自己的秋招感受。直接开始安排之后的事。现在也觉得早做个计划效率会更高。</p><p>在寄出三方协议之后先回家呆个10天左右，然后可能会在成都逗留两三天。这个到时候在决定。那下次再回到学校应该是在11.5号左右。接下来需要在12月之前把驾照考完吧，希望自己不要挂，直接过了。然后期间也需要考虑下系统能力培养的那个作业。如果是在12月，那尽快搞定呗。然后这个期间还有自己选的那堂计算机图形学，也需要找本参考书好好看下。这些都需要在12月前开始甚至有一定的进度。 那之后的话如果驾照ok了。对了还有自己已经选好了ios方向，不过这个需要之后看安排在决定资料的选择了。这个也会在12月前开启。 之后驾照ok了话，看能不能找个助教或者什么工作之类的吧。如果找不到合适的助教就去做点勤工吧。驾照不ok就继续呗。然后就是毕业设计自己也有了一个想法了，到时候如果能成的话就最好了。还有公司那边说实习的事，这个之后沟通下吧。感觉年后去会好点，那如果在年前能够完成毕业设计就好了。这是最理想的情况了。还有专业书也要继续看下去。不能太过咸鱼。离毕业还有8个月多，应该可以在ios这方面学到很多东西了。大体安排就这样了。</p><p>之后根据情况做具体的安排，虽然这和博文标题不相关，但是写出来还是感觉挺爽的。旧的旅程即将结束，新的旅途即将开启，再混下去就见鬼去吧。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;眼看秋招即将结束，自己也终于在这个1个多月的煎熬后收获了offer，但是这算不算满意的offer呢？其实我似乎一开始就没在心里给自己定一个特别的目标，但应该还是有的，就是希望工作的环境好点，同事间关系能够简单点。这也是自己之前特别想去morning star这家外企的原因了。 在我看来工资是很重要，但是如果可以给我一个舒服的环境工资就显得较为苍白了（表面苍白）。既然现在已经基本确定了。那就必须要向前看了。&lt;/p&gt;</summary>
    
    
    
    <category term="感悟" scheme="http://yoursite.com/categories/感悟/"/>
    
    
    <category term="感悟" scheme="http://yoursite.com/tags/感悟/"/>
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="http://yoursite.com/2019/10/04/%E2%80%98%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/10/04/%E2%80%98%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2019-10-04T02:35:48.000Z</published>
    <updated>2019-10-04T07:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>发现之前对于散列表这个数据结构一直有点模糊不清，今天手上正好带了算法这本书，就系统的过一遍，加深下印象。</p><h3 id="散列表特性"><a href="#散列表特性" class="headerlink" title="散列表特性"></a>散列表特性</h3><p>散列表作为一种动态的结构，其空间是随着数据的插入和删除不断变化的，他也是数组概念的扩展，在支持insert，delete，search的操作的同时能够进一步降低时间复杂度。在设计合理的情况下，上述操作的复杂度能够降到o(1)。散列表的特性是1.实际存储的关键字数目比关键字总数小。2.通过计算得到关键字的下标。对应的方式是hash中解决冲突的策略。</p><a id="more"></a> <h3 id="直接寻址表"><a href="#直接寻址表" class="headerlink" title="直接寻址表"></a>直接寻址表</h3><p>当关键字的域范围比较小时，可以使用直接寻址，使用一个数组作为直接寻址表，表中每一个位置称为slot（槽）,每个slot存放一个关键字。没有存放关键字的slot用特殊值代替。 优点是效率很高，缺点是条件很苛刻，属于比较理想的情况。对于空间的浪费比较严重。</p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>在直接寻址方式中对于空间的浪费比较严重，所以考虑将关键字的域通过一个函数计算进行放缩，这个函数称为hash函数，h:U→{0，1，2，…m-1};</p><p>通过这样一个函数对关键字进行计算将U范围的数据放缩到m的空间大小中，节约了很多空间，但是也带来了一个问题，可能有多个关键字会映射到一个slot上，称为冲突，不过有很多的办法来解决冲突。</p><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>链地址的存放方式如下:</p><p><img src="/2019/10/04/‘散列表/liandizhi.jpg" alt="liandizhi"></p><p>其中的链表可以采用单链表或者双向链表，在同一个链表中关键字的hash值是相同的。</p><p>性能分析：定义装载因子为a=n/m,(n表示关键字个数，m表示散列表大小)，因此当m与n成正比时（a&lt;1）可以实现在o（1）的时间内进行查找，删除，和插入元素。</p><h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>在设计散列函数时需要近似的满足简单均匀散列假设：每个关键字等可能的散列到槽位的任何一个。</p><p>设计方法：1. 利用关键字分布的有用信息，尽量降低将相似符号散列到相同位置。2.一个好的方法导出的散列值应该可以独立数据可能存在的任何模式。3.让近似的关键字具有截然不同的散列值。</p><h4 id="除法散列法"><a href="#除法散列法" class="headerlink" title="除法散列法"></a>除法散列法</h4><p>h(k)=kmodm;</p><p>散列法设计的好坏关系到散列表的冲突大小，使用除法散列时尽量避免m为2的幂，可以选择接近2的幂的一个质数作为m.</p><h4 id="乘法散列法"><a href="#乘法散列法" class="headerlink" title="乘法散列法"></a>乘法散列法</h4><p>乘法散列法的设计步骤1.用关键字k乘上常数A（0&lt;A&lt;1），提取kA的小数部分，步骤2.用m乘以这个数在向下取整 h(k)=m<em>(k</em>A mode 1);</p><h4 id="寻址方式–开放寻址法"><a href="#寻址方式–开放寻址法" class="headerlink" title="寻址方式–开放寻址法"></a>寻址方式–开放寻址法</h4><p>在开放寻址法中，所有元素都存放在散列表中，也就是说，每一个表项或包含一个元素或者为空。当查找某个元素时，要系统的检查所有表项，直到找到所需的元素或者最终发现元素不在表中。这里面没有链表，元素都存放在散列表外，因此在开放寻址法中a不能超过1.</p><h5 id="开放寻址法–线性探测"><a href="#开放寻址法–线性探测" class="headerlink" title="开放寻址法–线性探测"></a>开放寻址法–线性探测</h5><p>给定一个普通函数作为散列函数，h(k,i)=(h`(k)+i) mod m;  i=0,1,2…m-1; 给定一个关键字k，根据 h’(k)获得一个槽位，如果发生冲突，则使用上述公式推进到下一个位置。 极端情况是遍历了整个散列表。 因此存在的问题称为<strong>一次群集</strong>，随着占用槽位的不断增加，平均查找时间也会不断增加。</p><h4 id="开放寻址法–二次探测"><a href="#开放寻址法–二次探测" class="headerlink" title="开放寻址法–二次探测"></a>开放寻址法–二次探测</h4><p>二次探测使用函数如下 h(k,i)=(h`(k)+c1<em>i+c2</em>i^2)mod m;i=0,1,2…m-1; 这个方式需要探查的槽位会比线性探测的方式少。但是也会出现<strong>二次群集</strong>的问题。</p><h4 id="开放寻址法–双重散列"><a href="#开放寻址法–双重散列" class="headerlink" title="开放寻址法–双重散列"></a>开放寻址法–双重散列</h4><p>双重散列是对上述两种方式的优化， hash函数为 h(k,i)=(h1(k)+i*h2(k))mod m; 这种方式使得关键字以两种不同的方式依赖于hash函数，因此效果是比较理想的，但是在设计时为了遍历到整个散列表需要确保h2（k）与m互素。因为这样的数据相对密度可能较小。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;发现之前对于散列表这个数据结构一直有点模糊不清，今天手上正好带了算法这本书，就系统的过一遍，加深下印象。&lt;/p&gt;
&lt;h3 id=&quot;散列表特性&quot;&gt;&lt;a href=&quot;#散列表特性&quot; class=&quot;headerlink&quot; title=&quot;散列表特性&quot;&gt;&lt;/a&gt;散列表特性&lt;/h3&gt;&lt;p&gt;散列表作为一种动态的结构，其空间是随着数据的插入和删除不断变化的，他也是数组概念的扩展，在支持insert，delete，search的操作的同时能够进一步降低时间复杂度。在设计合理的情况下，上述操作的复杂度能够降到o(1)。散列表的特性是1.实际存储的关键字数目比关键字总数小。2.通过计算得到关键字的下标。对应的方式是hash中解决冲突的策略。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/数据结构/"/>
    
    
    <category term="数据结构" scheme="http://yoursite.com/tags/数据结构/"/>
    
  </entry>
  
  <entry>
    <title>一些感想</title>
    <link href="http://yoursite.com/2019/09/23/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/"/>
    <id>http://yoursite.com/2019/09/23/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/</id>
    <published>2019-09-23T04:21:53.000Z</published>
    <updated>2019-10-04T07:41:28.000Z</updated>
    
    <content type="html"><![CDATA[<p> 我只是觉得有时候郁闷了还是需要至少是写点东西排解下才行。突然想起一个问题。之前一些测评里面有一个问题这么问的：你最近是否感到无法集中精神，我当时选了否。这才过了大概3-4天感觉自己的选择应该变成反面了。所以我在自己相当混乱的时候选择来到图书馆让自己理清一下思路。</p><a id="more"></a> <p> 我也不知道自己出了什么毛病，好吧，其实我内心是清楚的很，只是不想写出来而已。但是想想自己刚坚持了一周那么好的状态，现在就松懈下来似乎还是不行的，需要找下之前的感觉。我今天老是担心自己之前掌握的那些东西都会消失不见。这可能也是我混乱的原因之一吧。不过还好，就算我感觉郁闷，还是认为自己过得去。有压力才有动力嘛，今天下午我只想找回一点状态。让我坚持过完这个九月，那就足够了。</p><p> 最近（其实也就花了一个晚上加半个早上）看完了一本小清新的小说。《等待，只为与你相遇》，属于那种比较治愈性的小说吧。但是在平淡的故事里却还是饱含了溢于言表的亲情和爱情。我不是觉得这个故事又多么美好，而且现实中也不会（我自认为不会）又这样的人存在，但是这个故事却可以让我在如此混乱的周末感到一丝轻松（我也不知道用什么词）。反正就感觉看了之后挺舒服的。虽然还是没什么营养的一本书，顶多让你可以期待一下自己也能遇到这样的人就好了，然后过几天又全部抛之脑后。感觉对自己有益就行了嘛，不要强求太多。虽然我感觉自己现在那个混乱还是没有太大改善（或许我并不混乱，只是自己这么想而已）。不过用大脑思考一个下午应该有所改善吧。希望如此。</p><p> 到头来，想改善下自己的组织语言的逻辑能力，发现写出来还是那么丑陋啊，更别想自己说出来是怎么样了。希望自己的逻辑能力还是可以慢慢提高吧。 2019.9.23</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 我只是觉得有时候郁闷了还是需要至少是写点东西排解下才行。突然想起一个问题。之前一些测评里面有一个问题这么问的：你最近是否感到无法集中精神，我当时选了否。这才过了大概3-4天感觉自己的选择应该变成反面了。所以我在自己相当混乱的时候选择来到图书馆让自己理清一下思路。&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/其他/"/>
    
    
    <category term="感悟" scheme="http://yoursite.com/tags/感悟/"/>
    
  </entry>
  
  <entry>
    <title>最长公共子串和lcs</title>
    <link href="http://yoursite.com/2019/09/16/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E5%92%8Clcs/"/>
    <id>http://yoursite.com/2019/09/16/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E5%92%8Clcs/</id>
    <published>2019-09-16T08:00:03.000Z</published>
    <updated>2019-10-04T08:36:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>感觉我对算法这一块的总结比较少，leetcode做题后没太注意总结各种算法，有时候会出现一道题目感觉就是会做但是思路总是会出一点问题。之后还是需要多做总结才行。</p><p>今天第一个需要注意的是 memset这个库函数。 这个函数可以用来对一块连续的空间做初始化。但是有一点我已知没有注意。这个函数的特性是<strong>分别对每一个字节进行初始化，也就是说对于一个64位机中的int类型进行初始化时，0x00000000初始化为1的结果是0x01010101。</strong>这一点还是挺重要的。之前都没有注意到。 类似的char（一个字节）的初始化就不用担心出错了。下面回到正题。</p><a id="more"></a><h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p>给定两个字符串，找出他们的最长公共子串。”abcde”和”bcdf”返回”bcd”,这个题目可以联想到lcs，所以我顺便复习下lcs（最长公共子序列）。只要对lcs还有一点残存的记忆，想法都是使用二维数组来解题。<br>下面是关于”abcde”和”bcdf”的情况。</p><pre><code>  b c d f     a 0 0 0 0b 1 0 0 0c 0 1 0 0d 0 0 1 0e 0 0 0 0</code></pre><p>观察上面的结构，最长子序列会出现在斜线上，这是一个典型的动态规划，他的递推式为</p><pre><code>s1[i]==s2[j]? dp[i][j]=dp[i-1][j-1]+1;最后结果就如下：    b c d f       a 0 0 0 0  b 1 0 0 0  c 0 2 0 0  d 0 0 3 0  e 0 0 0 0</code></pre><p>时间复杂度o(n2)，空间复杂度o(n2);</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>代码如下：也可以输出其中的子串，方法比较多substr，或者遍历一下原串都可以。</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;string.h&gt;using namespace std;int getlen(string&amp;s1,string &amp;s2){    int size1 = s1.size();    int size2 = s2.size();    int dp[size1][size2];    memset(dp, 0, sizeof(dp));    for (int i = 0; i &lt; size1;i++)        dp[0][i] = s2[i] == s1[0] ? 1 : 0;    for (int i = 0; i &lt; size2;i++)        dp[i][0] = s2[0] == s1[i] ? 1 : 0;    int ret = 0;    int indexx = 0;    for (int m = 1; m &lt; size1;m++){        for (int n = 1; n &lt; size2;n++){            if(s1[m]==s2[n]){                dp[m][n] = dp[m - 1][n - 1] + 1;                if(dp[m][n]&gt;ret){                    ret = dp[m][n];                    indexx = m;                }            }        }    }    for (int i = 0; i &lt; size1;i++){        for (int j = 0; j &lt; size2;j++)            cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;         cout &lt;&lt; endl;    }    string tmp = &quot;&quot;;    for (int i = indexx,j=ret; j&gt;0&amp;&amp;i&gt;=0;i--,j--){        tmp =s1[i]+tmp;    }    cout &lt;&lt; tmp &lt;&lt; endl;    return ret;}int main(){    string s1,s2;    cin&gt;&gt;s1&gt;&gt;s2;    int len=getlen(s1,s2);    cout&lt;&lt;len&lt;&lt;endl;    return 0;}</code></pre><h3 id="lcs"><a href="#lcs" class="headerlink" title="lcs"></a>lcs</h3><p>给定两个字符串，找出其中最长的公共子序列，注意子序列可以不是连续的字符，但是相对顺序不能变。<br>lcs是动态规划的典型，有很多类似的模型。比如地图最短路径，最大/最小正方形等。</p><p>这类问题的关键都是找到通项公式：lcs的通项如下：</p><p><img src="/2019/09/16/最长公共子串和lcs/lcs.png" alt="lcs"></p><p>所以一切的关键都在这个递归公式中，照着这个公式写就完全ok。有一篇文章图文并茂的博客总结的很好，感谢原作者.参考 <a href="https://blog.csdn.net/hrn1216/article/details/51534607" target="_blank" rel="noopener">https://blog.csdn.net/hrn1216/article/details/51534607</a> </p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>可以在得出长度后再次返回去求得子串的组成元素。其中已经给出。</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;string.h&gt;using namespace std;int getlen(string&amp; s1,string&amp;s2){    int len1 = s1.size();    int len2 = s2.size();    int dp[len1+1][len2+1];    memset(dp, 0, sizeof(dp));    for (int i = 0; i &lt; len1;i++){        for (int j = 0; j &lt; len2;j++){            if(s1[i]==s2[j]){                dp[i + 1][j + 1] = dp[i][j]+1;            }else{                dp[i + 1][j + 1] = std::max(dp[i][j + 1], dp[i + 1][j]);            }        }    }    for (int i = 0; i &lt;= len1;i++){        for (int j = 0; j &lt;= len2;j++)            cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    }    int m = len1, n = len2;    string tmp = &quot;&quot;;    while(m&gt;0 &amp;&amp;n&gt;0 &amp;&amp; dp[m][n]!=0){        if(dp[m-1][n]==dp[m][n]){            m = m - 1;        }else if(dp[m][n-1]==dp[m][n]){            n = n - 1;        }else{            m = m - 1;            n = n - 1;            tmp = s1[m] + tmp;        }    }    cout &lt;&lt; tmp &lt;&lt; endl;    return dp[len1][len2];}int main(){    string s1, s2;    cin &gt;&gt; s1 &gt;&gt; s2;    int len = getlen(s1, s2);    cout &lt;&lt; len &lt;&lt; endl;    return 0;}</code></pre><p>以上代码都在牛客网对应题目中提交通过.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;感觉我对算法这一块的总结比较少，leetcode做题后没太注意总结各种算法，有时候会出现一道题目感觉就是会做但是思路总是会出一点问题。之后还是需要多做总结才行。&lt;/p&gt;
&lt;p&gt;今天第一个需要注意的是 memset这个库函数。 这个函数可以用来对一块连续的空间做初始化。但是有一点我已知没有注意。这个函数的特性是&lt;strong&gt;分别对每一个字节进行初始化，也就是说对于一个64位机中的int类型进行初始化时，0x00000000初始化为1的结果是0x01010101。&lt;/strong&gt;这一点还是挺重要的。之前都没有注意到。 类似的char（一个字节）的初始化就不用担心出错了。下面回到正题。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/算法/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>5190. 反转每对括号间的子串 &amp;&amp; 5191.K次串联后最大子数组之和</title>
    <link href="http://yoursite.com/2019/09/15/5190-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2-K-%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/09/15/5190-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2-K-%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C/</id>
    <published>2019-09-15T09:24:49.000Z</published>
    <updated>2019-09-23T04:51:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这次的周赛做的太菜了，不忍直视，我想图书馆对面那对情侣老是在那里叽叽喳喳，但是本质还是我太菜了。不过还是花了快一个下午时间+找参考资料把B和C过了。所以我再一次认为，多看下优秀的代码真的对自己很有帮助。</p><p>先看下题目B</p><a id="more"></a><h3 id="题目B"><a href="#题目B" class="headerlink" title="题目B"></a>题目B</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>题意的话我还是直接贴图了。</p><p><img src="/2019/09/15/5190-反转每对括号间的子串-K-次串联后最大子数组之和/B.png" alt="B"></p><p>当然对于这一类字符串去括号或者字符串压缩得题目还是使用stack比较有效。但是我当时就想着用一种新的办法做一下，没有考虑<strong>括号可能有没有嵌套得情况，</strong>直接就崩了。 所以遇到这类题目还是多注意下隐藏得测试用例好点。关键多思考。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>既然明确了思路，就直接使用一个栈来完成，思考入栈和退栈，当需要退栈时都是在遇到”)”时，因为此时我们需要将”（）”内得字符串反转。那就很明显了。 遍历一遍字符串，遇到 “)”时退栈，遇到”(“时停止退栈。将得到的字符串反转在压栈。重复这个过程就可以得到结果了。</p><p><strong>note</strong>：这里需要注意一点</p><pre><code>string tmp=&quot;&quot;+&apos;i&apos;;//这个代码在mingw环境下输出一个空串。string tmp=&quot;&quot;;tmp=tmp+&apos;i&apos;;// 可以输出 i</code></pre><p><del>这个我觉得比较奇怪，但是还没有找到原因。 之后再来填吧。</del>  <strong>note:2019.9.16 填坑</strong>关于昨天这个问题，和班上一个大佬讨论了下，然后查了下资料，这应该是一个关于capacity的问题，string就好比vetcor<char>,当我使用上述第一种方式进行初试化时，我是用的tmp并没有被初始化，或者说他没有这样类型的构造函数，所以经过 tmp=””+’i’;后tmp的capacity还是0，所以就会打印不出任何东西。而它刚好有一个拷贝构造函数，这个构造函数底层还是深拷贝（毕竟stl），初始化后capacity不为0，就可以继续往下了。</char></p><h4 id="ac代码"><a href="#ac代码" class="headerlink" title="ac代码"></a>ac代码</h4><p>思路大概清楚，就直接代码了</p><pre><code>class Solution {public:    string reverseParentheses(string s) {        stack&lt;string&gt; str;        s= &apos;(&apos;+s+&apos;)&apos;;        int size=s.size();   //     cout&lt;&lt;size&lt;&lt;endl ;        for(int i=0;i&lt;size;i++){            string now=&quot;&quot;;            now=now+s[i];            str.push(now);            if(s[i]==&apos;)&apos;){                string tmp;                str.pop();                while(str.empty()==false &amp;&amp; str.top()!=&quot;(&quot;){                    tmp=str.top()+tmp;                    str.pop();                }                 reverse(tmp.begin(),tmp.end());  //o(n)                if(str.empty()==false)                    str.pop(); //pop (                str.push(tmp);            }        }        reverse(str.top().begin(),str.top().end());        return  str.top();    }};</code></pre><p>//这种方法我觉得应该算是比较快的了。就不贴ac图了。</p><h3 id="题目C"><a href="#题目C" class="headerlink" title="题目C"></a>题目C</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>还是先贴题目吧<br><img src="/2019/09/15/5190-反转每对括号间的子串-K-次串联后最大子数组之和/C.png" alt="c"></p><p>这道题是真的难(对于我来说)。自从之前做了一道叫 求<strong>数组的最大自序和</strong>之后，我的思路感觉就固化了,就是喜欢直接求整个数组的最大值去了，所以当然就是直接超时了。这道题我参考一些资料后，思路大概是这样的：</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>如果k为1 直接取最大值。 如果k&gt;1,需要计算出一个数组的和，一个数组左边开始的最大值，一个数组右边开始的最大值。然后分以下几种情况讨论：</p><ol><li>如果一个数组的和小于等于0，那么最大值应该为一个数组计算所得的最大值和 左边的最大值加右边的最大值进行比较</li><li>否则的话，需要进行判断比较下列几种情况的最大值 A. k个数组的和 B.左边k-1个数组的和加上最后一个数组的左最大值。 C右边k-1个数组的和加上第一个数组的右最大值。C.中间k-2个数组的和+左右两边的数组的最大值。 比较他们的结果，最终得出最值。</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>根据上面的思路，就有了整体的代码：</p><pre><code>class Solution {    const int BIG=1e9+7;public:    int kConcatenationMaxSum(vector&lt;int&gt;&amp; arr, int k) {        int size=arr.size();        long max=0,sum=0;        for(int i=0;i&lt;size;i++){            sum=sum+arr[i];            if(max&lt;sum)                max=sum;            if(sum&lt;0)                sum=0;        } //一个子数组最大和        //k==1 直接取最大        if(k==1) return max%BIG;        //k&gt;=2        long lmax=0,rmax=0;        long cntleft=0;        for(int i=0;i&lt;size;i++){            cntleft=cntleft+arr[i];            lmax=std::max(lmax,cntleft);        }//左边最大和        long cntright=0;        for(int i=size-1;i&gt;=0;i--){            cntright=cntright+arr[i];            rmax=std::max(rmax,cntright);        }//右边最大和        //分类讨论        long sumofone=0;        for(auto c: arr)            sumofone+=c;       // cout&lt;&lt;lmax&lt;&lt;&quot; &quot;&lt;&lt;rmax&lt;&lt;&quot; &quot;&lt;&lt;sumofone&lt;&lt;endl;        if(sumofone&lt;0){ //数组的和小于0，则比较max和左最大值加右最大值的和            max=std::max(max,(lmax+rmax));        }else{ //一个的和大于0，则比较第一个右最大值+k-1个数组的和，中间k-2个数组的和+左右两个的左右最大值，左边k-1个数组的和+最后一个数组左最大值。 k个数组的和。            max=std::max(sumofone*k,std::max(sumofone*(k-1)+lmax,sumofone*(k-1)+rmax));            //还有一种情况 中间k-2个的和 加上左右lmax和rmax的最大值在比交            max=std::max(sumofone*(k-2)+lmax+rmax,max);        }        return max%BIG;    }};</code></pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这次的周赛做的太菜了，不忍直视，我想图书馆对面那对情侣老是在那里叽叽喳喳，但是本质还是我太菜了。不过还是花了快一个下午时间+找参考资料把B和C过了。所以我再一次认为，多看下优秀的代码真的对自己很有帮助。&lt;/p&gt;
&lt;p&gt;先看下题目B&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
    <category term="coding" scheme="http://yoursite.com/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>git基础</title>
    <link href="http://yoursite.com/2019/09/09/git%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/09/09/git%E5%9F%BA%E7%A1%80/</id>
    <published>2019-09-09T10:58:55.000Z</published>
    <updated>2019-09-23T04:49:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>git作为一个流行的源管理系统，使得用户可以为内容的开发创建分支。使用分支并且在分支间交换。 具有很强的版本控制功能，可以解决多人协作的问题。提高开发效率。</p><a id="more"></a><p>很早以前就已经对git有所耳闻，今年参考一些资料后总结一些基本的git操作。方便自己以后用到时可以有地方复习。</p><h3 id="git-安装"><a href="#git-安装" class="headerlink" title="git 安装"></a>git 安装</h3><p>安装直接跳到git官网下载对应操作系统的版本即可。 <a href="https://git-scm.com" target="_blank" rel="noopener">https://git-scm.com</a> 选择与自己对应的版本下载安装即可。</p><p>安装之后打开git bash配置一下username和email</p><pre><code>git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot;</code></pre><p>配置完成后可以使用 <strong>git config –list</strong>查看配置信息</p><p><img src="/2019/09/09/git基础/message.png" alt="message"></p><p>如果还不习惯使用命令行界面，可以下载一个图形界面soursetree来尝试一下，这个类似于githubdesktop 和mysql的图形界面操作。减轻了在命令行界面的操作。 soursetree下载地址：<a href="https://www.sourcetreeapp.com" target="_blank" rel="noopener">https://www.sourcetreeapp.com</a> 选择适合自己的版本下载安装即可。</p><h3 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h3><p>在开始之前需要先知道git的整个工作流程，大致流程图如下：</p><p><img src="/2019/09/09/git基础/fllow.png" alt="fllow"></p><ul><li>工作区：存放git版本仓库的目录就是工作区。</li><li>版本库（本地仓库）：在工作区的目录下有一个.git文件，这个不算工作区，而是git的版本库。</li><li>暂存区：git的版本库中存储了很多东西，其中最重要的就是暂存区，其中存放还未commit到版本区的内容，有一个重要的指针 HEAD指向最近一次的提交结果。</li><li>远程仓库：当本地仓库代码测试无误后，可以将代码push到源程仓库。方便之后管理。在团队协作中使用源程仓库也便于团队开发。</li></ul><p>下面将一些git常用指令。<br>    //初始化版本库，选择或者新建一个空目录，在其中出是一个版本库<br>    git init</p><pre><code>//添加文件到版本库git add //将文件从工作区添加到暂存区，从上图也可以看出git commit -m //将暂存区的修改提交到版本库 -m 后面加上本次提交的提示信息。//查看仓库状态git status //通过该命令可以查看工作区当前的修改是否已经提交//将暂存区的修改回退到上一次提交git reset HEAD filename//清空工作区git checkout </code></pre><p><img src="/2019/09/09/git基础/rollback.png" alt="rollback"></p><p>工作流程类似于回滚到上一次的提交</p><pre><code>//回滚到某一次的提交git log //获取某一次提交的commit号git reset --hard + commit号   //移除某个文件  git rm filename //移出工作区的文件git commit -m  &quot;delete file&quot; //将移出文件提交到本地仓库</code></pre><p>下面是一个git的工作流：</p><p><img src="/2019/09/09/git基础/workingfllow.png" alt="workingfllow"></p><h3 id="本地仓库与远程仓库"><a href="#本地仓库与远程仓库" class="headerlink" title="本地仓库与远程仓库"></a>本地仓库与远程仓库</h3><p>创建 SSH key： 由于本地仓库和远程仓库是通过ssh来进行通信的，所以需要创建ssh key</p><pre><code>ssh-keygen -t rsa -C &quot;youremail@blabla.com&quot; //邮箱为github中注册时使用的邮箱//创建之后使用如下面命令判断是否连接成功ssh -T git@github.com</code></pre><p>连接成功后就可以在本地仓库和远程仓库进行通信。</p><pre><code>git remote add origin +github中新建的仓库地址 //关联本地仓库和远程github仓库git push -u origin master //将本地内容推到github中</code></pre><ul><li><p>克隆仓库</p><pre><code>git clone +远程仓库SSH //将远程仓库克隆到本地</code></pre><p>修改之后又可以在推到远程仓库 （git push） </p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>创建新的分支后方便自身在创作时不影响整个团队的流程，当新的分支的功能完成后再merge到master</p><p>  //创建新的分支<br>  git branch featurename<br>  //显示当前分支<br>  git branch<br>  //切换分支<br>  git checkout featurename<br>  // 合并分支<br>  git merge featurename<br>  //删除分支<br>  git branch -d featurename</p></li></ul><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>标签的作用：在发布时在版本库中加上一个标签，就可以确定当前版本对应的标签，同时创建标签和删除标签比较快。</p><pre><code>//查看所有标签git tag//创建标签git tag +name//指定提交信息git tag -a name -m &quot;comment&quot;//删除标签git tag -d name//标签发布git push origin name </code></pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;git作为一个流行的源管理系统，使得用户可以为内容的开发创建分支。使用分支并且在分支间交换。 具有很强的版本控制功能，可以解决多人协作的问题。提高开发效率。&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
    <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>一些面试题目</title>
    <link href="http://yoursite.com/2019/09/06/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/09/06/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</id>
    <published>2019-09-06T01:03:04.000Z</published>
    <updated>2019-10-11T01:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想着之后要面试了，就看一下面试相关的一些题目，稍微做一下总结。</p><h3 id="关于引用和指针的区别"><a href="#关于引用和指针的区别" class="headerlink" title="关于引用和指针的区别"></a>关于引用和指针的区别</h3><p>突然遇到了就还是稍微总结一下两者的区别。可能不够完善，以后继续补充。引用是变量的别名，指针是间接指向了其他变量。</p><a id="more"></a> <ol><li>作为引用的变量本身sizeof的大小不确定，随着被引用变量而变化。而指针本身大小是固定的，一般在64位机中占用四字节。</li><li>引用在申明时必须初始化让其指向一个变量，但是指针可以不用（虽然这样存在风险）。所以一般在使用指针时都是先判断是否为空。但是引用不必。</li><li>算术运算符的区别，对一个引用变量做++/–运算是将被引用的变量值变化，而指针做++/–则是使指针指向下一个位置。</li><li>引用不可以改变指向，如果擅自修改引用指向，其实是修改了被引用的变量。指针可以修改指向。</li><li>引用一般来说比指针更安全，指针在释放之后变成了一个野指针，但是引用不存在空引用。 </li></ol><h3 id="分时操作系统和实时操作系统"><a href="#分时操作系统和实时操作系统" class="headerlink" title="分时操作系统和实时操作系统"></a>分时操作系统和实时操作系统</h3><p>实时操作系统：当外界事件或者数据产生时，能够以足够快的速度接受并作出响应，其处理结果也能在足够快时间内做出响应。实现实时任务协调一致。 小的嵌入式操作系统经常需要实时操作系统，内核需要满足实时操作系统需求。</p><p>特征： 多任务，线程优先级，多级中断</p><p>分时操作系统：一台计算机可以同时为多个用户服务，将系统处理时间分成多个很小的时间片段，轮流给各个用户使用，由于时间片很小，所以各个用户感觉自己像在独占操作系统一样。</p><p>特征：交互性：用户与系统进行对话。多路性：多个用户使用同一块cpu。独立性：用户可彼此独立操作，不互相干扰。及时性：短时间内可以得到操作系统应答。</p><h3 id="程序内存空间分布"><a href="#程序内存空间分布" class="headerlink" title="程序内存空间分布"></a>程序内存空间分布</h3><p><img src="/2019/09/06/一些面试题目/pro.png" alt="pro"></p><p>从上图可以看出，一般来讲，栈空间存放的都是一些局部变量，或者形式参数。 堆空间中一般都是存放程序运行时申请的内存。</p><p>所以局部变量存放位置和全局变量不同。生命周期也是不同的。存放在全部空间的变量未初始化时值为0</p><h3 id="C-虚函数"><a href="#C-虚函数" class="headerlink" title="C++虚函数"></a>C++虚函数</h3><p>虚函数是C++中实现多态的机制，核心理念是通过基类访问派生类定义的函数。 因为派生类继承了基类的性质和地址范围，所以一般来讲派生类的空间大于基类地址空间，因此可以使用基类去访问派生类。函数的<strong>多态</strong>表现在“推迟联编”或者“动态联编”上。一个类的函数调用不是在编译时期被确定，而是在运行时才可以确定（也称运行时多态）。而相对于<strong>静态多态</strong>则是在编译时期表现出来的，效率较高，通过template 模板编程实现函数的泛型化。</p><p>overload（重载）具有相同函数名但是参数列表不同函数。和override（重写）派生类实现对基类继承而来的函数的重新编写。一般来讲基类的析构函数都要编写为虚函数。防止内存泄漏。</p><p>何时使用virtual：当设计一个类时，一个函数需要在基类和派生类表现出不同的性质，就需要使用。</p><h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h3><p>超文本传输协议用于在web浏览器和网站服务器间传输信息，http以明文的方式发送信息，不提供加密数据传输，如果攻击者截取了web浏览器和网站服务器间的http报文，就可以读取其中的信息。为了解决这一缺陷，使用另一种套接字层超文本传输协议HTTps，在http基础上加入了SSL协议，SSL证书可以验证服务器身份，并为web和服务器间的通信加密。https协议的主要作用是建立安全信道来保证数据传输的安全，还有确认网站的真实性。</p><p><strong>区别</strong>：1. https协议需要ca证书，因此需要一定的费用。 2. http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输。 3. https和http使用端口不同443 和80。 4. http的连接简单，是无状态的，https是http和SSL协议构建的可进行加密传输身份认证的网络协议。</p><p>https 工作流程：</p><p><img src="https.png" alt="https"></p><p>优点：1. 确保数据正确发送到客户机和服务器 2. 防止数据在传输过程中被窃取和改变。</p><p>缺点：1. 握手（建立连接）阶段比较费时。2. https连接缓存不如http高效，会增加数据开销和功耗。 3. SSL证书需要花钱。</p><ul><li></li><li><strong>Note：2019.9.10更新</strong><h3 id="http请求过程"><a href="#http请求过程" class="headerlink" title="http请求过程"></a>http请求过程</h3></li></ul><p><strong>第一步：输入地址</strong></p><p>当在浏览器输入网址时，浏览器已经开始匹配URL，他会从书签，历史记录等地方找到输入字符串可能对应的url。</p><p><strong>第二步：浏览器查找域名的ip</strong></p><ol><li>当输入完域名后发起请求，然后对域名进行解析，首先会查找本机的hosts文件，如果有和域名对应的ip，就直接使用这个ip地址。</li><li>如果再本地没有找到对应的ip地址，会向本地DNS服务器发起请求，(本地DNS服务器一般是本地网络服务提供商，如移动，电信等。)</li><li>查询你输入的网址的DNS请求到达本地DNS服务器时，会先查询本地缓存，如果此条缓存有记录，则直接返回缓存对应的结果（这个过程是递归查询），如果没有找到记录，则会向根DNS服务器发起请求。</li><li>根域名服务器不会返回查找的结果，而是告诉本地DNS服务器可以继续到域服务器上继续查询，这个过程是迭代的过程。</li><li>本地DNS继续向域服务器发送请求，这样本地DNS服务器就可以知道用户请求的域名和ip的对应关系。</li><li>此时本地DNS服务器不仅要把结果返回给浏览器，还要将这个对应关系保存在缓存中。方便之后请求可以直接返回结果。</li></ol><p><strong>第三步：浏览器向web服务器发送http请求</strong></p><p>此时浏览器会向已知的web服务器请求建立tcp连接，因为tcp协议是全双工，经过三次握手之后就可以相互间进行通信了。此时浏览器再向服务器发起http请求连接，http请求报文一般包含一下信息：</p><pre><code>请求方法 URL协议版本请求头请求正文</code></pre><p>一般请求方法常用的是get和post方法。post一般用在填写表单后提交结果。在请求头和请求报文中还有一个空行，这个空行（\r\n）表示报文头部结束，下面是报文正文。</p><p><strong>第四步：服务器的永久重定向响应</strong></p><p>服务器给浏览器响应一个301的永久重定向响应，这样浏览器就会访问重定向后的新域名。</p><p>状态码301：表示旧地址被永久移除了，搜索引擎在获取新地址的同时也将就地址换成了新地址。</p><p>状态码302：表示旧地址的资源还在，只是暂时的从旧地址跳转到新地址。浏览器不会保存新地址。</p><p><strong>第五步：浏览器跟踪重定向地址</strong></p><p>重定向后浏览器知道了新的地址，会和新的地址建立http请求。</p><p><strong>第六步：服务器处理请求</strong></p><p>当服务器收到来自浏览器的http请求报文后，会将报文解析，进一步封装成响应报文，在一些大的网站不是直接使用http访问，而是通过Nginx，先请求到Nginx，再由Nginx请求服务器，将结果返回给客户端。Nginx的作用是反向代理，好处是当一个服务器挂了后，还是可以继续工作。</p><p><strong>第七步：服务器返回一个http响应</strong></p><p>服务器收到请求，并且处理后返回一个http响应报文，由三部分组成</p><pre><code>状态行响应头响应报文</code></pre><p>在响应头和响应报文中有我们我们需要的具体信息，如cookie， html，image等。响应头和响应报文中间有一个空行表示头部信息结束。</p><p><strong>第八步：浏览器显示html页面</strong></p><p>在浏览器没有完全接收到html页面时就会开始渲染，请求过程是异步的，不会影响页面的渲染。中间涉及一些比较复杂的渲染过程。</p><h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><p>管道，消息队列，套接字（socket），共享内存，信号量。</p><p>管道： 半双工方式，只允许消息向一个方向流动，无名管道只允许在父进程和子进程间通信。 有名管道可以允许在非亲缘关系进程间通信。</p><p>消息队列：可以将不同进程格式化的字节流以消息队列的方式发送给任意进程。</p><p>套接字：在网络编程中可以实现不同主机上间的通信。</p><p>共享内存：速度快，时间简单</p><p>信号量：可以实现数据的封锁访问。实现进程的同步。</p><h3 id="c和c-的区别"><a href="#c和c-的区别" class="headerlink" title="c和c++的区别"></a>c和c++的区别</h3><ol><li>是是面向过程的语言，c++是面向对象的语言，举列子来说在设计一个简易的棋牌游戏时，c语言的思考方式是开始游戏，绘制画面，玩家一出牌，绘制画面，玩家二出牌。判断输赢。 而c++的设计思路则是一类对象设计游戏规则，一类对象设计两名玩家，一类对象初始化游戏画面等等。</li><li>内存管理，c使用malloc/free 向堆申请内存，c++使用new/delete从自由存储区申请内存（自由存储区是一个抽象的概念，并不实际存在，表示c++可以从不止包括堆以外的内存区申请内存）</li><li>c++中的class是对c中struct的扩展，struct中访问成员是public，而class中默认是private。</li><li>c++支持函数重载和函数重写。重载是相同名称的函数参数列表不同。重写是建立在virtual关键字的基础上，子类继承了父类的接口，为了实现子类的特定功能，通过对函数的重写实现。</li><li>c++中有引用，c中没有c中（&amp;）表示取地址。引用和指针的区别在于引用不必初始化，而且一定指向一个对象。表示对象的一个副本，指针则是通过指向对象的地址间接指向对象，但是指针可以修改指向的内容，而且指针必须初始化后才能使用。指针大小固定，都是64位机中的四字节。引用不固定。</li></ol><h3 id="define和inline的区别"><a href="#define和inline的区别" class="headerlink" title="define和inline的区别"></a>define和inline的区别</h3><p>define用于预处理阶段，预处理阶段的工作主要是宏替换，去注释。define只是单纯的代码替换，不会进行类型检查。容易出错。</p><p>inline主要用在一小块代码重复使用的情况下，使用inline代替，并且支持类型检查。但是导致代码膨胀。inline后面的函数会在运行时才进行参数替换。  也说到friend，使用friend修饰的友元函数可以访问类的私有成员，因此破坏了类的封装性。所以不建议使用friend关键字。</p><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程是资源分配的基本单位，进程控制块描述进程的基本信息和运行状态，创建进程和撤销进程都是对pcb的操作。线程是独立调度的基本单位，一个进程中可以有多个线程，共享进程资源。</p><p>区别：1. 线程不拥有资源，但是可以访问隶属进程的资源。 2. 同一进程中，线程的切换不会引起进程的切换，从一个进程的线程切换到另一个进程的线程时会引起进程切换。3. 创建或者撤销进程时，系统要为之分配或者回收资源，付出的开销大于创建或者撤销线程时的开销。4. 线程间的通信可以通过进程的数据进行通信。5.同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC）</p><p>进程拥有独立的数据和堆栈空间，创建一个进程时必须分配独立的资源，线程的开销比较小，不同线程间的切换速度也比较快，效率也比较高。</p><p>在通信机制方面，因为进程间不互相干扰，因此在管道，消息队列，套接字，共享内存等方面使用进程进行通信。</p><p>何时创建线程，何时创建进程：当需要频繁的创建和销毁时优先考虑使用线程。 当需要大量计算时优先使用线程。在并行操作时优先使用线程。</p><ul><li></li><li><strong>Note:2019.9.12更新</strong></li></ul><h3 id="程序编译运行过程和内存分布"><a href="#程序编译运行过程和内存分布" class="headerlink" title="程序编译运行过程和内存分布"></a>程序编译运行过程和内存分布</h3><ul><li>内存分布</li></ul><p>内存的基本构成：可编程区域在基本上上分为静态存储区，堆区和栈区（堆和栈一起称为动态存储区），内存在程序编译的时候就已经分配好了，这块内存在程序的整个运行周期都存在主要放静态数据，全局数据和常量。（这也就是我们常说静态全局变量的生存周期在整个程序运行期间。）</p><p>栈区：在执行函数时，函数内部的局部变量，函数的参数列表都会保存到栈上，函数运行结束时返回调用区域，这一步称为保护现场和回复现场。但是其空间有限，有时会出现stackoverflow（栈溢出），一般是由于程序在运行期间反复调用某一个函数而没有调用出口所致。</p><p>堆区：亦称动态内存分配的区间，程序运行时使用new（自由存储区）和malloc申请的内存区间，可以自行指定所需区间的大小，但是malloc需要计算空间，可以在空间不足时继续分配，new不能在原有空间上继续分配。注意这两个一般和free的delete配合使用，否则会造成内存泄漏，如果没有释放内存，申请的内存空间会在程序最后才释放。 使用动态内存时需要注意访问的范围，如果超过申请的内存空间范围，有时程序不会报错，但是由于存储的数据未知，会导致严重的后果。</p><p>因为是动态分配，所以上述空间在程序运行时才存在，在程序还未运行时（编译后）生成的文件中包括数据段和代码段。</p><p>代码区：存放函数体的二进制代码。<br>字符常量区：一些常量字符存放的位置，程序结束后由系统释放。函数指针所指向的位置一般就是数据区，堆区，栈区。</p><p>数据区:只读数据区，读写数据区。顾名思义，程序中的数据就是存放在这个位置，一些未初始化的变量会在程序运行初始化后开辟空间存放。</p><ul><li>编译过程</li></ul><p>预编译：与编译阶段主要对#的过程做处理，由头文件的展开，宏替换，去掉程序的注释，条件编译等。生成.i文件</p><p>编译： 检查语法，如果没有错误就会生成汇编带代码。</p><p>汇编：将汇编代码转换为机器代码。生一个二进制文件。</p><p>链接： 分为静态链接和动态链接。静态链接是把要调用的库函数链接到程序中，成为可执行文件的一部分。 动态链接所调用的函数代码并没有加入到可执行文件中，而是经过重定位，在程序运行期间当运行到该部分时采取动态链接库中执行相应的代码。</p><ul><li><strong>Note:2019.9.13更新</strong></li></ul><h3 id="SSH原理浅析"><a href="#SSH原理浅析" class="headerlink" title="SSH原理浅析"></a>SSH原理浅析</h3><p>之前都有听说过这个协议，但是没怎么用过，刚好一起复习一下。</p><p>什么是SSH： SSH是一种网络协议，使用SSH远程的登陆另一台计算机，我么就可以认为这种登录是安全的。因此其目的就是为了实现安全远程登录以及其他网络安全服务。</p><p>SSH工作原理：SSH时通过对数据进行加密实现安全性的。加密方式主要有两种，1.对称加密 2.非对称加密 对称加密指加密解密使用同一套密钥。在客户端加密的密钥和在服务器端解密的密钥是相同的。对称加密的 安全强度很高，很难破解，但在实际运用中由于一个服务器会有很多的客户端，一旦一个客户端的密钥被窃取，就好导致整个系统的安全性不复存在。为了解决这个问题，就使用了非对称加密。非对称加密有两个密钥，<strong>“公钥”和“私钥”</strong>。其具有的特性是公钥加密的密文必须使用对应的私钥解密，而从公钥推理出私钥的可能性几乎为0.</p><p><img src="/2019/09/06/一些面试题目/jiami.png" alt="jiami"></p><p>上面是一个客户端<strong>登录</strong>远程服务器的过程1.客户端向服务器发起登录请求。2.服务器将公钥发送给客户端。3.客户端输入账号和密码，并使用公钥加密4.客户端将加密的密码发送给服务器。5.服务器用自己的私钥将登录密码解密进行匹配。并返回验证结果给客户端。</p><p>私钥是服务器独有的，这保证了客户端的登陆信息即使在网络中传输也不会被解密，保证了数据安全性。</p><p><strong>认证！！</strong></p><p>SSH工作流程：1.服务器开启SSH服务，在端口22监听客户端请求，2.客户端发出请求，如果是第一次域服务器建立连接，服务器会发送一个rsa key，而且这个rsa key会被记录到服务器端的 ~/.ssh/known_hosts中，3. 客户端收到来自服务器的rsa key后，就会使用和服务器协商好的加密算法生成会话密钥（用于两者间的通信）。并用rsa key加密会话密钥，发送给服务器。服务器用私钥解密会话密钥，然后同此会话密钥确认加密信息，然后发送给客户端。客户端用会话密钥解密加密的确认信息，到此密钥交换和服务器认证成功。</p><p>接下来是客户端的认证，使用基于口令认证和基于密钥认证。</p><p>基于口令认证：客户端会使用会话密钥加密用户名和密码发送给服务器进行匹配，服务器使用私钥解密后进行确认（容易收到中间人攻击）</p><p>基于密钥认证：客户端生成一对私钥（只用于身份认证），并将公钥发送给服务器，服务器收到公钥后使用公钥加密一段信息，并发送给客户端，客户端使用私钥解密，将数据与会话密钥进行散列后将信息发送给服务端，服务端将两部分信息进行比较，确认客户端是否匹配。</p><h3 id="数据库索引的存储类型"><a href="#数据库索引的存储类型" class="headerlink" title="数据库索引的存储类型"></a>数据库索引的存储类型</h3><p>索引的存储类型有两种，hash和btree。索引是单独存储在磁盘上的数据结构。他们包含对数据库表中所有记录的引用指针，可以加快对数据库特定数据的查询效率。</p><p>索引的优点：1. 通过创建唯一索引，可以保证数据库中每行数据的唯一性，2. 可以加快数据的查询速度。 </p><p>索引的缺点 创建索引需要耗费时间，需要耗费更多内存。对数据库中数据进行删改时也需要对索引进行动态维护。</p><h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><p>封锁粒度： mysql中提供行级锁和表级锁。 封锁粒度越大（表级锁），则并发度越低，但是系统开销也会越低。封锁类型。 读锁（共享锁/s锁）：加了s锁后还可以添加锁，但是不能加x锁。  写锁（排他锁/x锁）：加锁后不能再添加其他锁。 三级封锁协议 一级：对数据进行修改时必须加x锁。 避免了修改被覆盖。二级封锁协议：，在一级的基础上，再读取数据时必须加锁，读取结束后释放。 三级：在二级的基础上读取数据时加s锁，事务结束后释放。</p><h3 id="为什么析构函数要申明为虚函数"><a href="#为什么析构函数要申明为虚函数" class="headerlink" title="为什么析构函数要申明为虚函数"></a>为什么析构函数要申明为虚函数</h3><p>当有子类继承一个父类时，我们可以使用一个父类指针指向一个子类对象，这样在对这个对象进行析构时，顺序是先析构子类对象，再析构父类对象，如果不使用虚函数，那么父类对象就不会被析构，如果父类中含有指针成员，就容易导致内存泄漏。</p><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><p>处理机管理，设备管理，存储管理，文件管理</p><p>处理机管理：主要是对进程的控制和管理，实现进程同步进程通信等。</p><p>设备管理：负责设备分配，设备处理.</p><p>存储管理：主要是对内存分配，地址映射内存保护的管理。</p><p>文件管理：文件存储空间的管理，目录的管理，文件读写管理和保护。</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ol><li>先来先服务:如果先来的任务需要花费的时间更多,则等待的时间更久.</li><li>短作业优先. </li><li>优先级法</li></ol><p>死锁的原因:资源竞争,进程推进方式非法. 产生条件:互斥条件,占有并等到,不可剥夺,环路等待.</p><h3 id="局部性原理和页面调度算法"><a href="#局部性原理和页面调度算法" class="headerlink" title="局部性原理和页面调度算法"></a>局部性原理和页面调度算法</h3><p>时间局部性:如果某个信息被访问,那么它在不久的将来也很有可能会多次被访问.</p><p>空间局部性:如果某个位置的信息被访问,那么他相邻的信息也很有可能会被访问到.</p><p>页面调度算法:</p><p>先进先出置换:类似于队列,总是最先淘汰进入内存的页面.有些数据可能会被频繁的进出,导致产生抖动.</p><p>LRU置换算法:最久未使用算法,记录页面中每个字段自上次访问后到现在所经历的时间,置换出时间最长的页面.</p><h3 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h3><p>shutdown ：执行关机</p><p>reboot：重启</p><p>vim命令： ：w 保存 ：q退出  ：wq保存和退出 ：q！不保存退出 ：w filename 另存为 ：set nu 显示行号  ：set nonu 不显示行号</p><p>挂载：挂载利用目录作为文件系统的进入点，进入目录后就可以读取文件系统的数据。</p><p>文件时间：  modification（mtime）：文件内容更新就会更新 status time（ctime）： 文件属性/权限更新就会更新。  access time（atime）： 读取文件时就会更新。</p><p>touch： 创建新文件或更新文件时间</p><p>cp src dst ：复制文件</p><p>mv filename 路径： 移动文件</p><p>rm filename： 删除文件</p><p>chmod：切换模式</p><p><strong>获取文件内容</strong></p><p>cat：获取文件内容 </p><p>tac：从最后一行获取文件内容</p><p>more： 可以一页一页的查看文件</p><p>less： 和more类似，只是多了向前翻页的功能</p><p>head： head -n 5 filename 显示文件前五行</p><p>tail： tail -n 5 filename  显示文件后5行</p><p>wc -l filename：显示文件行数 </p><p>sed -i ‘1’d filename //删除文件第一行</p><p>sed -n  ‘1’d filename //删除文件最后一行</p><p><strong>指令/ 文件搜索</strong></p><p>which ：查询指令所在目录</p><p>whereis ：文件搜索，速度较快，应位只搜索特定目录</p><p>locate：文件搜索，使用关键字或者正则表达式进行搜索。</p><p>find：文件搜索，可以使用文件属性和权限进行搜索。</p><p><strong>网络</strong></p><p>ipconfig //查看网络配置</p><p>ifdown 网课设备名 //关闭网卡</p><p>ifup 网卡设备名 //气用网卡</p><p>netstat -t //列出tcp协议端口 //-u 列出udp协议端口  //-l 仅列出在监听的端口  //-a 列出所有的连接   //-r  路由表</p><p>nslookup 翻译域名对应的ip和dns，其中 server（服务器）表示当前的DNS</p><p><img src="/2019/09/06/一些面试题目/nslookup.png" alt="nslookup"></p><p>ping ip 判断网络情况</p><p>hostname  显示主机名字</p><p>traceroute ip  路由跟踪命令<br><strong>查看进程</strong></p><p>ps // -A 列出所有进程  -W 可以显示较多的资讯。</p><p><strong>i/o多路复用</strong></p><p>概念：i/o复用可以让单线程具有处理多个i/o事件的能力。如果一个web服务器没有i/o复用，那么每一个socket连接都需要一个线程去处理，如果同时连接很多个socket连接，将创建相同数量的线程。 因此i/o复用使得系统开销更小。</p><p>i/o模型： 阻塞  非阻塞   同步  异步。  阻塞/非阻塞是等待i/o完成的方式。阻塞要求等待用户程序停止执行直到io完成，非阻塞在io完成前还能继续执行。</p><p>同步/异步是获知i/o完成的方式，同步需要时刻关心i/o是否已经完成。异步需要主动关心，会在io完成后通知它。</p><p>select/poll/epoll 三个都是i/o多路复用的具体实现</p><p>select/poll 功能：select默认只能监听1024个描述符（连接），二者都不是线程安全的，这意味着在一个线程内只能进行一组io流。poll可以监听任意个数的连接。 </p><p>epoll：epoll是i/o多路复用的最新实现，epoll是线程安全的，但是只支持linux系统。</p><h3 id="http-1-0-1-1-2-0"><a href="#http-1-0-1-1-2-0" class="headerlink" title="http 1.0 /1.1 /2.0"></a>http 1.0 /1.1 /2.0</h3><p>http 1.0 不支持持久连接，请求队列的第一个请求由于服务器繁忙导致后面的请求阻塞。</p><p>http 1.1 支持持久连接，使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive.一个tcp连接可以传送多个http请求，减少了建立/关闭连接所需要的时间。 增加了请求头和相应头来扩充功能。</p><p>http 2.0 支持多路复用,支持首部压缩算法。</p><h3 id="动态规划的几个特性"><a href="#动态规划的几个特性" class="headerlink" title="动态规划的几个特性"></a>动态规划的几个特性</h3><p>最优子结构性：问题的最优解中的子问题的解也是最优的。</p><p>子问题重叠性：从最优解向下计算时，其中许多子问题会重复求解。</p><p>后无效性：按照一定的顺序得到的当前问题的结果，他的结果不会是之前子问题的结果，对后面的结果不产生影响。</p><h3 id="封装-继承-多态"><a href="#封装-继承-多态" class="headerlink" title="封装 继承 多态"></a>封装 继承 多态</h3><p>封装:封装是实现面向对象的第一步.将函数和数据成员编写成类,封装可以保护代码被无意中破坏,这得益于类成员的访问权限.private:只有类本身可以访问,protected:类本身和继承的子类可以访问.public,公开都可以访问.</p><p>继承:继承实现了代码重用,节省了开发时间.通过继承也可以实现对一个方法的重写.</p><p>多态:同一操作对于不同的对象,可以有不同的解释,会出现不同的结果.可以使用基类的指针指向子类对象,这样访问的方法是子类对象.</p><p>编译时多态(静态多态)是通过函数重载来实现的,函数重载是对于一个同名函数,他的参数列表不同. 运行时多态(动态多态)是指运行时,根据实际情况决定运行何种操作.比如上面的基类指针指向子类对象.这种通过virtual关键字实现. </p><h3 id="fork创建进程"><a href="#fork创建进程" class="headerlink" title="fork创建进程"></a>fork创建进程</h3><p>一个现有进程可以调用fork创建一个新的进程。 pid = fork();fork函数被调用一次，但是返回两次，返回值为0，表示子进程。返回值为-1表示创建进程失败，其余表示返回父进程，可以通过返回值的不同进入不同的进程，父进程和子进程共享代码段，但是分别拥有自己的数据段和堆栈段。</p><h3 id="proc目录"><a href="#proc目录" class="headerlink" title="/proc目录"></a>/proc目录</h3><p>linux内核提供了一种通过/proc访问运行时内核的部分数据结构，改变内核设置的机制。用户和应用程序可以通过/proc 得到系统的信息，并可以改变内核的某些参数。由于系统的信息是动态改变的，因此proc是从系统内核读取信息并提交的。</p><p>/proc/cpuinfo  读取cpu信息</p><p>/proc/devices  已加载的设备并分类</p><p>/proc/meminfo  RAM使用的相关信息</p><p>/proc/net  网卡设备信息</p><p>/proc/N  pid为N的进程信息</p><p>/proc/N/stat  pid为N的进程状态</p><h3 id="GBN和SR协议快速重传"><a href="#GBN和SR协议快速重传" class="headerlink" title="GBN和SR协议快速重传"></a>GBN和SR协议快速重传</h3><p>GBN协议：在发送方维护一个一定大小的窗口，这个窗口中是当前已经发送还未确认或者即将要发送的数据，在接受方只维护一个大小为1的报文窗口，如果到达的报文由于某些原因在中间信道上导致失序，则接收方不接收这些报文，并且返回上一次的确认ack给发送方，并且发送方收到之后就需要重新发送窗口中的内容，只有有序到达发送方窗口才会向后移动。</p><p>SR协议：发送方和接收方都维护一个窗口，但是两个窗口的序号不一定对等。当接收方收到来自发送方的报文后，如果失序，会暂时缓存，并且发送给发送方上次确认的ack，直到收到丢失的失序报文后才一起将缓冲区的数据递交上层。</p><p>快速重传：快速重传相对于选择重传的优点在于它不依赖于定时器的时间到，而是当发送方连续三次收到三个冗余的ack时就会重新发送发送这个失序报文。需要明白的一点是由于报文是类似流水线传输的，因此收到三个冗余ack的时间会比定时器时间到的花费要少。</p><h3 id="inner-join-，left-join，right-join，full-join"><a href="#inner-join-，left-join，right-join，full-join" class="headerlink" title="inner join ，left join，right join，full join"></a>inner join ，left join，right join，full join</h3><p>上述四种都是连接查询，他们没有太大的区别，只是在对表进行查询时结果又稍微不同。</p><p>inner join：在对两张表进行查询时只保留表中完全匹配的信息。</p><pre><code>SELECT p.LastName, p.FirstName, o.OrderNoFROM Persons pINNER JOIN Orders oON p.Id_P=o.Id_P and 1=1　　--用and连接多个条件ORDER BY p.LastName</code></pre><p>left join：对两张表进行查询时，如果只是左边的表具有需要的信息，右边的表没有，也会显示。（返回左表的所有行，即使右表没有匹配的记录）</p><pre><code>SELECT p.LastName, p.FirstName, o.OrderNoFROM Persons pLEFT JOIN Orders oON p.Id_P=o.Id_PORDER BY p.LastName</code></pre><p>right join： 对两张表进行查询时，返回右表的所有行，即使左表没有行与之匹配。</p><pre><code>SELECT p.LastName, p.FirstName, o.OrderNoFROM Persons pRIGHT JOIN Orders oON p.Id_P=o.Id_PORDER BY p.LastName</code></pre><p>full join：返回左表和右表所有没有匹配的行和已经匹配的行。 </p><pre><code>SELECT p.LastName, p.FirstName, o.OrderNoFROM Persons pFULL JOIN Orders oON p.Id_P=o.Id_PORDER BY p.LastName</code></pre><h3 id="strcpy-strncpy-memcpy-memmove"><a href="#strcpy-strncpy-memcpy-memmove" class="headerlink" title="strcpy strncpy memcpy memmove"></a>strcpy strncpy memcpy memmove</h3><p>strcpy(dst,src) 拷贝字符串，拷贝结束后再末尾加上’\0’，且src和dst的空间不可以重叠。返回dst的指针</p><p>strncpy(dst,src,size_t) 将size_t长度的src拷贝到dst，如果不足size_t,则补充NULL到size_t长度</p><p>memcpy（dst,src,size_t） //将size_t个<strong>字节</strong>拷贝到dst区域，两者不能重叠。一定会拷贝size_t个字节。</p><p>memmove(dst,src,size_t) //与memcpy类似，只是当空间重叠时也可以正确执行。</p><h3 id="指针数组-数组指针-指针函数-函数指针"><a href="#指针数组-数组指针-指针函数-函数指针" class="headerlink" title="指针数组 数组指针 指针函数  函数指针"></a>指针数组 数组指针 指针函数  函数指针</h3><p>指针数组：可以这样理解，本质是一个数组，数组的每个元素都是一个指针，表示为<strong>*p[]</strong>;根据优先级，先是[],再是 *</p><p>数组指针：(*p)[],根据优先级，先结合括号，再结合[],于是其本质相当于用指针去指向一个数组的所有元素，每个数组元素都是匿名的，使用指针指向。</p><p>指针函数，int * f(); 用指针去指向一个函数。这个比较常见。</p><p>函数指针 int (*f)();这样来理解，此处指针的类型是一个函数类型，所以本质是一个指针，当作指针来使用，只不过需要用函数来指向。使用示例</p><pre><code>int add(int x,int y){    return x+y;}int sub(int x,int y){    return x-y;}//函数指针int (*fun)(int x,int y);int main(int argc, char *argv[]){    QApplication a(argc, argv);    //第一种写法    fun = add;    qDebug() &lt;&lt; &quot;(*fun)(1,2) = &quot; &lt;&lt; (*fun)(1,2) ;    //第二种写法    fun = &amp;sub;    qDebug() &lt;&lt; &quot;(*fun)(5,3) = &quot; &lt;&lt; (*fun)(5,3)  &lt;&lt; fun(5,3)；    return a.exec();}</code></pre><h3 id="预防栈溢出"><a href="#预防栈溢出" class="headerlink" title="预防栈溢出"></a>预防栈溢出</h3><p>1.在递归函数中用static代替nostatic。 2.增大栈的空间 3.把递归函数修改为非递归函数。</p><h3 id="static-auto-register-extern"><a href="#static-auto-register-extern" class="headerlink" title="static auto register extern"></a>static auto register extern</h3><p>auto： 修饰局部变量，一般内存空间分布在栈上。  static: 修饰静态局部变量，存储在静态数据段，默认初始化为0. 修饰全局变量，整个生存周期是程序运行期间。  register: 修饰的变量会尽量分配到内存中的寄存器中，这样可以提升运行效率。 extern: 主要修饰全局变量，在文件a中定义的变量在文件c中使用可以使用extern修饰。</p><h3 id="数据库保护"><a href="#数据库保护" class="headerlink" title="数据库保护"></a>数据库保护</h3><p>数据库保护又称为数据库控制：包括安全性控制，完整性控制，并发性控制和数据恢复。</p><p>安全性控制：防止因非法使用数据库造成的数据泄漏，更改和破坏。</p><p>完整性控制：保护数据库的正确性，有效性和相容性。</p><p>并发控制：防止多个用户同时存取统一数据造成数据不一致。</p><p>数据库恢复：和数据库日志文件有关</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>发现一个很好理解的KMP算法：<br><a href="https://leetcode-cn.com/problems/implement-strstr/solution/kmp-suan-fa-xiang-jie-by-labuladong/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-strstr/solution/kmp-suan-fa-xiang-jie-by-labuladong/</a></p><h3 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound() upper_bound()"></a>lower_bound() upper_bound()</h3><p>两者都是通过二分查找的方式在一个容器种进行查找的map和vector种可以直接使用，但是某些容器（比如list）并没有重载这两个方法，需要自行实现。</p><p>在 从小到大的有序数组中：</p><p>lower_bound(begin,end,num)： 在数组中查找第一个大于或等于num的数字的地址(map则返回一个迭代器)，通过指针的运算可以得到这个下标位置。找不到则返回end指针</p><p>upper_bound(begin,end,num):在数组中查找第一个大于num的数字的地址，（map则返回一个迭代器），找不到则返回end。</p><p>在大到小的有序容器中：</p><p>lower_bound(begin,end,num,compare)： 在数组中查找第一个小于或等于num的数字的地址(map则返回一个迭代器)，通过指针的运算可以得到这个下标位置。找不到则返回end指针</p><p>upper_bound(begin,end,num,compare):在数组中查找第一个小于num的数字的地址，（map则返回一个迭代器），找不到则返回end。最后的compare是一个仿函数，是用于比较的方式。</p><h3 id="kruskal算法-Prim算法"><a href="#kruskal算法-Prim算法" class="headerlink" title="kruskal算法 Prim算法"></a>kruskal算法 Prim算法</h3><p>kruskal算法:也称为加边法，初始最小生成树的边数为0，每迭代一次就选择一条满足条件的最小代价边加入到最小生成树的边集合中。</p><p>算法过程：1.把图中所有的边按代价从小到达排序 2.把图中的n个顶点看成独立的n棵树组成的森林 3.按权值从小到大选择边，所选边应满足边的两个顶点属于不同的树，则将这条件加入成为生成树的一条边。并将这两棵树合并为1棵树。4.重复3直到所有顶点都在一棵树内或者有n-1条边为止。</p><p>Prim算法：也称为加点法，每次迭代代价最小的边对应的点，加入到最小生成树中。算法从某一点s开始，逐渐扩张覆盖整个联通网的所有顶点。</p><p>算法过程：1.图的顶点集合为V，生成树顶点集合初始为u={s}，v=V-u。2.在两个集合能够组成的边中，选择一条代价最小的边(v0,u0),并把v0加入到集合u中，3.重复上述步骤，直到最小生成树有n个顶点或者n-1条边为止。  由于不断向集合u中加入点，所以不在 集合u中的点的最小代价必须同步更新，需要建立一个辅助数组来维护集合v中的点相对于集合u中的最小代价。</p><p>一篇很好的关于这两个算法的博客：<a href="https://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">https://blog.csdn.net/luoshixian099/article/details/51908175</a> 感谢原作者。</p><h3 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h3><p>数据库优化包括几个方面，数据结构，sql语句，索引，系统结构，硬件等。 设计好的数据结构可以方便后续优化。</p><p><img src="/2019/09/06/一些面试题目/database.png" alt="database"></p><p>从上图看出，数据结构和sql语句索引是成本较低效果较好的优化方式。</p><p>优化方向 ：1.sql语句和索引的优化。根据需要写出较好结构的sql，然后根据sql语句在表中建立有效的索引。 2.合理的数据库表结构：根据数据库范式和实际情况设计良好的表结构。可以大大缩短运行时间。  数据库的五大约束</p><pre><code>PRIMARY key:设置主键约束；UNIQUE：设置唯一性约束，不能有重复值；DEFAULT 默认值约束NOT NULL：设置非空约束，该字段不能为空；FOREIGN key :设置外键约束。</code></pre><p>使用枚举或整数代替字符串类型。，尽量避免使用NULL字段（很难查询且暂用额外空间）。3.尽量少用数据库提供的函数。选择合适的索引列，选择在where，group by， order by，on 等从句中出现的列作为索引。<br>一篇文章关于数据库优化总结的很好，码住，可能以后用得到，同时感谢原作者。<a href="https://blog.csdn.net/u013628152/article/details/82184809" target="_blank" rel="noopener">https://blog.csdn.net/u013628152/article/details/82184809</a></p><h3 id="类的大小"><a href="#类的大小" class="headerlink" title="类的大小"></a>类的大小</h3><p>sizeof(class),c++中空类的大小为1.虚函数因为有虚指针指向，所以在64位机种占4字节。成员函数不占用空间。</p><h3 id="虚继承和虚基类"><a href="#虚继承和虚基类" class="headerlink" title="虚继承和虚基类"></a>虚继承和虚基类</h3><p>在c++的多重继承中，可以从多个直接基类产生产生派生类，但是多个基类的相互交织可能会带来问题，如下图所示：</p><p><img src="/2019/09/06/一些面试题目/jicheng.png" alt="jicheng"></p><p>此时对于类D，A中的成员可能来自两个方向，A-B-或者A-C-D。在访问时可能会出现歧义。为了解决多继承时的命名冲突和冗余数据问题，C++提出了虚继承，使得在派生类中只保留一份间接基类的成员。如下图：</p><p><img src="/2019/09/06/一些面试题目/jicheng2.png" alt="jicheng2"></p><p>其中呗共享的基类成为虚基类（类A），但是其中只有出现类D时才会对虚基类有所需求，如果类B，C不是从A虚继承得到，那么类D还是会保存两份成员。</p><h3 id="http请求范围"><a href="#http请求范围" class="headerlink" title="http请求范围"></a>http请求范围</h3><p>如果响应中存在Accept-Range首部，那么表示该服务器支持范围请求。可以使用 CURL 发送一个HEAD请求进行检测。</p><pre><code>CURL -I https://sj110.github.io</code></pre><p>如果站点未发送Accept-Range首部，那么有可能不支持范围请求。也有站点将Accept-Range设置为none表示不支持范围请求。</p><p>如果服务器支持范围请求，可以在首部只是服务器应该返回文件的哪一部分或者哪几部分</p><pre><code> //单个范围curl https://sj110.github.io -I -H &quot;Range:bytes=0-1023&quot;//多重范围curl https://sj110.github.io -I -H &quot;Range:bytes=0-100,200-250 &quot;</code></pre><p>范围请求的响应有三种状态：1.请求成功情况下，服务器返回206 Partial Content 状态码 2. 在请求范围越界（超过资源大小），服务器会返回416 Requested Range Not Satisfiable 状态码 3.在不支持范围请求的情况下，返回200 OK状态码，并返回整个内容。</p><p>参考自：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests</a></p><h3 id="操作系统虚拟内存换页过程"><a href="#操作系统虚拟内存换页过程" class="headerlink" title="操作系统虚拟内存换页过程"></a>操作系统虚拟内存换页过程</h3><p>程序的空间局部性和时间局部性：空间局部性：一旦一个程序访问了某个存储单元，那么在不久之后也将访问该单元附近的存储空间。<strong>即程序一段时间内访问的空间可能集种在一定范围内。</strong>时间局部性：如果程序的某条指令被执行，那么今后还有可能再次执行。<strong>比如程序中的循环操作。</strong></p><p>虚拟存储器：从程序的局部性原理可知，在运行一个程序时没有必要将所有的程序装载到内存中，只需要其中的某些内存页，在程序的运行过程中，如果需要访问的那部分内容不在内存空间中，发生缺页中断，更进一步，如果此时内存已满，则需要使用内存置换算法调出暂时不用的页面，放入新的需要访问的页面，对应算法：<strong>最佳置换法</strong>：调出以后不再使用的页面，放入新的内存页，因为无法预料以后是否使用调出的空间，所以算法无法实现。<strong>最久未使用（LRU）</strong>：从当前开始，每次请求内存时，为其中未被访问的内存空间设置一个计数器，统计每次内存访问时，如果未被访问，计数器加1，否则计数器清零，当空间已满时，调出计数器值最大的页面（最久未被访问的页面。） <strong>FIFO(先进先出)</strong>:类似队列机制，但是容易造成系统抖动，因为在程序中可能某些全局变量将会多次访问，就会导致多次置换页面。    </p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;想着之后要面试了，就看一下面试相关的一些题目，稍微做一下总结。&lt;/p&gt;
&lt;h3 id=&quot;关于引用和指针的区别&quot;&gt;&lt;a href=&quot;#关于引用和指针的区别&quot; class=&quot;headerlink&quot; title=&quot;关于引用和指针的区别&quot;&gt;&lt;/a&gt;关于引用和指针的区别&lt;/h3&gt;&lt;p&gt;突然遇到了就还是稍微总结一下两者的区别。可能不够完善，以后继续补充。引用是变量的别名，指针是间接指向了其他变量。&lt;/p&gt;</summary>
    
    
    
    <category term="复习" scheme="http://yoursite.com/categories/复习/"/>
    
    
    <category term="复习" scheme="http://yoursite.com/tags/复习/"/>
    
  </entry>
  
  <entry>
    <title>网络复习</title>
    <link href="http://yoursite.com/2019/09/02/%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/09/02/%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</id>
    <published>2019-09-02T04:42:21.000Z</published>
    <updated>2019-10-07T03:54:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>拖了好几天，今天复习一下计算机网络中的一些知识点，感觉这门课我一直学的不太好，主要是因为实践也比较少，但是这些知识也是比较重要的，只能之后多看书多找点有关练习了。</p><a id="more"></a><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>DNS:</strong> 识别主机的方式有两种，一种是通过主机名或者ip地址访问主机，还有一种就是DNS域名服务器。1. DNS是由一个分层的DNS服务器实现的分布式数据库。2. 一个允许主机查询分布式数据库的应用层协议。DNS一般运行在UDP上。DNS一般运行在其他应用层协议上，用于将用户提供的主机名解析为ip地址。使用端口号为53</p><p>比如访问 <a href="http://www.hust.edu/index.html" target="_blank" rel="noopener">www.hust.edu/index.html</a> 时DNS的运行如下：1.同一主机上运行着DNS应用的客户机端。2. 浏览器从上述URL中抽取出主机名 <a href="http://www.hust.edu" target="_blank" rel="noopener">www.hust.edu</a>, 并将主机名传给应用的客户机端。 3.  DNS向DNS服务器发送一个包含主机名的请求。 4. DNS客户机收到一份应答报文，报文中包含主机名的ip地址 5. 浏览器通过该ip地址定位的http服务器建立tcp连接</p><p>DNS缓存：为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛运用了缓存技术。原理是当一个DNS服务器在接收到一个DNS回答时，DNS服务器能将回答中的信息缓存在本地。</p><p><strong>FTP：</strong>FTP是网络上用于文件传输的一套标准协议。使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。与HTTP的区别，使用两个并行的TCP连接来传输文件，一个是控制连接，一个是数据连接。FTP端口号 控制连接21，数据连接20</p><p><strong>SMTP:</strong>使用TCP端口号25.是一组用于源地址到目的地址传送邮件的协议。控制邮件的中转方式，帮助每台计算机在发送或中转信件时找到下一个目的地。</p><p><strong>HTTP:</strong>协议端口号为80 用于服务器传输超文本到本地浏览器的数据传送协议。web页面是由对象（html文件）组成的。 URL地址包含 两部分内容，主机地址+对象路径名。web服务器用于存储web对象，每个对象由URL寻址。web服务器实现了HTTP的服务器端。</p><p>持久连接和非持久连接：当http协议运行在tcp协议上时，如果每个请求响应是分别由不同的tcp连接发送，那么称为非持久连接。如果所有请求都是由一个TCP连接发送称为持久连接。非持久连接需要对每个对象建立和维护一个TCP连接，如果是串行方式，则会造成严重的时延。持久连接在服务器响应后保持tcp连接打开。一段时间仍未使用则断开连接。</p><p>http请求方法： GET：请求指定的页面信息，并返回实体主体。</p><p>POST：  向指定资源提交数据进行处理（如提交表单或者上传文件），数据被包含在请求体中，post请求可能导致新的资源的建立或者已有的资源修改。</p><p>PUT： 从客户端向服务器端传送的数据取代指定文档的内容。</p><p>DELETE：请求服务器删除指定页面。</p><p>状态码： 100 Continue:继续，客户端继续其请求<br>101 Switching Protocols:切换协议，服务器根据客户端的请求切换协议。只能切换到更高级的协议。</p><p>200 OK 请求成功。</p><p>301 Moved Permanently:永久移动，请求的资源已被永久的移动到新的URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替。</p><p>400 Bad Request： 客户端请求语法错误，服务器无法理解。</p><p>401 Unauthorized: 请求要求用户的身份认证。</p><p>403 Forbidden： 服务器理解客户端的请求，但是拒绝执行此请求（权限不够）</p><p>404 Not Found： 服务器无法根据客户端的请求找到资源.</p><p>408 request timeout: 服务器等待客户端发送的请求时间过长，超时</p><p>500 Internal Server Error: 服务器内部错误，无法完成请求。</p><p>503 Service Unavailable： 由于超时或系统维护，服务器展示无法处理客户端的请求。</p><p>504 Gateway Timeout:充当网关或代理服务器，未及时从远端服务器获取请求。</p><p><strong>DHCP</strong> 动态主机设置协议，是一个局域网的网络协议，使用UDP工作，主要用于1. 内部网络或网络服务提供商自动分配ip地址给用户。2. 内部网络管理员作为对所有电脑作中央管理的手段。</p><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>运输层协议为运行在不同主机上的应用进程提供了逻辑通信。<br>在协议栈中，运输层位于网络层上，运输层为运行在不同主机上的进程提供逻辑通信，而网络层提供了不同主机间的逻辑通信。</p><p>多路分解和多路复用：将运输层报文段交付到正确的套接字称为多路分解。从源主机的不同套接字收集数据块，并为每个数据块封装上首部信息生成报文段称为多路复用。</p><p>面向无连接的运输 UDP：</p><p>如果应用程序开发使用UDP而不是TCP，则应用程序几乎直接与IP打交道，UDP从应用层得到数据，附加上多路复用和多路分解所需的源端口和目的端口号，再附加上报文长度，校验和，然后将形成的报文交付给主机。如果报文段到达主机，则根据目的端口号来将报文段中数据交付给正确的进程。整个过程发送方和接受方没有握手，因此是无连接的。</p><p>UDP协议特征：无连接，不会引入建立连接的时延。尽可能交付，面向报文传输，没有拥塞控制，支持一对一，一对多，多对一，多对多交互通信，首部开销小，</p><p>可靠数据传输协议TCP：是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。<br>特征： 面向连接， 点对点通信，可靠交互，全双工通信，面向字节流。</p><p>tcp如何实现可靠交付：确认和超时重传，数据合理分片和排序，流量控制，拥塞控制，数据校验。    </p><p>tcp字节流和UDP数据报的区别：两者的区别在于TCP接收的是一堆数据，而每次取多少由主机决定;而UDP发的是数据报，客户发送多少就接收多少。</p><p>tcp报文格式：</p><p><img src="/2019/09/02/网络复习/tcp.png" alt="tcp"></p><p>tcp状态控制码：占6bits，含义如下：</p><p>URG：紧急比特，当为1时，表明紧急指针字段有效，代表该封包为紧急封包，告诉系统该报文段为紧急数据，应尽快传输。</p><p>ACK：确认bit，当为1时，确认号字段有效，代表封包为确认封包。</p><p>PSH（push function）： 若为1，代表要求对方立即传送缓冲区内其他对应封包，无需等待缓冲满了再传。</p><p>RST:复位比特，当为1时，表明TCP连接出现严重差错，必须释放连接重新建立。</p><p>SYN：同步比特，为1时，表示这是一个请求连接或者连接接受报文，通常带有SYN报文表示要连接到对方。</p><p>FIN：终止比特，用来释放一个连接，当为1时，表明此报文段的发送端数据已经发送完毕。要求释放连接。</p><ul><li><p>TCP三次握手连接建立：1.客户端发送SYN给服务器，说明客户端请求建立连接。2. 服务端收到客户端的SYN，并回复SYN+ACK表示同意连接。3. 客户端收到SYN+ACK后回复ACK给服务端表示收到了建立连接的同意报文。4.服务端收到客户端的ACK，表示连接已经建立，现在可以发送数据了。</p></li></ul><p>进行三次握手的原因：1. 因为信道不可靠，而tcp确保可靠交付，需要在可靠信道上进行数据传输，而三次握手是理论上的最小值。 2. 因为双方都需要确认对方收到了自己发送的序列号，这个过程最少需要进行三次通信。3. 为了防止已经失效的连接请求报文端突然传送到服务器，导致错误。</p><p><img src="/2019/09/02/网络复习/estanblish.png" alt="estan"></p><ul><li></li><li></li></ul><p>TCP四次挥手释放连接：1.客户端发送FIN给服务器，说明客户端不在发送数据给服务器了，请求释放连接。 2. 服务器收到客户端的FIN，并回复ACK给客户端（表示同意释放连接）。 3. 客户端收到来自服务器端的ACK，此时客户端到服务器的连接已经释放（但是服务器到客户端的连接还未释放），所以客户端还可以接收数据。 4. 服务器继续发送之前为发送完的数据给客户端。5. 服务端发送ACK+FIN给客户端，说明服务端此时已经发送全部数据，请求断开连接，就算没有收到客户端回复，过段时间也会断开连接。 6. 客户端接收到FIN+ACK，并恢复ACK给客户端。（同意释放连接。） 7. 服务端收到ACK后，两端断开连接。</p><p>为什么要进行四次挥手： 因为TCP是全双工模式，客户端向服务器端关闭连接后（1 2），服务器端继续传输之前没有传完的数据，然后服务器端向客户端关闭连接（3 4）.所以tcp释放连接时服务器的ACK和FIN时分开发送的，中间还有剩余的数据传输。tcp建立链接时SYN和ACK时一起发送的，所以建立需要三次，释放需要四次。</p><p>为什么TCP连接时可以ACK和SYN一起发送，而释放时ACK和FIN是分开发送呢？ 因为客户端请求建立连接时，服务器器收到SYN，因为此时没有传输数据，所以SYN和ACK一起传输。而释放连接时，在收到客户端的ACK后，服务器端还有数据没有发完，需要继续发送数据，因此FIN和ACK分开了。</p><p><img src="/2019/09/02/网络复习/destroy.png" alt="destroy"></p><ul><li></li><li></li></ul><p>TCP黏包问题：原因：tcp是一个基于字节流的传输服务，流意味着TCP所传输的数据是没有边界的，可能出现两个数据包黏在一起的情况。</p><p>解决：1. 发送定长包，如果每个消息长度都是一样的，那么接受对等放只需要累计接收数据，直到数据等于一个定长值就将其作为一个消息。2. 包头加上包体长度，接受对等方先接受包头长度，依据包头长度来接收包体。3. 使用更复杂的协议。</p><ul><li></li><li></li></ul><p>TCP流量控制： 就是为了让发送方速率不要太快，要让接受方来得及接收。</p><p>方法，利用可变窗口进行流量控制。tcp通过让发送方维护一个称为接收窗口的变量来进行流量控制，接收窗口用于告诉发送方，该接收方还有多少可用的缓存空间。</p><p><img src="/2019/09/02/网络复习/control.png" alt="control"></p><ul><li></li><li></li></ul><p>TCP拥塞控制<br>概念：拥塞控制是为了防止过多的数据注入到网络中，这样可以使网络的路由器不至于过载。</p><p>方法： 慢启动 拥塞避免 快重传 快恢复</p><p><img src="/2019/09/02/网络复习/yongsai.png" alt="yongsai"></p><p><img src="/2019/09/02/网络复习/chongchuan.png" alt="chongchuan"></p><p><img src="/2019/09/02/网络复习/liucheng.png" alt="liucheng"></p><p>慢启动：由小逐渐增大发送窗口，每次接收到报文段时将窗口大小加倍。（初始发送方只能发送一个报文段。）当到达ssthresh时，为了方式拥塞窗口过大导致网络阻塞，使用拥塞避免。</p><p>拥塞避免：当拥塞窗口逐渐增大，没经过一个RTT就将窗口增加1.是窗口大小按照线性增长。</p><p>加法增大乘法减小，（乘法减小）只要出现超时，将窗口大小置为1，并开始慢启动。 （加法增大） 当网络频繁出现超时情况时，ssthresh就下降的很快。减小注入网络中的分组数。</p><p>快重传： 要求首先接受方收到一个时需的报文段后立刻发出重复确认，不要等待自己发送数据时才稍待确认。</p><p>快恢复：1. 当发送方连续收到三个重复确认后，执行乘法减小算法，将门限值减半，防止发生拥塞。2. 由于发送发现在认为网络可能没有发生阻塞，因此不执行慢启动，而是把拥塞窗口设置为慢启动门限减半后的值。然后执行拥塞避免算法。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>运输层依赖于网络层提供的主机到主机的通信服务。网络层的重要区分：转发和选路。 转发：当一个分组到达某个路由器的输入链路时，该路由器必须将该分组移动到合适的输出链路。选路：当分组从发送放到接收方时，网络层必须决定这些分组所采用的路由或者路径。</p><p>网络服务模型：确保交付，具有时延上界的确保交付，有序分组交付，确保最小带宽，完全性服务。</p><p>虚电路网络和数据报网络：仅在网络层提供连接服务的网络称为虚电路网络。仅在网络层提供无连接服务的网络称为数据报网络。</p><p>路由器：输入端口：完成将一条输入的物理链路端接到路由器的物理层也要完成远端数据链路层数据的交互。还要完成转发和查找。交换结构：是一台路由器中的网络，将路由器的输入端口连接到输出端口。 输出端口：存储经过交换结构转发给他的分组，并将这些分组转发。选路处理器：执行选路协议。</p><p>网际协议：IP:是为计算机网络相互连接进行通信而设计的协议。ARP（地址解析协议），ICMP（网际控制报文协议），IGMP（网际组管理协议）</p><p>IP地址分类{网络号+主机号}</p><p><img src="/2019/09/02/网络复习/ip.png" alt="ip"></p><p>DHCP协议：即插即用协议，主机可以自动获取ip地址，还可以获取一台主机的子网掩码，默认网关以及本地NDS服务器地址。四个步骤： 1. DHCP服务器发现，2. DHCP服务器提供，3. DHCP请求， 4. DHCP ACK</p><p>NAT（网络地址转换）NAT能使路由器对外部网络隐藏了家庭网络的实现细节，NAT通过内部的NAT地址转换表，将一个外界传来的数据报转发给内部主机。</p><p>ICMP（互联网报文控制协议）应用：1.PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性。 2.TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量。</p><p>IPV6：不允许在中间路由器上进行分片和重新组装，这种操作只能在目的地上进行，如果收到的数据报过大导致不能转发，则丢弃该数据报并发送一个ICMP差错报文。</p><p>内部网关协议<br>RIP（Routing Information Protocol，路由信息协议）<br>OSPF（Open Sortest Path First，开放最短路径优先）</p><p>外部网关协议<br>BGP（Border Gateway Protocol，边界网关协议）</p><p><strong>note：2019.9.16 修改</strong></p><p>ARP协议：每个主机都有一个ARP高速缓存，其中存放局域网中ip和硬件地址的映射关系。ARP是为了解决局域网内部主机硬件地址与ip映射问题所使用的协议。其运行过程大致如下：同一个局域网内的主机A要向主机B发送ip数据报，主机A会在ARP高速缓存中查找主机B的ip地址，如果查找到主机B对应的硬件地址，则将该硬件地址封装到MAC帧中，通过局域网发送过去。如果没有找到，就通过本网络进行广播将将目的mac地址封装发送给网络内部全部主机，主机B收到消息后进行响应，将自己的mac地址和ip封装发送给主机A。主机A收到后将映射写入缓存，将MAC帧发送给主机B。</p><p>如果要同行的主机不在局域网内，则需要将分组发送给某个路由器，再由路由器将分组发送到下一个网络。</p><p>路由器和交换机： 路由器：路由器工作在网络层,他的作用是通过运输层的协议实现不同主机间的通信,包括选路算法等. 路由器连接多个不同的广域网形成更大的广域网(多个局域网连接起来),实现不同ip间的通信. 交换机工作在数据链路层,它将不同的以太网连接形成更大的以太网(以太网可以看成是一种实现局域网通信的技术标准).通过mac地址进行转发.交换机转发的是数据帧，路由器转发的是ip数据报。数据帧在ip数据报基础上封装了帧头和帧尾。交换机主要用来组建局域网,路由器则是负责让主机连接外网。多台主机通过网线连接到交换机就形成了局域网。 路由器一般具有防火墙功能：能够对一些网络数据包进行过滤。</p><p>网关:网关一般指主机间通信的第一跳路由器.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;拖了好几天，今天复习一下计算机网络中的一些知识点，感觉这门课我一直学的不太好，主要是因为实践也比较少，但是这些知识也是比较重要的，只能之后多看书多找点有关练习了。&lt;/p&gt;</summary>
    
    
    
    <category term="复习" scheme="http://yoursite.com/categories/复习/"/>
    
    
    <category term="计网" scheme="http://yoursite.com/tags/计网/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 5175. 构建回文串检测</title>
    <link href="http://yoursite.com/2019/09/01/leetcode-5175-%E6%9E%84%E5%BB%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/09/01/leetcode-5175-%E6%9E%84%E5%BB%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E6%A3%80%E6%B5%8B/</id>
    <published>2019-09-01T08:51:43.000Z</published>
    <updated>2019-09-23T04:51:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天早上有点其他事情，就没做这次题目，下午回来想着还是坐下看看，这里记录下本次周赛的第三题。前面两题都相较前几次的简单，就不介绍了，而且感觉第二题的题意不太清楚，还好是没在竞赛，看得到答案，否则我觉得ac不了第二题。直接看下题目：</p><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>题意的话我直接贴一张图片就行了：</p><p><img src="/2019/09/01/leetcode-5175-构建回文串检测/question.png" alt="question"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>大致思路是遍历整个的queries，判断其对应的子串能否通过变化变成回文串。</p><p>要求很重要*<em>我们可以 重新排列 子串 s[left], …, s[right]，并从中选择 最多 k 项替换成任何小写英文字母。 *</em>还有提示部分有说原本字符串中只有小写字母，这是一个比较重要的条件，后面会用到。</p><p>关键的一点是要判断如何使一条子串能否变成回文。因为只有小写字母，再结合回文串的性质，其中最多只有一个字符是单数，其余字符都是双数，因为可以随意变换位置，所以问题转换为求出一个子串中单个字符的个数，根据queries中的k值去比较单个字符串的个数大于（1/2）就是true，否则为false.</p><p><strong>但是</strong>，这样还是不能ac，会在倒数第二个测试超时，因为没在竞赛，所以我还可以好好思考下，重点来了，因为字符串都是小写字母，所以最多只有26中情况，最多只有26种字符都是单数，所以只要k值大于等于13就一定可以改为回文串。<br>所以加上这个条件就可以ac了。</p><p>还有一点要提，统计其中每个子串种每个字符个数，使用一个基数排序。</p><h3 id="ac代码"><a href="#ac代码" class="headerlink" title="ac代码"></a>ac代码</h3><pre><code>class Solution {public:    vector&lt;bool&gt; canMakePaliQueries(string s, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        int size=queries.size();        vector&lt;bool&gt; ret(size,false);        for(int i=0;i&lt;size;i++){            int left=queries[i][0],right=queries[i][1];            int len=right-left+1;            //string tmp=s.substr(queries[i][0],len);            int flag[26];            memset(flag,0,sizeof(flag));            if(queries[i][2]&gt;=13) {                ret[i]=true;                continue;            }            for(int k=left;k&lt;=right;k++){                flag[s[k]-&apos;a&apos;]++;            }            int help=0;            for(int m=0;m&lt;26;m++){                if(flag[m]%2==1) help++;            }            if((help/2)&lt;=queries[i][2]) ret[i]=true;            if(len%2==1 &amp;&amp; ((help-1)/2)&lt;=queries[i][2]) ret[i]=true;        }        return ret;    }};</code></pre><p>最后注意一下其中的小细节就可以了。<br>给一个ac截图</p><p><img src="/2019/09/01/leetcode-5175-构建回文串检测/ac.png" alt="ac"></p><p>可能是因为没在竞赛，没紧张感所以效率高一点吧，要是在竞赛里感觉只能ac两道。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天早上有点其他事情，就没做这次题目，下午回来想着还是坐下看看，这里记录下本次周赛的第三题。前面两题都相较前几次的简单，就不介绍了，而且感觉第二题的题意不太清楚，还好是没在竞赛，看得到答案，否则我觉得ac不了第二题。直接看下题目：&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
    <category term="coding" scheme="http://yoursite.com/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>排序算法梳理</title>
    <link href="http://yoursite.com/2019/08/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/</id>
    <published>2019-08-27T07:29:23.000Z</published>
    <updated>2019-09-23T04:52:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本着复习的理念，还是简单梳理一遍常见的排序算法，直接贴出代码，并且在代码中加以注释。</p><h3 id="排序算法对比"><a href="#排序算法对比" class="headerlink" title="排序算法对比"></a>排序算法对比</h3><p>说到排序算法，那还是就放这张图就可以了。</p><a id="more"></a><p><img src="/2019/08/27/排序算法梳理/sort.png" alt="sort"></p><p>本文实现了上述的几种算法，上面没提到的桶排序和基数排序并没有加以实现。 </p><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p><p>运行结果如下：</p><p><img src="/2019/08/27/排序算法梳理/answer.png" alt="answer"></p><pre><code>#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;/*冒泡排序 时间复杂度 O(n^2);可以修改其中的条件使其稳定或者不稳定主要思路就是通过不断比较相邻的数据大小，并进行交换。如果数据原本就是有序的，那么无需交换，但是循环次数不变*/void Bubble_sort(vector&lt;int&gt;&amp; temp){    int size = temp.size();    for (int i = 0; i &lt; size-1;i++){        for (int j =  1; j &lt; size;j++){            if(temp[j-1]&gt;temp[j])                swap(temp[j-1], temp[j]);        }    }    return;}//select sort/*选择排序 O(n^2)    选择排序的思路也比较简单，多次循环数组，每次找到当前循环的最小值，记录下标，每次找到最小值后放到（swap）前面已排好序的末尾即可。    如果数组全都排好序，那就不必交换，但是循环次数不变。*/void select_sort(vector&lt;int&gt;&amp; tmp){    int size = tmp.size();    for (int i = 0; i &lt; size-1;i++){        int minindex = i;        for (int j = i+1; j &lt; size;j++){            if(tmp[j]&lt;tmp[minindex])                minindex = j;        }        swap(tmp[minindex], tmp[i]);    }    return;}/*插入排序 O(n^2)我习惯将插入排序和选择排序做比较，当然两者的思路都比较直接，每次从当前位置向前看，比前面的元素小就交换，否则继续下一次循环，因为每次向后推进前面的 元素都是已经排好序的。因此最好情况为O(n)*/void insert_sort(vector&lt;int&gt; &amp; tmp){    int size = tmp.size();    for (int i = 0; i &lt; size - 1;i++){        for (int j = i + 1; j &gt;0;j--){            if(tmp[j-1]&gt;tmp[j])                swap(tmp[j - 1], tmp[j]);            else break;        }    }    return;}/*希尔排序：思路不够直接，主要是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序。复杂度O(n^2);最好为o(n);*/void shellsort(vector&lt;int&gt;&amp; tmp){    int size = tmp.size();    for (int gap = (size / 2); gap &gt; 0;gap=gap/2){        for (int i = gap; i &lt; size; i++)        {            int j = i;            int cur = tmp[i];            while((j-gap)&gt;=0 &amp;&amp; cur&lt;tmp[j-gap]){                tmp[j] = tmp[j - gap];                j = j - gap;            }            tmp[j] = cur;        }    }    return;}//quick_sort 复杂度O(nlogn)，如果数组原本有序，那么就会变为O(n^2)，个人认为退化为冒泡了;/*算法思想的典型使用，选取一个flag，从左右开始，小于flag就将交换left和right元素，同时left右移，大于flag也交换位置，同时right左移。当循环结束后将flag放回到left==right的位置分别对左部和右部进行相同的排序，递归出口为right-left&lt;=0*/void quick_sort(vector&lt;int&gt;&amp; tmp,int left,int right){    if(left&gt;=right)        return;    int flag = tmp[left];    int tmpl=left;    int tmpr = right;    while(tmpl&lt;tmpr){        while( tmpr&gt;tmpl &amp;&amp; tmp[tmpr]&gt;=flag)            tmpr--;        if(tmpr&gt;tmpl)             tmp[tmpl] = tmp[tmpr];        while(tmpl&lt;tmpr &amp;&amp; tmp[tmpl]&lt;flag)            tmpl++;         if(tmpr&gt;tmpl)             tmp[tmpr] = tmp[tmpl];    }    //完成一遍后把flag放回tmp    tmp[tmpl] = flag;    quick_sort(tmp, left, tmpl);    quick_sort(tmp, tmpr + 1, right);}//heap sort  makeheap popheap sortheap// O(nlogn)/*三个步骤，make_heap:将最大元素放在堆（数组）首部pop_heap：取出最大元素放到heap（数组）尾部同时缩小堆范围sort_heap:循坏执行make和pop操作，逐渐减小堆。最后得到有序数组*/void makeheap(vector&lt;int&gt;&amp;tmp,int pare,int curlen){      int cur = tmp[pare];     int child = pare * 2 + 1; //左孩子      while(child&lt;curlen){        if(child+1&lt;curlen &amp;&amp; tmp[child+1]&gt;tmp[child]){              child++;        }         if(tmp[child]&gt;tmp[pare]){              swap(tmp[child], tmp[pare]);             pare = child;            child=child*2+1;         }else break;              } //o(logn)}void popheap(vector&lt;int&gt;&amp; tmp,int index){      swap(tmp[0], tmp[index]);}void heapsort(vector&lt;int&gt; &amp; tmp){      int size = tmp.size();      int child = size / 2 - 1; //确保第一个节点有孩子      for (int i = child; i &gt;= 0;i--)            makeheap(tmp, i, size);      for (int i = size - 1; i &gt; 0; i--){          popheap(tmp,i);         makeheap(tmp, 0, i);    }}///count_sort/* 复杂度为o(n);    一边用来数组差别不大的排序中，统计字符串中字母个数时也可以用到这个方法*/void counting_sort(vector&lt;int&gt;&amp;tmp){    int min=65535,max=-65535;    int size = tmp.size();    for (int i = 0; i &lt; size;i++){        if(tmp[i]&lt;min)            min = tmp[i];        if(tmp[i]&gt;max)            max = tmp[i];    }    int flag[max - min + 1];    memset(flag, 0, sizeof(flag));    for (int i = 0; i &lt; size;i++){        flag[tmp[i] - min]++;    }    int index = 0;    for (int i = 0; i &lt; max - min + 1;i++)        while(flag[i]&gt;0){            tmp[index++] = i + min;            flag[i]--;        }}/*归并排序：将数组分为各个部分排好序后再合并复杂度为O(nlogn)*/void merge(vector&lt;int&gt;&amp;tmp,int lefthelp,int mid,int right){    int left = lefthelp;    vector&lt;int&gt; help(right - left+1,0); //注意此处需要保证左右的空间，因此尽量让right指向back而不是end    int k = 0;    int index = mid + 1;    while(left&lt;=mid &amp;&amp;index&lt;=right){        if(tmp[left]&gt;tmp[index]){            help[k++] = tmp[index];            index++;        }else{            help[k++] = tmp[left];            left++;        }    }    //出现多余一个的情况    while(left&lt;=mid)        help[k++] = tmp[left++];    while(index&lt;=right)         help[k++] = tmp[index++];    for (int i = 0; i &lt;= (right - lefthelp);i++)        tmp[i + lefthelp] = help[i];}void merge_sort(vector&lt;int&gt;&amp;tmp,int left,int right){    if(left&lt;right){        int mid = (left + right) / 2;        merge_sort(tmp, left, mid);        merge_sort(tmp, mid + 1, right);        merge(tmp,left,mid,right);    }}void print(const vector&lt;int&gt; tmp){    for (int i = 0; i &lt; tmp.size();i++)        cout &lt;&lt; tmp[i] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;}int main(){    vector&lt;int&gt; test = {3,1, 40, 5, 18, 25, 33, 17, 17, 20,55};    //1.bubblesort    vector&lt;int&gt; tmp = test;    cout &lt;&lt; &quot;Bubble_sort&quot; &lt;&lt; endl;    Bubble_sort(tmp);    print(tmp);   // for (int i = 0; i &lt; tmp.capacity();i++)//     cout &lt;&lt; &amp;tmp[i] &lt;&lt; &quot; &quot;;//     //2.selectsort//  cout &lt;&lt; endl;    tmp = test;//  for (int i = 0; i &lt; tmp.capacity(); i++)//     cout &lt;&lt; &amp;tmp[i] &lt;&lt; &quot; &quot;;//  print(tmp);    cout &lt;&lt; &quot;select_sort&quot; &lt;&lt; endl;    select_sort(tmp);    print(tmp);    //3.insert_sort    cout &lt;&lt; &quot;insert_sort&quot; &lt;&lt; endl;    tmp = test;    insert_sort(tmp);    print(tmp);    //4.shell sort    tmp = test;    cout &lt;&lt; &quot;shell_sort&quot; &lt;&lt; endl;    shellsort(tmp);    print(tmp);    //5.merge_sort    tmp = test;    cout &lt;&lt; &quot;merge_sort&quot; &lt;&lt; endl;    merge_sort(tmp, 0, tmp.size()-1);    print(tmp);    //6.quick sort    tmp = test;    cout &lt;&lt; &quot;quick_sort&quot; &lt;&lt; endl;    quick_sort(tmp, 0, tmp.size() - 1);    print(tmp);    //7.heap_sort    tmp = test;    cout &lt;&lt; &quot;heap_sort&quot; &lt;&lt; endl;    heap_sort(tmp, tmp.size() - 1);    print(tmp);    //count_sort    tmp = test;    cout &lt;&lt; &quot;counting_sort&quot; &lt;&lt; endl;    counting_sort(tmp);    print(tmp);    return 0;};  </code></pre><p><strong>note</strong> 8.28补充</p><p>我突然想到一个关于=的问题，上述的vector赋值我都是使用=进行赋值的，那么=对于很多类来说都是一个浅拷贝，当然如果vector自身已经重写了拷贝构造函数的话那就是一个深拷贝了。</p><p>想到问题后，我找了一些资料，没有找到相应的源码，但是找到一篇关于这部分知识的博文，感觉还行。<a href="https://blog.csdn.net/vict_wang/article/details/88812389" target="_blank" rel="noopener">https://blog.csdn.net/vict_wang/article/details/88812389</a>，这来看，在vector中使用a=b,a(b)也都是深拷贝了，当然还有上述博客中的assign 和swap也是深拷贝模式，我也实践了一下，在源码中打印他们的地址，发现最后证明确实是深拷贝。所以上述的排序源码应该没问题吧。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本着复习的理念，还是简单梳理一遍常见的排序算法，直接贴出代码，并且在代码中加以注释。&lt;/p&gt;
&lt;h3 id=&quot;排序算法对比&quot;&gt;&lt;a href=&quot;#排序算法对比&quot; class=&quot;headerlink&quot; title=&quot;排序算法对比&quot;&gt;&lt;/a&gt;排序算法对比&lt;/h3&gt;&lt;p&gt;说到排序算法，那还是就放这张图就可以了。&lt;/p&gt;</summary>
    
    
    
    <category term="复习" scheme="http://yoursite.com/categories/复习/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
