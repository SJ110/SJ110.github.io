<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaopingpp</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-03-27T12:49:36.298Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xiaopingpp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写在换工作之前</title>
    <link href="http://yoursite.com/2022/03/27/%E5%86%99%E5%9C%A8%E6%8D%A2%E5%B7%A5%E4%BD%9C%E4%B9%8B%E5%89%8D/"/>
    <id>http://yoursite.com/2022/03/27/%E5%86%99%E5%9C%A8%E6%8D%A2%E5%B7%A5%E4%BD%9C%E4%B9%8B%E5%89%8D/</id>
    <published>2022-03-27T12:09:25.000Z</published>
    <updated>2022-03-27T12:49:36.298Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;在即将离开南京之际,本以为会有很多的感想,可是到目前来看,似乎还是没什么值得纪念的.真要说的话,也就是在南京这一年大半算是对coding这份工作入门了吧.其他好像都在原地踏步.甚至有些倒退了.本打算以日记的方式记录下最近,但是转念一想:正经人谁写日记啊.所以下面的这些废话只能算是我的一些乱七八糟的吐槽.希望后面再来看到时还记得当时的自己那种心情.</p><a id="more"></a><ul><li><p>关于找工作</p><p>其实本次找工作某些环节没有按照计划进行了.大体看来还是自己第一次换工作,第一次去和别人argue工资和其他一些东西.还是有些太过天真了.高兴我还能保留一些天真的属性在当前我这个一团糟的自己中.郁闷的是工资还是没有达到自己的心理预期.不过既然决定去了,那就要做好接下来的事情.薪水在接下来的自己的良好表现中会不断提升.</p><p>其次,从iOS转到web前端应该会是个不错的选择吧.要说自己完全不会前端,但是还是断续做了一些.要说会,让我单独来写一个项目还是难以开始.从我个人的角度来看,目前成都这边的话应该是前端的前景会好一些的.iOS这个技术还是有些难以生存了.马后炮一句,如果当时被头条成都录取了,估计我就不是现在的想法了,不过没关系,我在gap一两年在去试试.看能不能进所谓的一些个大厂,不过不知道到时候我还会不会如此热衷于找一个大厂这件事了.</p><p>心理上感觉接下来的老大人还不错,但是这边的技术氛围感觉会和现在差不多,甚至会差一些.不过一切以实际为准.接下来就不能像现在这样借着自己身份去做一些张扬的事了,我的打算是在自己的本职工作上高调去做,其他一些事情低调去处理.也许有时候不得不在领导面前表现下自己了.但是我绝对不会做违背自己基本原则的事情.前面两个月多虚心请教下.之后一切必须要靠自己了,做事必须要开始有自己的思考.感觉还是说的好多,不过对于不是我自己的人看到应该会一脸懵逼.</p></li><li><p>关于今年</p><p> 打算今年要做好多事的,首先脸部痘印去处理下,然后尝试找一个培训机构开始学习日语.去吃成都好多好多好吃的.跑步和健身不能停下来(虽然最近也停下来了).了解一下近视手术相关的东西,考虑是否要做.要去逛一下周围了.我得学会改变下当前的性格了.我始终相信那句话:“人长大后总会变成自己讨厌的模样.”,对于我自己来说,我要尽量延缓自己长大,尽量让自己慢的变成自己讨厌的样子.</p><p> 我还要在家里的冰箱放好多好多的饮料,买一个switch来玩,对了还要买下在京东购物车里的几个玩具,还要学习一些python的简单用法.要考虑下拍一些周末日常的琐碎传到b站上.还有,找机会去玩玩钓鱼,还要尝试找个川妹子来的.我要做好多好多事,所以今年要加油呀,皮酱~</p></li><li><p>关于最近</p><p>最近可以说是有点水逆了,感觉自从过完年从家里回来自己就没有彻底静下心来过.对一些事物的看法也在不知不觉中发生了改变.我把这些事一大部分原因归结为自己的运气不够好.好吧,虽然这有些玄学,但是这也正好是我自己面对这狗屎一般生活的一种方式.我始终相信,每个人的运气都是相同的,这个运气包括了财富,幸福,倒霉等各种部分,那既然我现在运气不咋地,那就意味着我之后将好运当道.</p><p>郁闷的是今年居然把身份证给搞丢了,希望明天能找到,不然只能去补办了.然后房子转租啊,坐飞机去成都啊,各种乱七八糟的事,希望到了四月不要让自己在陷入类似的麻烦中了吧.</p><p>之后的博客应该也会是以js和前端为主了,那iOS相关的东西就暂时告一段落吧.我得变得更强.</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;在即将离开南京之际,本以为会有很多的感想,可是到目前来看,似乎还是没什么值得纪念的.真要说的话,也就是在南京这一年大半算是对coding这份工作入门了吧.其他好像都在原地踏步.甚至有些倒退了.本打算以日记的方式记录下最近,但是转念一想:正经人谁写日记啊.所以下面的这些废话只能算是我的一些乱七八糟的吐槽.希望后面再来看到时还记得当时的自己那种心情.&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/其他/"/>
    
    
    <category term="感悟" scheme="http://yoursite.com/tags/感悟/"/>
    
  </entry>
  
  <entry>
    <title> 如何用OC如何写一个单例</title>
    <link href="http://yoursite.com/2022/01/07/%E5%A6%82%E4%BD%95%E7%94%A8OC%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B/"/>
    <id>http://yoursite.com/2022/01/07/%E5%A6%82%E4%BD%95%E7%94%A8OC%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B/</id>
    <published>2022-01-07T07:09:58.000Z</published>
    <updated>2022-02-21T01:59:39.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;最近看了一些<strong>copyWithZone:</strong>这个方法相关的一些东西.没想到从这里可以延伸出来很多内容,包括深拷贝,浅拷贝,copy,mutableCopy,NSCopying协议,NSMutableCoping协议,单例等等东西.他们之间要么相互关联,要么环环相扣.也许拿出其中一点来可以说的比较清晰,但是全部合在一起又很乱了.因此写一篇文章来梳理一下这些知识脉络.</p><a id="more"></a><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>&ensp;&ensp;首先从单例开始说起,因为单例里面涉及到上面比较多的东西.<br>&ensp;&ensp;单例指的是在app生命周期内只会存在一个实例的对象.无论实例化多少次,都只会在内存中存在一个地址.现在看一个简单的单例模式.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">///.h</span><br><span class="line">@interface SJPSingletonManager:NSObject</span><br><span class="line">+ (instancetype)shareManager;</span><br><span class="line">@end</span><br><span class="line">///.m</span><br><span class="line">@implementation SJPSingletonManager</span><br><span class="line"></span><br><span class="line">+(instancetype)shareManager &#123;</span><br><span class="line">    static SJPSingletonManager *manager = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        manager = [[SJPSingletonManager alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">.....</span><br><span class="line">///testCode</span><br><span class="line">    SJPSingletonManager *manager1 = [SJPSingletonManager shareManager];</span><br><span class="line">    SJPSingletonManager *manager2 = [SJPSingletonManager shareManager];</span><br><span class="line">/// consle outprint</span><br><span class="line">2022-01-07 15:29:50.053345+0800 multi-thread-demo[87156:1046260] singleton:0x600002830000--0x600002830000</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;通过dispatch_once_t这种方式让初始化代码只执行一次.因此做到了多次实例化只得到一份内存的效果,但是这么写的缺点在于如果调用的人不使用暴露出来的shareManager方法,而是通过init或者new的方式进行初始化的话,得到的对象就不在是一个单例,因此需要把这两个入口也堵住.另外还了解到,无论是通过init的方式,还是通过new的方式创建对象,最终都会调用到<strong>allocWithZone:</strong>这个方法(经过验证确实是这样子的),因此我们可以少写一些代码,直接堵住<strong>allocWithZone:</strong>这个初始化方法.因此修改后的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)shareManager &#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    static SJPSingletonManager *_manager = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        if (!_manager) &#123;</span><br><span class="line">            _manager = [super allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return _manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;shareManager内部不在执行dispatch方法,而是放到<strong>allocWithZone:</strong>中执行.个人认为到这一步的话已经可以算是完整的单例了,但是还是有一些场景需要考虑下.</p><ul><li>如果调用方使用copy来对单例进行复制.</li><li>如果调用方方使用mutableCopy来对单例进行复制.<br>&ensp;&ensp;copy和mutableCopy都是定义在NSCopying和NSMutableCopying协议中的方法,如果不继承这两个协议直接调用copy方法的话,会直接调用<strong>copyWithZone:</strong>这个方法从而造成crash.crash信息如下:</li><li>Thread 1: “-[SJPSingletonManager copyWithZone:]: unrecognized selector sent to instance 0x600001328980”</li></ul><p>&ensp;&ensp;此处我发现了一个华点,如果不继承NSCopying协议,直接实现copyWithZone:这个方法,在实例对象调用copy方法时也不会crash,因此推测NSObject内部的实现代码大致是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">///没有前面的if条件判断</span><br><span class="line">[self performSelector:@selector(copyWithZone:)];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;增加了<strong>copyWithZone:</strong>和<strong>mutableCopyWithZone:</strong>方法后,整体的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@implementation SJPSingletonManager</span><br><span class="line"></span><br><span class="line">+(instancetype)shareManager &#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    static SJPSingletonManager *_manager = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        if (!_manager) &#123;</span><br><span class="line">            _manager = [super allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return _manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull id)copyWithZone:(nullable NSZone *)zone &#123;</span><br><span class="line">    return [SJPSingletonManager allocWithZone:zone];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (nonnull id)mutableCopyWithZone:(nullable NSZone *)zone &#123;</span><br><span class="line">    return [SJPSingletonManager allocWithZone:zone];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;到这一步应该已经算是一个完整的单例了.涵盖了可能想到的所有场景.</p><h3 id="copy-mutableCopy"><a href="#copy-mutableCopy" class="headerlink" title="copy,mutableCopy"></a>copy,mutableCopy</h3><p>&ensp;&ensp;oc提供的集合对象:array,dictionary,string等内部都是实现了&lt;NSCopying,NSMutableCopying&gt;两个协议的,有一点需要明确,以上这些类型通过调用mutableCopy方法得到的一定是可变对象,通过copy方法调用得到的一定是immutable对象.考虑如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">///.h</span><br><span class="line">@interface classA : NSObject&lt;NSCopying,NSMutableCopying&gt;</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *array;</span><br><span class="line">@property (nonatomic, copy) NSString *str;</span><br><span class="line">@property (nonatomic, copy) NSArray *iArray;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">///.m</span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _iArray = @[@&quot;111&quot;,@&quot;222&quot;];</span><br><span class="line">        _str = @&quot;ssss&quot;;</span><br><span class="line">        _array = @[@&quot;3333&quot;].mutableCopy;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull id)copyWithZone:(nullable NSZone *)zone &#123;</span><br><span class="line">    classA *A = [[classA alloc] init];</span><br><span class="line">    A.iArray = self.iArray.copy;</span><br><span class="line">    A.str = self.str.copy;</span><br><span class="line">    A.array = self.array.copy;</span><br><span class="line">    NSLog(@&quot;copy--%p,%p,---array:%p,%p&quot;,self.str,A.str,self.array,A.array);</span><br><span class="line">    return A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull id)mutableCopyWithZone:(nullable NSZone *)zone &#123;</span><br><span class="line">    classA *A = [[classA alloc] init];</span><br><span class="line">    A.iArray = self.iArray.mutableCopy;</span><br><span class="line">    A.str = self.str.mutableCopy;</span><br><span class="line">    A.array = self.array.copy;</span><br><span class="line">    return A;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">    classA *A = [classA new];</span><br><span class="line">    classA *Aa = [A copy];</span><br><span class="line">    classA *Aaa = [A mutableCopy];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;通过上面的方式定义了copyWithZone和mutableCopyWithZone方法之后,我们可以对自定义的对象进行拷贝.得到的地址不同的对象.增加这个方法之后就可以对自定义的对象使用copy和mutableCopy方法.</p><h3 id="深拷贝-浅拷贝"><a href="#深拷贝-浅拷贝" class="headerlink" title="深拷贝,浅拷贝"></a>深拷贝,浅拷贝</h3><p>&ensp;&ensp;前面说过,执行copy后得到的是不可变对象,执行mutableCopy方法之后得到的时候可变对象.这在深拷贝和浅拷贝上表现出来是这样的.上面代码运行后,可以得到log输出<br>  2022-01-07 17:50:05.046960+0800 multi-thread-demo[90687:1165918] copy–0x10260c5b8,0x10260c5b8,—array:0x6000008670f0,0x6000004fab00,</p><p>&ensp;&ensp;分析:</p><ul><li>str是一个不可变的string对象,使用copy是浅拷贝,因此得到的是一份地址的拷贝且内容相同.以前曾经疑问一个点,虽然地址相同,但是对其中一个重新赋值之后为什么地址又不同呢,指向的内容也不同了呢,现在才发现,不可变对象本身是不可修改的,重新赋值只会重新申请一块内存存储新的对象.</li><li>array是一个可变对象,使用copy之后获得一个不可变对象,不过也会生成新的数据地址.同时,使用mutableCopy是深拷贝,这里有一个点,一般开发过程中建议把对象声明为不可变的,如果在运行过程中一定需要修改对象内的元素的话,可以通过如下方式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_iArray = @[@&quot;111&quot;,@&quot;222&quot;];</span><br><span class="line">NSMutableArray *mArray = [_iArray mutableCopy];</span><br><span class="line">[mArray setValue:@&quot;222&quot; forKey:@&quot;1111&quot;];</span><br><span class="line">_iArray = mArray.copy;</span><br><span class="line">/// 通过借助第三个变量来对不可变的变量进行修改.</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;最近看了一些&lt;strong&gt;copyWithZone:&lt;/strong&gt;这个方法相关的一些东西.没想到从这里可以延伸出来很多内容,包括深拷贝,浅拷贝,copy,mutableCopy,NSCopying协议,NSMutableCoping协议,单例等等东西.他们之间要么相互关联,要么环环相扣.也许拿出其中一点来可以说的比较清晰,但是全部合在一起又很乱了.因此写一篇文章来梳理一下这些知识脉络.&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础语法</title>
    <link href="http://yoursite.com/2021/12/06/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2021/12/06/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2021-12-06T02:29:17.000Z</published>
    <updated>2021-12-29T12:54:22.248Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;最近开始看下<a href="https://weread.qq.com/web/reader/7a232e307199a64a7a29ea8k9bf32f301f9bf31c7ff0a60" target="_blank" rel="noopener">《Swift4从零到精通iOS开发》</a>,学习下Swift的语法.也相当于做一个简单的读书笔记.</p><p>&ensp;&ensp;虽然在毕业前也做过一丢丢的Swift语法学习,但是那个时候还没有接触到任何的iOS开发,当时学起来也是晦涩难懂,所以之前的学习就当作空白归零,现在重新开始新的Swift语法学习.</p><a id="more"></a><h3 id="量值与基本数据类型"><a href="#量值与基本数据类型" class="headerlink" title="量值与基本数据类型"></a>量值与基本数据类型</h3><h4 id="特殊的基本数据类型"><a href="#特殊的基本数据类型" class="headerlink" title="特殊的基本数据类型"></a>特殊的基本数据类型</h4><ul><li>元组<br>&ensp;&ensp; 元组是Swift中特有的数据类型,允许一些不相关的数据类型进行自由组合成为新的集合类型.如下定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// note Swift中对于string类型前面不需要加@</span><br><span class="line">    var pen:(name:String,price:Int) = (&quot;钢笔&quot;,2)</span><br><span class="line">/// 进行元组定义后,可以使用通过参数名称来取得各个参数</span><br><span class="line">    var name = pen.name; //钢笔</span><br><span class="line">    var price = pen.price; //2</span><br></pre></td></tr></table></figure></li></ul><p>&ensp;&ensp;在创建元组时,可以不指定元组中的参数名称,此时元组会自动为每个参数分配下标,从0开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var newpen:(String,Int) = (&quot;钢笔&quot;,2)</span><br><span class="line">var newpenName = newpen.0; //钢笔</span><br><span class="line">var newpenPrice = newpen.1; // 2</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;元组分解,元组创建后,可以通过制定变量为分解.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var newpen:(String,Int) = (&quot;钢笔&quot;,2)</span><br><span class="line">///分解元组,分组成员分解为两个变量</span><br><span class="line">var (newpenName,newpenPrice) = newpen</span><br><span class="line">print(newpenName,newpenPrice)</span><br><span class="line">/// 匿名分解</span><br><span class="line">var (newpenName2,_) = newpen;</span><br><span class="line">print(newpenName2);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;在上面代码中,使用<strong>_</strong>来表示匿名的概念,因此只分解了第一个参数</p><ul><li>可选值类型<br>&ensp;&ensp;optional类型是Swift特有的一种类型,在实现Swift类型安全上,使用Optional对普通类型进行包装,实现对空值的监控.在Swift中,如下代码会在编译时报错,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Variable &apos;obj&apos; used before being initialized</span><br><span class="line">    var obj:String</span><br><span class="line">    if obj == nil &#123;</span><br><span class="line">        obj = &quot;111&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>&ensp;&ensp;在Swift中如果需要基本类型为nil的话,应该将其包装为Optional类型.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj:String?</span><br><span class="line">/// 在普通数据类型后加?包装为Optional类型.</span><br><span class="line">/// Optional类型不会独立存在,总是附着在某个具体的数据类型上.具体数据类型可以是基本数据类型/结构体/类等.</span><br><span class="line">/// Optional只有两种值 1、如果附着类型的对应变量有值,那么其为具体值的包装 2、如果没有具体值,那么为nil</span><br><span class="line">if obj == nil &#123;</span><br><span class="line">    obj = &quot;111&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;Optional是对普通类型的一种包装,在使用时也需要拆包操作.拆包使用操作符”!”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj:String?</span><br><span class="line">if obj != nil &#123;</span><br><span class="line">    obj!;</span><br><span class="line">&#125;</span><br><span class="line">/// 一般开发中,更常用的拆包操作</span><br><span class="line">    var obj:String? </span><br><span class="line">/// if let 结构将创建一个临时变量接受拆包后的数据    </span><br><span class="line">    if let tmp = obj &#123;</span><br><span class="line">        print(tmp)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        obj = &quot;111&quot;;</span><br><span class="line">        print(obj!)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="字符-字符串和集合类型"><a href="#字符-字符串和集合类型" class="headerlink" title="字符,字符串和集合类型"></a>字符,字符串和集合类型</h3><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>&ensp;&ensp;在Swift中,String类型是一个结构体,结构体中定义了属性和方法.String中提供了很多的重载构造方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        var str:String = &quot;123&quot;; //使用字符串初始化</span><br><span class="line">        str = &quot;&quot;; // 使用空字符串</span><br><span class="line">        str = String(); // &quot;&quot;</span><br><span class="line">        str = String(&quot;123&quot;); // &quot;123&quot;</span><br><span class="line">        str = String(123);  /// 数字转字符串&quot;123&quot;</span><br><span class="line">        str = String(&quot;a&quot;); /// 字符转字符串&quot;a&quot;</span><br><span class="line">        str = String(describing: (1,1,true)); /// 元组转字符串 &quot;(1,1,true)&quot;</span><br><span class="line">        str = String(false);</span><br><span class="line">        str = String(format: &quot;12%@&quot;,&quot;3&quot;); /// 格式化字符串 &quot;123&quot;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### 字符串组合</span><br><span class="line">&amp;ensp;&amp;ensp;Swift中重载了+号运算符,可以将两个字符串连接起来.</span><br></pre></td></tr></table></figure><pre><code>var str1 = &quot;hello&quot;;var str2 = &quot;world&quot;;/// 注意重载运算符+两边不能有空格str1 = str1+&quot; &quot;+str2;print(str1);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;可以使用插值的方式对字符串进行组合拼接.这种方式**在开发中经常使用**</span><br></pre></td></tr></table></figure><pre><code>var str3 = &quot;hello\(123)&quot;var str4 = &quot;hello \(str2)&quot;print(str3,str4); // hello123 , hello world</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 字符串类型中的常用方法</span><br><span class="line">&amp;ensp;&amp;ensp;Swift中可以使用 &gt;/&lt;/==比较两个字符串,其比较方式是对每一个字符依次比较其对应AscII码大小.</span><br></pre></td></tr></table></figure><pre><code>var sstr = &quot;hello-swift&quot;var startIndex = sstr.startIndex; ///起始索引,不是一个integervar endIndex = sstr.endIndex; /// 结束索引,不是一个integer,注意,此处返回结束位置的下一个位置var lenth = sstr.count; /// 字符串长度 11var char = sstr[sstr.index(after: startIndex)]; /// 第二个字符 evar char2 = sstr[sstr.index(before: endIndex)]; /// 最后一个字符 tprint(char,char2); ///e tvar range = sstr.range(of: &quot;hello&quot;) ///子串所在的位置sstr.append(&quot;!&quot;) /// hello-Swift!print(sstr)sstr.insert(&quot;1&quot;, at: sstr.endIndex) /// hello-Swift!1print(sstr)sstr.insert(contentsOf: [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], at: sstr.endIndex) /// hello-Swift!1111sstr.remove(at: sstr.index(before: sstr.endIndex)) /// hello-Swift!111print(sstr)sstr.hasPrefix(&quot;hell&quot;)  ///是否有前缀 yessstr.hasSuffix(&quot;222&quot;)  ///是否有后缀  nosstr.uppercased()  ///转大写sstr.lowercased()  ///转小写</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#### 集合类型</span><br><span class="line"> - Array类型 </span><br><span class="line">&amp;ensp;&amp;ensp;申明</span><br></pre></td></tr></table></figure><p>///申明空数组<br>        var arr1:[Int] = []<br>        var arr2:Array<int> = Array()<br>        arr1 = [1,2,3];  // [1,2,3]<br>        arr2 = Array(arrayLiteral: 1,2,3) [1,2,3]</int></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;数组相加 Swift中对数组的+运算符也进行了重载,但是要保证相加的数组元素类型相同</span><br></pre></td></tr></table></figure><pre><code>var arr3 = [1,2,3]+[4,5,6] //[1,2,3,4,5,6]</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;数组中的常用方法</span><br></pre></td></tr></table></figure><pre><code>arr3.count; /// 个数arr3.isEmpty /// 是否空arr3.first; /// 第一个元素arr3.last; ///最后一个元素arr3.append(7); ///[1,2,3,4,5,6,7]arr3.removeLast() /// [1,2,3,4,5,6]arr3.removeLast(2) /// [1,2,3,4]arr3.max() /// 最大值arr3.min() /// 最小值</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> - Set集合</span><br><span class="line">&amp;ensp;&amp;ensp; set和C++中的set比较类型,对比即可,Swift中的set可以进行集合的运算.</span><br></pre></td></tr></table></figure><pre><code>var set1:Set&lt;Int&gt; = [1,2,3,4]var set2:Set&lt;Int&gt; = [3,4,5,6] var setInter = set1.intersection(set2)  //[4, 3] 交集var setEx = set1.symmetricDifference(set2) // [6, 5, 1, 2] 交集的补集var setUni = set1.union(set2) /// 并集 [4, 5, 6, 1, 3, 2]var setSub = set1.subtracting(set2) /// 差集 [1,2]print(setInter,setEx, setUni,setSub)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Swift两种特殊运算符</span><br><span class="line"> - 空合并运算符 空合并运算符是针对Optional类型设计的运算符,比如如下判断代码</span><br></pre></td></tr></table></figure><pre><code>    var q:Int? = 8    var value:Int    if q != nil {        /// 不为空,拆包        value = q!    } else {        /// 为空,赋值0        value = 0    }/// 使用空合并运算符var q:Int? = 8var value:Intvalue = q ?? 0  /// 8</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;空合并运算符会自行判断是否为空,并自行拆包.**注意:??两边需要有空格**</span><br><span class="line"></span><br><span class="line"> - 区间运算符 在Swift中使用了区间运算符来快捷的表示范围.实例代码如下</span><br></pre></td></tr></table></figure><pre><code>var srange = 0...10var srange2 = 0..&lt;10</code></pre><p>//        var range3 = 0&lt;..10 ///报错,没有左开区间<br>        print(srange,srange2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 分支选择结构</span><br><span class="line"> - Swift中的swicth结构有一定的优化,其中不需要加break在执行分支后进行跳出,case条件的匹配不仅仅局限于Int类型.可以进行任意类型的匹配.</span><br></pre></td></tr></table></figure><pre><code>var ssstr:String = &quot;111&quot;switch ssstr {case &quot;111&quot;:    print(sstr) ///自动breakcase &quot;333&quot;:    print(&quot;333&quot;)default:    print(&quot;222&quot;)}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- fallthrough:fallthrough可以使switch语句继续向下执行,不直接跳出</span><br></pre></td></tr></table></figure><pre><code>var ssstr:String = &quot;111&quot;switch ssstr {case &quot;111&quot;:    print(sstr) ///自动break    fallthroughcase &quot;333&quot;:    print(&quot;333&quot;)    fallthroughdefault:    print(&quot;222&quot;) /// log 111 333 222}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- guard else 守护语句:作用是只在某个条件成立时才执行相应代码,类似if的效果</span><br></pre></td></tr></table></figure><pre><code>func foo(params:Int) {    if params&gt;0 {        print(params)    } else {        return    }}</code></pre><p>   /// guard<br>    func foo2(params:Int) {<br>        /// params &lt;= 0 直接返回<br>        guard params&gt;0 else {<br>            return<br>        }<br>        print(params)<br>    }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">### 函数</span><br><span class="line"></span><br><span class="line">#### 函数的基本使用</span><br><span class="line">&amp;ensp;&amp;ensp; Swift中的函数定义需要在最前面增加一个**func**,不过在xcode的语法提示下,申明一个函数变得比较简单,下面是两个特殊点</span><br><span class="line"> - 不定数量函数参数:可以使用...实现不定参数个数的函数.需要注意不定参数的参数类型需要保持一致.</span><br></pre></td></tr></table></figure><pre><code>/// params1不定参数,但是类型一致func foo3(params1:Int ...,params2:String) -&gt; Int {    var sum:Int = 0;    for cout in params1 {        sum += cout    }    print(&quot;foo3&quot;,sum)    return sum}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- Swift中如果是值传递,不能修改参数在函数内部的值.在Swift中类是引用类型,基本数据类型(枚举,结构体,float...)是值类型,如果需要修改值类型的参数,需要添加**inout**关键字,同时引用传递参数</span><br></pre></td></tr></table></figure><pre><code>func foo4(params:Int) -&gt; Int {    params = params+1;  ///不能修改params    return params}/// 正确func foo4(params:inout Int) -&gt; Int {    params = params+1;    return params}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 闭包</span><br><span class="line"> - 闭包可以和OC中的block进行类比,但是Swift中的闭包语法可以进行一定的简化.</span><br></pre></td></tr></table></figure><pre><code>func foo4(params:Int) -&gt; Int {    return params*params}let myClosure = {(params:Int)-&gt;Int in    return params*params}foo4(3) /// 9myClosure(3) /// 9/// 1、闭包返回值类型可以通过定义自动推断let myClosure2 = {(params:Int) in    return params*params}myClosure2(3) /// 9</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 闭包作为函数参数</span><br></pre></td></tr></table></figure><p>/// sortClosure 作为参数传递,进行数组排序<br>    func mySort(array:inout Array<any>, sortClosure:(Int,Int)-&gt;Bool) -&gt; Array<any> {<br>        for indexI in array.indices {<br>            if indexI == array.count-1 {<br>                break<br>            }<br>            for indexJ in 0 … ((array.count - 1) - indexI - 1) {<br>                if sortClosure(array[indexJ] as! Int, array[indexJ+1] as! Int) {</any></any></p><pre><code>            } else {                array.swapAt(indexJ, indexJ+1)            }        }    }    return array}/// 调用mySort(array: &amp;tmpArray, sortClosure: {(index:Int,index2:Int) -&gt; Bool in    return (arrays[index] as!Int) &lt;= (arrays[index2] as!Int)</code></pre><p>   })</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 闭包的写法优化</span><br></pre></td></tr></table></figure><p>///省略返回类型,编译器自动通过闭包返回类型推断<br>    mySort(array: &amp;tmpArray, sortClosure: {(index:Int,index2:Int) in<br>        return (arrays[index] as!Int) &lt;= (arrays[index2] as!Int)<br>    })<br>/// 如果闭包只有一行代码,同时闭包作为函数的参数,闭包的return关键字可以省略<br>    mySort(array: &amp;tmpArray, sortClosure: {(index:Int,index2:Int) in<br>        (arrays[index] as!Int) &lt;= (arrays[index2] as!Int)<br>    })<br>/// 当闭包围坐函数的参数时,闭包的参数列表会自动创建一组参数,参数名以$0,$1这样的结构类推,因此<br>    mySort(array: &amp;tmpArray, sortClosure: {<br>        (arrays[$0] as! Int) &lt;= (arrays[$1] as!Int)<br>    })</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 后置闭包</span><br><span class="line">&amp;ensp;&amp;ensp;当函数中的最后一个参数位闭包参数时,可以在调用函数时,将闭包结构脱离函数参数列表,追加在函数尾部.</span><br></pre></td></tr></table></figure><pre><code>///后置闭包写法mySort(array: &amp;tmpArray) {    (arrays[$0] as! Int) &lt;= (arrays[$1] as!Int)}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;当函数之后一个参数,并且参数时比好类型时,可以用后置闭包的写法省略函数的参数</span><br></pre></td></tr></table></figure><p>/// 定义<br>    func foo5(myClosure:(Int,Int)-&gt;Bool){</p><pre><code>}</code></pre><p>/// 调用<br>    foo5 {<br>        $0&lt;=$1<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 逃逸闭包和非逃逸闭包</span><br><span class="line">&amp;ensp;&amp;ensp;逃逸闭包指函数内的闭包在函数执行结束后在函数外依然可以执行.非逃逸闭包纸当函数的生命周期结束后,闭包也将被销毁.非逃逸闭包也不可以作为返回值返回.逃逸闭包一般用在异步操作中,比如接口调用之后对于返回结果的回调.</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;闭包类型是Swift中比较特殊的语法,需要多加练习.</span><br><span class="line"></span><br><span class="line">### 运算符重载和枚举</span><br><span class="line"></span><br><span class="line">#### 运算符重载</span><br><span class="line"> - 函数重载,是指参数列表不同,返回值不同的同名函数,OC中没有函数的重载,Swift中可以进行函数的重载</span><br></pre></td></tr></table></figure><pre><code>func adds(params1:Int,params2:Int)-&gt;Int {}func adds(params1:String,params2:Int)-&gt;String {}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 运算符重载,Swift从2.x版本后剔除了++运算符,但是通过重载运算符可以自定义相关的方法.</span><br></pre></td></tr></table></figure><p>/// 前缀++<br>prefix operator ++<br>prefix func ++(params:Int) -&gt; Int {<br>    var ret = params<br>    ret = ret+1<br>    return ret<br>}<br>/// 中缀运算符重载<br>infix operator ++<br>func ++(params:Int,params2:Int) -&gt; Int  {<br>    return (params * params2)<br>}<br>/// 后缀运算符重载<br>postfix operator ++<br>postfix func ++(params:Int) -&gt; Int {<br>    return params+1<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 枚举的创建和应用</span><br><span class="line">&amp;ensp;&amp;ensp;Swift中枚举的创建支持声明一个原始类型,如果定义为int类型时,如果设置第一个为1,后面的枚举都会自增1.</span><br></pre></td></tr></table></figure><p>/// 声明字符枚举<br>enum charEnum:Character {<br>case a = “a”<br>case b = “b”<br>case c = “c”<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;Swift中枚举较为灵活,可以通过自定义枚举实现匹配</span><br></pre></td></tr></table></figure><p>enum shape {<br>    case circle(center:(Double,Double),radius:(Double))<br>    case rectangle(center:(Double,Double),width:(Double),height:(Double))<br>    case triangle(point1:(Double,Double),point2:(Double,Double),point3:(Double,Double))<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">然后使用switch语句时根据样式进行匹配.</span><br><span class="line"></span><br><span class="line">### 类和结构体</span><br><span class="line">#### 类和结构体的区别</span><br><span class="line"> - 类中需要定一个初始化方法,进行内部成员的初始化,结构体不需要,结构体会自动生成一个初始化方法在内部</span><br><span class="line"> - 结构是值类型,进行赋值是会进行一份内存的拷贝,修改其中一个,另一个不会影响.类是引用类型,赋值后两份指向同一份内存.</span><br><span class="line"> - 类可以继承,结构体不能继承.</span><br><span class="line"> - Swift中结构体内部可以定义方法.</span><br><span class="line"></span><br><span class="line">#### 类的继承</span><br><span class="line"> - Swift中类可以被继承,实现子类自身所需要的特点.</span><br><span class="line"> - override关键字表示子类中重写父类中的方法.在重写的方法中可以通过super关键字调用父类的实现,然后继续子类的逻辑.</span><br><span class="line"> - final关键字可以修改类的方法,属性,类本身.被修饰后,不可以被子类继承或重写.</span><br><span class="line"></span><br><span class="line">#### 使用场景</span><br><span class="line"> - 结构体:如果成员比较简单,不需要继承,所描述的数据类型需要以复制的形式进行.则使用结构体来定义,否则使用类来定义.</span><br><span class="line"> - Swift中array,dictionary,string,set等类型都是使用struct来定义的.因此进行赋值时都会拷贝一份新的数据.</span><br><span class="line"></span><br><span class="line">### 构造方法的设计和使用</span><br><span class="line">&amp;ensp;&amp;ensp;Swift中的构造方法与OC中的有区别,OC中的构造方法需要返回一个(instanceType)类型,Swift中无返回类型,Swift为了实现类型安全的特性,给构造方法增加了一些原则.Swift中的构造放包括指定构造放和便利构造方法,可失败构造方法和必要构造方法.想通的是在构造子类时需要先构造一个父类.</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;Swift中可以进行属性监听,但是监听在给属性设置初始值和构造方法时豆不会出发,只有在构造完成之后,属性监听才会生效.</span><br></pre></td></tr></table></figure><p>class MyClass {<br>    var count:Int = 0 {<br>        willSet {<br>            print(“willSet:count”)<br>        }<br>        didSet {<br>            print(“didSet:count”)<br>        }<br>    }<br>    init(params:Int) {<br>        count = params<br>    }<br>}<br>var objClass = MyClass(params: 5)<br>objClass.count = 3;  ///只有在初始化后赋值才会触发属性监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;对于结构体,可以不用实现其构造方法,编译器默认生成一个构造方法,将属性作为参数.**对于值类型结构,比如结构体,如果自己定义了一个构造方法,那么系统生成的构造方法将会失效**</span><br><span class="line"></span><br><span class="line">#### 指定构造方法和便利构造方法</span><br><span class="line">&amp;ensp;&amp;ensp;指定构造方法(Designnated)不需要任何关键字修饰,便利构造方法需要使用(Convenience)修饰.便利构造方法方便开发者使用.但是也需要遵循一些原则.</span><br><span class="line"> - 子类的指定构造方法中必须调用父类的指定构造方法</span><br><span class="line"> - 便利构造方法中必须调用当前类的其他构造方法</span><br><span class="line"> - 便利构造方法归根结底要调用某个指定构造方法</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;可以这样理解这三个原则,1、子类构造方法需要调用父类的构造方法.2、便利构造方法是为了方便开发这调用,但是便利构造方法最终依赖于指定构造方法.</span><br><span class="line"></span><br><span class="line">#### 构造方法的继承关系</span><br><span class="line"> - 在继承关系中,如果子类没有覆写或者重写任何指定构造方法,则默认子类会继承父类所有的指定构造方法. </span><br><span class="line"> - 如果子类提供了父类的指定构造方法,则子类默认继承父类的便利构造方法.</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;第一个原则说明子类如果自定义了指定构造方法,或者覆写了父类的某个指定构造方法,那么子类不在继承父类所有的指定构造方法.第二个原则说明由于所有的便利构造方法最终都会调用指定构造方法,因此无论子类中定义的便利构造方法与父类是否相同,都是子类独立的构造方法.</span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;这里注意下覆写(override)和重载(overload)的概念,覆写是指子类对父类的方法进行重新定义.重载是指方法名相同,参数不同或者返回值不同的方法.</span><br><span class="line"></span><br><span class="line">#### 构造方法的安全行检查</span><br><span class="line">&amp;ensp;&amp;ensp;Swift在类的构造方法中会进行4项安全性检查.</span><br><span class="line"> - 在子类的构造方法中,必须完成当前类所有存储属性的构造,才能调用父类的指定构造方法,这样可以保证构造完成从父类继承下来的存储属性前,本身定义的存储属性也构造完成.</span><br><span class="line"> - 子类中如果要自定父类中的存储属性的值,需要在调用父类的构造方法之后再设置,可以保证在重新赋值时父类的属性已经构造完成.</span><br><span class="line"> - 如果便利构造方法中要重新设置某些存储属性的值,那么需要在调用指定构造方法之后设置,可以保证便利构造方法中的值不会被指定构造方法中的值覆盖.</span><br><span class="line"> - 子类在调用父类构造方法前,不能使用self引用属性,可以保证使用self调用实例本身时,实例已经构造完成.</span><br></pre></td></tr></table></figure><p>class subCheck:check {<br>    var subProperty:Int<br>    init() {<br>        /// 原则1调用父类构造方法前,先完成自身属性赋值<br>        subProperty = 1;<br>        super.init(param: 0);<br>        /// 原则2 如果子类对父类属性重新赋值,需要在父类初始化方法之后,保证父类已经存在<br>        property = 2;<br>        /// 原则3完成父类构造方法之后,才能使用self关键字<br>        self.subProperty = 3;<br>    }<br>    convenience init(param1:Int,param2:Int) {<br>        self.init();<br>        /// 原则4 便利构造方法中要修改属性的值需要在指定构造方法之后,防止值被覆盖<br>        subProperty = 3;<br>        property = param2;<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 可失败构造方法和必要构造方法</span><br><span class="line">&amp;ensp;&amp;ensp;Swift为了处理某些可能空的值,引入了optional可选值类型,对于类的构造方法,如果传递的参数不符合要求时,可以让构造方法失败,此时需要使用可失败构造方法的语法.其次,可以设置某些构造方法为必要构造方法,如果类中的某些构造方法被指定为必要构造方法,则其子类必须实现这个方法.必要构造方法使用required关键字修饰.</span><br></pre></td></tr></table></figure><p>class reCheck {<br>    var property:Int<br>    /// 可失败构造方法<br>    init?(params:Int) {<br>        guard params&gt;10 else {<br>            return nil<br>        }<br>        property = params;<br>    }<br>    /// 此构造方法必须子类实现<br>    required init(param1:Int,param2:Int) {<br>        property = param2;<br>    }<br>    deinit {<br>        print(“该类被销毁”);<br>    }</p><p>}<br>```</p><p>&ensp;&ensp;与构造方法相对应的是析构方法.使用deinit标识,当把实例置为nil时,实例会被释放</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;最近开始看下&lt;a href=&quot;https://weread.qq.com/web/reader/7a232e307199a64a7a29ea8k9bf32f301f9bf31c7ff0a60&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Swift4从零到精通iOS开发》&lt;/a&gt;,学习下Swift的语法.也相当于做一个简单的读书笔记.&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;虽然在毕业前也做过一丢丢的Swift语法学习,但是那个时候还没有接触到任何的iOS开发,当时学起来也是晦涩难懂,所以之前的学习就当作空白归零,现在重新开始新的Swift语法学习.&lt;/p&gt;</summary>
    
    
    
    <category term="Swift" scheme="http://yoursite.com/categories/Swift/"/>
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS页面转场动画</title>
    <link href="http://yoursite.com/2021/11/29/iOS%E9%A1%B5%E9%9D%A2%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2021/11/29/iOS%E9%A1%B5%E9%9D%A2%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/</id>
    <published>2021-11-29T08:53:50.000Z</published>
    <updated>2021-11-30T12:25:12.391Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;之前一直对容器转场这一块很模糊,因为这里面涉及到好几个协议的实现,而且名字比较长.读来总是不想仔细去看协议的名称.对于视图切换经常都是使用iOS系统内部自带的present-dismiss动画,或者导航栏的push和pop动画.虽然这部分在我们公司目前的app内也是用的比较多的,但是我感觉在注重用户体验后,这部分也是会进一步优化的.正好前段时间看到了一些关于场景切换的博客,就正好学习一下,并且写一个小demo记录下.方便后面前来查找.</p><a id="more"></a><h3 id="iOS转场动画分类"><a href="#iOS转场动画分类" class="headerlink" title="iOS转场动画分类"></a>iOS转场动画分类</h3><p>&ensp;&ensp;iOS页面转场主要分为三种,uiviewcontroller页面转场,uinavigationviewcontroller页面转场,uitabbarcontroller页面转场,本文主要介绍前两种转场方式.其中对于uiviewcontroller的页面转场是通过present和dismiss的方式进行的页面切换.uinavigationcontroller的页面转场是通过navigtioncontroller管理的子vc的栈进行的push和pop切换.对于系统提供的页面切换,可以使用系统提供的API进行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// 模态弹出的方法</span><br><span class="line">- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^ __nullable)(void))completion;</span><br><span class="line"></span><br><span class="line">- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (^ __nullable)(void))completion;</span><br><span class="line"></span><br><span class="line">/// 导航切换的方法</span><br><span class="line">- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;</span><br><span class="line"></span><br><span class="line">- (nullable UIViewController *)popViewControllerAnimated:(BOOL)animated;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上面的后两个方法是通过导航栏控制调用的,如果要使用导航栏动画,需要设置当前页面容器的根视图是导航栏控制器.uinavigationcontroller里面有很多属性都是日常开发中经常会用到的,可以结合这篇设计<a href="https://www.jianshu.com/p/94910b42396c" target="_blank" rel="noopener"><strong>透明导航栏</strong></a>的文章参考下.</p><p>&ensp;&ensp;如果想要自定义场景切换动画,需要调用iOS提供的一些视图动画协议.我在demo中实现了如下几种效果的页面场景切换</p><p><img src="/2021/11/29/iOS页面转场动画/catagray.png" alt="catagray"></p><h3 id="present-dismiss转场"><a href="#present-dismiss转场" class="headerlink" title="present-dismiss转场"></a>present-dismiss转场</h3><h4 id="UIViewControllerContextTransitioning-amp-amp-UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerContextTransitioning-amp-amp-UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerContextTransitioning &amp;&amp; UIViewControllerAnimatedTransitioning"></a>UIViewControllerContextTransitioning &amp;&amp; UIViewControllerAnimatedTransitioning</h4><p>&ensp;&ensp; 在开始前先熟悉下几个关于自定义转场的协议类</p><ul><li>UIViewControllerContextTransitioning ,这个协议提供了视图切换上下文,在开发过程中一般不需要直接继承这个协议.在使用vc进行场景切换时,可以使用这个协议对象取得动画前后的视图容器.只看这个协议会觉得模糊不清,结合下一个协议一起来看会比较清楚.</li><li>UIViewControllerAnimatedTransitioning ,这个协议类中定义了动画执行的主要方法.其中包含了两个动画相关的主要方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// 返回动画执行的时长</span><br><span class="line">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</span><br><span class="line">/// 定义需要执行的动画</span><br><span class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;可以看到参数是实现了UIViewControllerContextTransitioning协议的参数.通过这个参数可以获取到视图和容器相关的一些参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// 获取转换前后的视图容器</span><br><span class="line">- (nullable __kindof UIViewController *)viewControllerForKey:(UITransitionContextViewControllerKey)key;</span><br><span class="line">/// 需要展示的视图需要添加到containerView中</span><br><span class="line">@property(nonatomic, readonly) UIView *containerView;</span><br><span class="line">/// 某个VC的初始位置，可以用来做动画的计算</span><br><span class="line">-(CGRect)initialFrameForViewController:(UIViewController *)vc;</span><br><span class="line">///与上面的方法对应，得到切换结束时某个VC应在的frame。</span><br><span class="line">-(CGRect)finalFrameForViewController:(UIViewController *)vc;</span><br><span class="line">/// 在动画完成后调用</span><br><span class="line">-(void)completeTransition:(BOOL)didComplete;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;有了以上的动画方法,取到动画切换前后的视图,就可以定义一些简单的动画效果.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;</span><br><span class="line">    /// 1、获取转换vc</span><br><span class="line">    UIViewController *toVc = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</span><br><span class="line">    /// 获取视图大小</span><br><span class="line">    CGRect finalFrame = [transitionContext finalFrameForViewController:toVc];</span><br><span class="line">    CGFloat oriY = [UIScreen mainScreen].bounds.size.height;</span><br><span class="line">    CGFloat oriX = [UIScreen mainScreen].bounds.size.width;</span><br><span class="line">    switch (self.type) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">        &#123;</span><br><span class="line">            /// 动画视图初始位置</span><br><span class="line">            toVc.view.frame = CGRectOffset(finalFrame, -oriX,-oriY);</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1:</span><br><span class="line">        &#123;</span><br><span class="line">            /// 动画视图初始位置</span><br><span class="line">            toVc.view.frame = CGRectOffset(finalFrame, 0, oriY);</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    /// 视图添加到containerView,不添加则展示不了</span><br><span class="line">    UIView *containerView = [transitionContext containerView];</span><br><span class="line">    [containerView addSubview:toVc.view];</span><br><span class="line">    </span><br><span class="line">    /// animation</span><br><span class="line">    /// usingSpringWithDamping 0-1 值越小,则弹性阻尼效果越明显</span><br><span class="line">    /// initialSpringVelocity 初始速度,值越大,动画效果越快</span><br><span class="line">    [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0 usingSpringWithDamping:0.6 initialSpringVelocity:1 options:UIViewAnimationOptionCurveLinear animations:^&#123;</span><br><span class="line">        toVc.view.frame = finalFrame;</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        /// 标记动画全部完成</span><br><span class="line">        [transitionContext completeTransition:YES];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上面自定义动画的过程中</p><ul><li>使用context取到目的视图的容器,(viewControllerForKey中的key可以取值fromVC和toVC)</li><li>确定动画视图的初始位置,上图中展示了动画从下到上(1)和从左上到右下(0)的效果.</li><li>将视图添加到containerView中准备进行动画. </li><li>执行动画</li><li>标记动画是否完成</li></ul><h4 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a>UIViewControllerTransitioningDelegate</h4><p>&ensp;&ensp;有了动画实现类,只需要找到调用方即可,比如A容器推到B容器,那就可以考虑让A容器在调用动画实现.因此考虑让A容器作为代理实现动画调用过程的协议方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// present动画调用方法,</span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source;</span><br><span class="line">/// dismiss动画调用方法</span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;在present动画执行时返回前面自定义的动画</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void) viewDidLoad &#123;</span><br><span class="line">    /// 自定义present动画</span><br><span class="line">    _transition = [ViewControllerAnimatedTransitioning new];</span><br><span class="line">    /// 自定义dismiss动画</span><br><span class="line">    _dismisstransition = [ViewControllerDismisstransition new];</span><br><span class="line">&#125;</span><br><span class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source</span><br><span class="line">&#123;</span><br><span class="line">    return self.transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// dismissvc</span><br><span class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed &#123;</span><br><span class="line">    return self.dismisstransition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;自定义的通过手势滑动关闭页面的动画可以在文末参考demo实现. 通过上面的方法就可以实现一个自定义的页面场景切换动画.整个过程大致如下.</p><ul><li>自定一个类继承 UIViewControllerAnimatedTransitioning 协议,并实现其中的自定义动画方法和动画执行时长方法.</li><li>在需要执行动画的VC中继承 UIViewControllerTransitioningDelegate,设置要执行动画的代理尾当前容器<strong>vc.transitioningDelegate = self;</strong></li><li>实现UIViewControllerTransitioningDelegate中的协议方法,在协议方法中返回自定义的动画效果</li><li><strong>调用控制器的presentViewController方法.系统在调用和这个方法后,如果有自定义动画,会走自定义动画,没有的话就走系统的present动画</strong></li></ul><p>&ensp;&ensp;如果需要实现一些更加炫酷的动画效果,可以自行了解iOS动画机制.</p><h3 id="push-pop动画"><a href="#push-pop动画" class="headerlink" title="push-pop动画"></a>push-pop动画</h3><p>&ensp;&ensp;push和pop的自定义动画实现过程非常类似.也有三个相关的协议类,只是最后在调用动画实现api时需要实现<strong>UINavigationControllerDelegate</strong>这个协议中的动画方法.需要注意的是,使用导航类动画的话需要保证当前所在的容器是包含导航栏的.因为在进行push-pop动画时其本质都是通过导航栏管理一个容器堆栈.下面实现一个自定的导航栏动画效果.</p><ul><li>自定义一个动画类,继承UIViewControllerAnimatedTransitioning,重新协议方法.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;</span><br><span class="line">    return 0.8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///CGAffineTransformMakeScale 视图按比例放缩</span><br><span class="line">- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;</span><br><span class="line">    /// 此方法在push和pop时都会执行</span><br><span class="line">    UIViewController *fromVc = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</span><br><span class="line">    UIViewController *toVc = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</span><br><span class="line">    UIView *fromView = fromVc.view;</span><br><span class="line">//    CGRect screenFrame = fromView.frame;</span><br><span class="line">    UIView *toView = toVc.view;</span><br><span class="line">    UIView *containerView = [transitionContext containerView];</span><br><span class="line">    [containerView addSubview:toView];</span><br><span class="line">    if (self.type == 4) &#123;</span><br><span class="line">        [containerView bringSubviewToFront:fromView];</span><br><span class="line">    //    [containerView bringSubviewToFront:toView];</span><br><span class="line">    //    toView.transform = CGAffineTransformMakeScale(0.2, 0.2);</span><br><span class="line">        [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123;</span><br><span class="line">            fromView.alpha = 0;</span><br><span class="line">            fromView.transform = CGAffineTransformMakeScale(0.2, 0.2);</span><br><span class="line">    //        toView.transform = CGAffineTransformMakeScale(1, 1);</span><br><span class="line">            toView.alpha = 1;</span><br><span class="line">        &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">            fromView.transform = CGAffineTransformMakeScale(1, 1);</span><br><span class="line">            [transitionContext completeTransition:YES];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; else if (self.type == 5) &#123;</span><br><span class="line"></span><br><span class="line">        toView.transform = CGAffineTransformMakeScale(0.2, 0.2);</span><br><span class="line">        [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123;</span><br><span class="line">            toView.transform =  CGAffineTransformMakeScale(1, 1);</span><br><span class="line">//            toView.frame = screenFrame;</span><br><span class="line">        &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">            [transitionContext completeTransition:YES];</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在需要实现动画的控制器中实现 UINavigationControllerDelegate,并将导航控制器的代理设置为容器本身.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// 如果在这一步将代理设置为被push的容器,那么自定义动画只会在pop返回时生效.   pushVc.navigationController.delegate = pushVc;</span><br><span class="line">self.navigationController.delegate = self;</span><br></pre></td></tr></table></figure></li><li><p>实现UINavigationControllerDelegate协议中的动画调用方法.返回自定义动画</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    _naviTransition = [NavigationControllerTransitioning new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// navigation animation</span><br><span class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC</span><br><span class="line">&#123;</span><br><span class="line">    return self.naviTransition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp; 和present动画另一个不同的点是,此处的动画是push和pop都会调用的.如果想设置push和pop不同的效果可以判断何时是push,何时是pop来进行区分.自定义的push动画效果过程大致如下:</p><ul><li>自定一个类继承 UIViewControllerAnimatedTransitioning 协议,并实现其中的自定义动画方法和动画执行时长方法.</li><li>在需要执行动画的VC中继承 UINavigationControllerDelegate,设置要执行动画的代理尾当前容器<strong>self.navigationController.delegate = self;</strong></li><li>实现UINavigationControllerDelegate中的协议方法,在协议方法中返回自定义的动画效果</li><li><strong>调用navigationcontroller的pushViewController:方法,触发动画,如果有自定义动画则走自定义动画,否则走系统自带动画效果.</strong></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://onevcat.com/2013/10/vc-transition-in-ios7/" target="_blank" rel="noopener">iOS7中的ViewController切换</a></p><p><a href="https://www.jianshu.com/p/e7155f938e59" target="_blank" rel="noopener">ViewController自定义转场－基础</a></p><p><a href="https://www.jianshu.com/p/319cbc53f0ba" target="_blank" rel="noopener">iOS导航控制器——UINavigationController使用详解</a></p><p><a href="https://github.com/SJ110/ios-animation-demo/tree/master/multi-thread-demo" target="_blank" rel="noopener">demo地址</a><br>demo里面比较杂,放的东西比较多.</p><p>之后了解下如何截gif图,尝试在博客中也添加一些gif图增加效果.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;之前一直对容器转场这一块很模糊,因为这里面涉及到好几个协议的实现,而且名字比较长.读来总是不想仔细去看协议的名称.对于视图切换经常都是使用iOS系统内部自带的present-dismiss动画,或者导航栏的push和pop动画.虽然这部分在我们公司目前的app内也是用的比较多的,但是我感觉在注重用户体验后,这部分也是会进一步优化的.正好前段时间看到了一些关于场景切换的博客,就正好学习一下,并且写一个小demo记录下.方便后面前来查找.&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>项目完成后的tips总结</title>
    <link href="http://yoursite.com/2021/11/19/%E9%A1%B9%E7%9B%AE%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84tips%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/11/19/%E9%A1%B9%E7%9B%AE%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84tips%E6%80%BB%E7%BB%93/</id>
    <published>2021-11-19T06:42:42.000Z</published>
    <updated>2021-11-30T12:31:01.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;最近刚刚完成了一个比较大的项目,整体客户端工期是14人天,我投入了10人天,因为服务端已经提前配合安卓上线了,所以整个项目中就是iOS端和测试端的人力投入,这整个项目包括从启动开始到最后渲染包含的东西不少.加之最近也看了好些iOS开发相关的书,我试着把自己学到的一些东西结合实际投入进去.可以感觉到和去年,不,应该是和半年前写代码有一些不同的感触.当然也不是说觉得自己很能写了,而是觉得自己面对一个问题时的思路比以往多了一些.主要表现在当觉得某一个方式实现功能不太方便时,我会尝试其他一些方式.习惯在实现一个复杂功能的时候先列出流程点.工程启动较慢,我就使用自己本地的小demo对一些不是完全把握的点先进行测试.遇到app表现和预期不一致时,不在直接打断点寻找问题,而是先思考一下可能的点,在追代码,然后断点.但是还是有很多需要加强的地方,架构设计这一块还是很模糊,很想把数据和视图隔离开来,总是差点意思.这个还是需要继续加强的. 更明显的点是因为前期把功能点分的比较细致,到后面相互模块间交互时,写起代码来就感觉比以往轻松了,很容易实现模块的相互交互.</p><a id="more"></a><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&ensp;&ensp;下面是对整个开发流程中遇到的一些问题的解决方案和个人的一些总结.方便自己记忆和后续再次遇到时能尽快解决.基本都是一些开发中很基本的问题,而且大多数在看书时也看到过,但还是忘记了在开发时要避免.</p><h4 id="1、页面粒度尽量细化"><a href="#1、页面粒度尽量细化" class="headerlink" title="1、页面粒度尽量细化"></a>1、页面粒度尽量细化</h4><p>&ensp;&ensp;在以往的开发中,我也会细化页面粒度,但是经常在开发中会有一个想法, 当两个视图从某些角度来看比较类似时,我就喜欢使用一个视图的不同状态来呈现.然后根据状态的不同来将子视图进行隐藏或者高度置为0.这样做很明显一个坏处就是,无论是数据源还是视图,总是需要一些个变量来操作当前需要什么数据,需要展示什么样式.带来了另一种程度上的臃肿.不过现在来看,感觉这也违背了<strong>单一职责</strong>的原则.视图虽然不应该跟交互绑定,但是一个视图对应的事项应该尽量少,这样才可以降低类与类之间的依赖.但是也需要根据自身情况考虑一些其他问题,有时候UI的复用如果带来的收益大于重新写一套带来的收益,我认为还是尽量复用原有组件比较好.经常也会有一些组件只需要稍微改动其中一小点的样式就可以达到本次需求的效果(这在我当前的公司还是比较常见的).我一般会给产品和设计的同学给出两种方案.1、尽量按照公司原本样式推进,不能因为一条业务线就使用一种新的样式,因为这样带来的结果是没条业务线都想要一些自己独特的风格.2、如果无法说服产品,当然标准还是需要推行的,我们会扩展原本的样式,相当于提供一个新的能力.但是也会要求以后需要按照新的标准来实行,同时推动产品侧同步公司的一套样式标准.</p><h4 id="2、尽量将VC瘦身"><a href="#2、尽量将VC瘦身" class="headerlink" title="2、尽量将VC瘦身"></a>2、尽量将VC瘦身</h4><p>&ensp;&ensp;本次开发中,我尽量把代码放到视图容器中,在VC(viewcontroller)通过申明一个<strong>视图容器</strong>来持有视图容器,最后的结果是VC中的代码没有超过100行.使用这个做法是之前有看到过一篇讲SDWebImage的博文中说过:“把复杂的东西留给自己,把简介的外表留给他人”.因此我把很多的数据交互逻辑放到了上面提到的视图容器中.视图容器不进行UI相关的操作,但是会持有子视图,自视图也正是需求所需要的U.视图容器中还会有数据逻辑的变化和交互处理,以及一些通知和代理的处理逻辑.当然这部分应该是可以在通过MVVM/MVP的设计思想在进一步优化一下的,但是当时做的时候我个人感觉对于这样的设计模式还是有一些模糊,简单来说就是知道这两种模式的意思,但是自己要按照这样实现起来还是有一定难度.大部分时间我都认为coding是一个模仿的过程,因为我们app内大多数都是以MVC为主,或者进行了一些变化.这也是我一段时间内都习惯于这种模式的编码,如今,在觉得某些场景不适合的情况下,我也会尽量使用新的模式或者通过将代码结构粒度细化的方式来实现需求.</p><h4 id="3、弹出新页面"><a href="#3、弹出新页面" class="headerlink" title="3、弹出新页面"></a>3、弹出新页面</h4><p>&ensp;&ensp;中间遇到一个需求点,要求点击视图中一个按钮,弹出一个新的视图覆盖在表面.这个问题解决方案比较多,首先是半透明的背景,然后在背景中增加一个需要展示的视图.因为是在首页,底部是存在一个tab,所以直接使用普通视图是无法覆盖底部tab的.可以选择1、将要展示的视图使用window承载,设置window背景色为半透明.2、将要展示的视图使用viewcontroller承载,设置vc的view背景色半透明,使用模态弹出的方式弹出视图.我考虑使用现成的模态弹出动画,因此我使用一个VC来承载弹出的视图.这样做也一定程度上分离了功能点,最后我只是在视图容器中声明了需要弹出的VC,就达到了最后需要的效果.</p><h4 id="4、数据传递"><a href="#4、数据传递" class="headerlink" title="4、数据传递"></a>4、数据传递</h4><p>&ensp;&ensp;本次开发中另一个让我觉得棘手的问题是数据的传递,因为页面粒度的细化,层级加深.带来的问题是外面的数据要传递到内部需要一层一层传递,内部的事件想要外部响应,也需要一层层往外传递.当这个时候我很不愿意给视图类增加一个fetch的public方法来提供给外部取数据向内传递,我原本想通过内外都增加一个共有的第三方类来处理信息和事件的内外流动,但是设计过程中效果甚微,导致短期看不到结果,为了不拖延工期,我还是使用数据一层层传递的方式,然后在中间增加了一些代理和block来处理事件的调用.对于这一点在后续codereview时我也会向相关同学请教一下更好的处理方式,在某个合适的时机在进一步实践.搞好这一点对于架构设计应该会更明朗一些.</p><h4 id="5、圆角和阴影共存"><a href="#5、圆角和阴影共存" class="headerlink" title="5、圆角和阴影共存"></a>5、圆角和阴影共存</h4><p>&ensp;&ensp;这个问题应该来说遇到好多次了.这次mark一下,之前都是遇到找一下相关博客,这次尽量记住.参考博客<a href="https://www.jianshu.com/p/56d6fb9fe189" target="_blank" rel="noopener">圆角阴影共存</a>,总结下来需要注意以下几点1、设置了layer.masksToBounds = YES,将导致阴影失效,因为这个属性会将超过视图的部分截断.2、如果对一个view的一个layer同时设置圆角和阴影,那么两者是无法并存的,因为设置圆角时我们总会将masksToBounds设置为yes保证圆角生效.因此参考博客后我的做法是使用两个view,外部的一个view设置阴影,内部的一个view设置圆角,同时设置外部view的backgroundColor为clear.另外在iOS 11之后提供了给视图指定位置设置圆角的方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* maskedCorners是一个枚举值,</span><br><span class="line">  kCALayerMinXMinYCorner = 1U &lt;&lt; 0, 左上角</span><br><span class="line">  kCALayerMaxXMinYCorner = 1U &lt;&lt; 1, 左下角</span><br><span class="line">  kCALayerMinXMaxYCorner = 1U &lt;&lt; 2, 右上角</span><br><span class="line">  kCALayerMaxXMaxYCorner = 1U &lt;&lt; 3, 右下角</span><br><span class="line">  */</span><br><span class="line">    if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">         self.bgView.layer.maskedCorners = kCALayerMinXMaxYCorner | kCALayerMaxXMaxYCorner;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="6、masonry动画"><a href="#6、masonry动画" class="headerlink" title="6、masonry动画"></a>6、masonry动画</h4><p>&ensp;&ensp;iOS中提供了非常成熟的视图动画效果,在我们app内可以应对绝大多数的日常需求开发.但是以往我使用的动画都是通过修改view的frame布局实现的,本次因为使用masonry来布局,实现动画时通过mas_updateConstraint,但是最后没有得到的动画效果.查找一些资料后发现需要在动画过程中强制出发UI的重新渲染,<a href="https://www.jianshu.com/p/fab05a3af1a0" target="_blank" rel="noopener">masonry动画</a>,mark一下,方便之后使用.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这句代码需要在UIView,animation动画过程中添加</span><br><span class="line">[view.superview layoutIfNeeded];</span><br></pre></td></tr></table></figure><h4 id="7、属性修饰符"><a href="#7、属性修饰符" class="headerlink" title="7、属性修饰符"></a>7、属性修饰符</h4><p>&ensp;&ensp;这次开发中还有一个非常低级的错误,以下是背景:保存下拉刷新时的列表数据源,在上拉加载更多时,将新的数据源追加到保存的数据源的末尾,再将新的数据返回给外部进行渲染.我将保存的数据源的变量使用如下修饰:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">///此处的修饰符应该使用strong而不是copy</span><br><span class="line">@property (nonatomic, copy) NSMutableArray *listArray;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;就是这个很小的错误我debug了很久,就觉得很奇怪,为什么一个ArrayM类型,会被识别为ArrayI类型.然后在我追加数据的方法里面carsh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObjectsFromArray:(NSArray&lt;ObjectType&gt; *)otherArray;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;好在最后找到了原因,使用copy修饰可变类型,无论如何初始化,最终也会在内存中被copy成一份不可变的类型.这是copy这个修饰符的特性.不会增加成员的引用次数,而是copy一份副本.strong修饰是增加成员的引用次数.对象不会拷贝一份新的.这也就是根本原因.虽然这一点我之前在书上也是看到的,但是不小心还是出错了….</p><p>&ensp;&ensp;然后随便讲下mutableCopy和copy方法.这两个方法是定义在NSOBJect中的,<strong>对于可变类型,使用mutableCopy得到的结果还是可变类型,使用copy得到的就是不可变类型,对于不可变类型,使用mutableCopy得到的结果是可变类型,使用copy得到的还是不可变类型.</strong></p><p>&ensp;&ensp;另外,对于不可变类型我们一般使用copy修饰符修饰,因为copy会对属性增加一份拷贝,如果使用strong的话,因为赋值前后两者都指向同一份地址,容易导致修改原数据时也不经意修改了赋值后的数据.</p><h4 id="8、开发中的小tips"><a href="#8、开发中的小tips" class="headerlink" title="8、开发中的小tips"></a>8、开发中的小tips</h4><p>&ensp;&ensp;开发过程中经常会对需要做到的一个效果保持怀疑态度,不确定这个方案是否正确,我一般的做法是本地写一个简单的demo,然后在demo中实现我需要的方案的简化板.如果成功,说明这是我期望的效果.不成功的话,就需要进一步在探索了.这个做法可以节约不少时间,因为我们app的主工程因为历史原因,代码量超大, 每次编译需要的时间比较长,使用小demo可以节约不少时间.</p><h4 id="9、导航栏黑线隐藏"><a href="#9、导航栏黑线隐藏" class="headerlink" title="9、导航栏黑线隐藏"></a>9、导航栏黑线隐藏</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self.navigationController.navigationBar setShadowImage:[UIImage new]];</span><br><span class="line">[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;注意,此设置后全局的navigtionBar的导航栏黑线都会消失,如果只是对某一场景定制的话,可以使用成员属性保存<strong>ShadowImage</strong>和<strong>BackgroundImage</strong>,然后在viewdiddisappear的方法里面在设置回来.(使用者方法是因为我们app内没有对导航栏黑线特别在意,基础库中没有提供相应方法.)</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;最近刚刚完成了一个比较大的项目,整体客户端工期是14人天,我投入了10人天,因为服务端已经提前配合安卓上线了,所以整个项目中就是iOS端和测试端的人力投入,这整个项目包括从启动开始到最后渲染包含的东西不少.加之最近也看了好些iOS开发相关的书,我试着把自己学到的一些东西结合实际投入进去.可以感觉到和去年,不,应该是和半年前写代码有一些不同的感触.当然也不是说觉得自己很能写了,而是觉得自己面对一个问题时的思路比以往多了一些.主要表现在当觉得某一个方式实现功能不太方便时,我会尝试其他一些方式.习惯在实现一个复杂功能的时候先列出流程点.工程启动较慢,我就使用自己本地的小demo对一些不是完全把握的点先进行测试.遇到app表现和预期不一致时,不在直接打断点寻找问题,而是先思考一下可能的点,在追代码,然后断点.但是还是有很多需要加强的地方,架构设计这一块还是很模糊,很想把数据和视图隔离开来,总是差点意思.这个还是需要继续加强的. 更明显的点是因为前期把功能点分的比较细致,到后面相互模块间交互时,写起代码来就感觉比以往轻松了,很容易实现模块的相互交互.&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS事件机制</title>
    <link href="http://yoursite.com/2021/10/25/iOS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/10/25/iOS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-10-25T03:09:39.000Z</published>
    <updated>2022-02-10T01:19:47.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;按照时间顺序,事件的生命周期包括事件的产生和传递(事件从父控件传递到子控件并找到合适的view)和事件的处理(对于事件的响应).其中的重点是:</p><ul><li>1、触摸事件由触屏生成后如何传递到当前应用.</li><li>2、应用接收触摸事件后如何寻找最佳响应者.</li><li>3、响应事件如何沿着响应链流动.</li><li>4、响应链(UIResponder),手势识别器(UIGesture),UIControl之间的关系.</li></ul><p>&ensp;&ensp;当用户触碰了屏幕后,整个事件的传递和响应的流程基本如下:<br>1、点击到屏幕上的某一点被封装成为触摸事件添加到UIApplication对象的事件队列中.这个队列按照fifo的顺序执行其中的触摸事件.事件出队列时,UIApplication开始寻找一个最佳响应者,过程称为这个过程称为hit-testing.<br>2、当找到一个最佳响应者后,接下来是事件的传递和响应.事件除了被最佳响应者消耗,还能被手势识别器或者targte-action模式捕捉或者消耗.<br>3、触摸事件要么会被某个响应对象捕获后释放,要么没有找到能够响应的对象,最终被释放.</p><a id="more"></a><h3 id="触摸-事件-响应者"><a href="#触摸-事件-响应者" class="headerlink" title="触摸,事件,响应者"></a>触摸,事件,响应者</h3><h4 id="触摸–UITouch"><a href="#触摸–UITouch" class="headerlink" title="触摸–UITouch"></a>触摸–UITouch</h4><p>&ensp;&ensp;当手指触摸屏幕时,会生成一个UItouch对象,如果多个手指同时触摸,会生成多个对象.如果两个手指一前一后触摸同一位置(双击),那么第一次触摸生成UITouch对象,第二次触摸更新这个对象,UItouch对象的tapCount从1变为2. 如果两个手指一前一后触摸位置不同,将生成两个UITouch对象,两者之间没有联系.每一个UITouch对象记录了触摸的一些信息,包括触摸事件,位置,阶段,所处的视图,窗口等信息.</p><h4 id="UIEvent"><a href="#UIEvent" class="headerlink" title="UIEvent"></a>UIEvent</h4><p>&ensp;&ensp;一个触摸事件对应一个UIEvent对象,其中的type属性标识了事件的类型(事件类型不只有触摸类型).UIEvent对象中包含了触发该事件的触摸对象集合,因为一个触摸事件可能包含多个UITouch对象.</p><h4 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h4><p>&ensp;&ensp;每一个响应者都是一个UIResponder对象或者是其子类.本身都具有响应事件的能力,<br>1、UIView<br>2、UIViewcontroller<br>3、UIApplication<br>4、Appdelegate<br>响应者之所以能响应事件,是因为UIResponder提供了如下四个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//手指触碰屏幕，触摸开始</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">//手指在屏幕上移动</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">//手指离开屏幕，触摸结束</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">//触摸结束前，某个系统事件中断了触摸，例如电话呼入</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure><p>这些方法会在响应者对象接收到事件的时候调用,用于对事件做出响应.</p><h3 id="寻找事件的最佳响应者"><a href="#寻找事件的最佳响应者" class="headerlink" title="寻找事件的最佳响应者"></a>寻找事件的最佳响应者</h3><p>&ensp;&ensp;当触摸事件产生时,因为触摸位置所在的视图不止一个,需要找到一个最适合响应的视图,这个过程叫做hit-testing,命中的最佳响应者称为hit-tested view.<br>1、应用程序收到事件后,如何寻找最佳响应者.2、寻找到最佳响应者过程中事件的拦截</p><h4 id="寻找最佳响应者-自上而下"><a href="#寻找最佳响应者-自上而下" class="headerlink" title="寻找最佳响应者-自上而下"></a>寻找最佳响应者-自上而下</h4><p>&ensp;&ensp;1、队列中的事件出队列后,application将事件传递给当前展示的window,2、如果window能响应事件,则传递给子视图.3、子视图如果能响应,则继续往下寻找,不能则传递给同级视图往下寻找.4、如果当前视图没有能响应事件的子视图了,则该视图就是最佳响应者.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIApplication-&gt;window-&gt;view-&gt;...-&gt;view</span><br></pre></td></tr></table></figure><p>需要注意的一点是,当寻找当前视图的子视图时,是从后(后添加)往前(先添加)寻找,判断是否可以响应.因为后添加的视图总是位于更上层.</p><h4 id="如何判断视图是否响应事件"><a href="#如何判断视图是否响应事件" class="headerlink" title="如何判断视图是否响应事件"></a>如何判断视图是否响应事件</h4><p>&ensp;&ensp;1、不允许交互:userInteractionEnabled = NO;2、视图隐藏:如果父视图hidden = yes,那么子视图也会隐藏,隐藏的视图无法接受事件.3、透明度:如果视图的alpha&lt;0.01,那么会认为视图透明,无法响应事件.</p><h4 id="hitTest-withEvent"><a href="#hitTest-withEvent" class="headerlink" title="hitTest:withEvent:"></a>hitTest:withEvent:</h4><p>&ensp;&ensp;hitTest:withEvent是每个view都可以响应的方法,如果当前视图无法响应事件,那么返回nil.如果当前视图可以响应事件,但是无子视图可以响应事件,则返回自身作为当前视图层级中事件响应者.如果当前视图可以响应,并且子视图也可以响应,则返回子视图中的响应者.<br>&ensp;&ensp;UIApplication响应hitTest:withEvent方法,传递UIWindow判断是否可以响应事件,如果可以,在调用UIWindow的子视图的hitTest:withEvent方法.最终返回一个结果给UIApplication.下面是hitTest:withEvent方法的大致实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    //3种状态无法响应事件</span><br><span class="line">     if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha &lt;= 0.01) return nil; </span><br><span class="line">    //触摸点若不在当前视图上则无法响应事件</span><br><span class="line">    if ([self pointInside:point withEvent:event] == NO) return nil; </span><br><span class="line">    //从后往前遍历子视图数组 </span><br><span class="line">    int count = (int)self.subviews.count; </span><br><span class="line">    for (int i = count - 1; i &gt;= 0; i--) </span><br><span class="line">    &#123; </span><br><span class="line">        // 获取子视图</span><br><span class="line">        UIView *childView = self.subviews[i]; </span><br><span class="line">        // 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标</span><br><span class="line">        CGPoint childP = [self convertPoint:point toView:childView]; </span><br><span class="line">        //询问子视图层级中的最佳响应视图</span><br><span class="line">        UIView *fitView = [childView hitTest:childP withEvent:event]; </span><br><span class="line">        if (fitView) </span><br><span class="line">        &#123;</span><br><span class="line">            //如果子视图中有更合适的就返回</span><br><span class="line">            return fitView; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    //没有在子视图中找到更合适的响应视图，那么自身就是最合适的</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<strong>pointInside:withEvent</strong>方法,判断如果坐标在自身坐标范围内则返回true,否则返回false.<br>&ensp;&ensp;对于如下视图,点击图中的view查看效果</p><p><img src="/2021/10/25/iOS事件机制/views.png" alt="views"></p><p>当点击view4的时候,可以看到其中的hitview的传递过程和响应链的传递过程</p><p><img src="/2021/10/25/iOS事件机制/consequens.png" alt="consequens"><br>&ensp;&ensp;因为是从最上层的view开始遍历,因此直接找到了view4,找到之后,开始事件的响应链传递,一层层传递到了application中.</p><h4 id="hit—testing过程中的事件拦截"><a href="#hit—testing过程中的事件拦截" class="headerlink" title="hit—testing过程中的事件拦截"></a>hit—testing过程中的事件拦截</h4><p>&ensp;&ensp;实际开发时会遇到一些特殊的交互需求,例如对tabbar中建的按钮,对于超过tabbar的部分点击是没有响应的,<br><img src="/2021/10/25/iOS事件机制/tabbar.png" alt="tabbar"></p><p>&ensp;&ensp;分析途中的事件触摸事件传递过程 window-rootview-tabbar-circlbutton,如果点击位置在tabbar内部,事件是可以传递到circlebutton的,但是点击在tabbar外部时,事件传递到tabbar后,因为点击区域在其之外,所以hit-testing返回了nil,认为其不可以响应事件,传递到tabbar的之外的视图上.<br>&ensp;&ensp;这个问题的解决方案是,当点击圆圈上部时,当事件传递到tabbar,pointInside:方法返回了no,因此,可以重写tabbar的pointInside:方法,如果触摸点在圆圈内部则返回true,否则才返回no,这样才可以让事件传递到源泉内部.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//TabBar</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    //将触摸点坐标转换到在CircleButton上的坐标</span><br><span class="line">    CGPoint pointTemp = [self convertPoint:point toView:_CircleButton];</span><br><span class="line">    //若触摸点在CricleButton上则返回YES</span><br><span class="line">    if ([_CircleButton pointInside:pointTemp withEvent:event]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    //否则返回默认的操作</span><br><span class="line">    return [super pointInside:point withEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件的响应及在响应链中传递"><a href="#事件的响应及在响应链中传递" class="headerlink" title="事件的响应及在响应链中传递"></a>事件的响应及在响应链中传递</h4><p>&ensp;&ensp;确定了最佳响应者之后,同时事件(UIevent)也会从UIwindow一起传递到视图上.通过重写UIResponder的触摸方法,可以实现截获对事件的处理,实现对视图的拖动和画图等功能.</p><p>&ensp;&ensp;响应链,响应者对于触摸事件的拦截和传递通过touchesBegan:方法控制,该方法,默认是将响应链向上进行传递.如果进行重写,可以做如下处理:</p><ul><li>不拦截,继续往下传递</li><li>拦截,自行处理事件,但是不在继续往下传递.</li><li>拦截,自行处理事件,同时继续将事件往下传递.</li></ul><p>&ensp;&ensp;事件向下继续传递通过super调用方法实现.向下传递是将事件传递给nextResponder, 对于UIView,nextResponder是其父视图,对于UIViewcontroller,nextResponder是presenting view controller或者UIWindow.UIWindow的nextResponder为UIApplication对象。<br>在touchBegan方法中调用如下方法可以查看nextResponder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)printResponderChain</span><br><span class="line">&#123;</span><br><span class="line">    UIResponder *responder = self;</span><br><span class="line">    printf(&quot;%s&quot;,[NSStringFromClass([responder class]) UTF8String]);</span><br><span class="line">    while (responder.nextResponder) &#123;</span><br><span class="line">        responder = responder.nextResponder;</span><br><span class="line">        printf(&quot; --&gt; %s&quot;,[NSStringFromClass([responder class]) UTF8String]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UIResponder-UIgestureRecognier-UIControl"><a href="#UIResponder-UIgestureRecognier-UIControl" class="headerlink" title="UIResponder,UIgestureRecognier, UIControl"></a>UIResponder,UIgestureRecognier, UIControl</h3><p>&ensp;&ensp;除了responder,手势和UIControl都可以处理事件,当他们同时出现时,会有什么结果呢?</p><h4 id="几个结论"><a href="#几个结论" class="headerlink" title="几个结论"></a>几个结论</h4><p>&ensp;&ensp;1、手势响应优先级最高(UIgestureRecognier),点击事件响应链优先级较低.很多的手势冲突都是事件的优先级没有捋清.<br>2、单击事件优先传递给手势响应,如果手势识别成功,那么就取消事件响应链的传递.<br>3、如果手势识别失败,那么触摸事件就会继续在响应链中传递下去.</p><h4 id="事件的几个概念"><a href="#事件的几个概念" class="headerlink" title="事件的几个概念"></a>事件的几个概念</h4><p>1、UITouch,当一根手指触摸屏幕时,会创建一个与之关联的UITouch对象.手指离开屏幕时对象销毁.<br>2、UIEvent,一个UIEvent对象对应多个UITouch对象,从第一个手指触摸屏幕到最后一个手指离开屏幕.<br>3、UIResponder,所有继承了UIResponder的对象都可以接受并处理事件.</p><h4 id="手势识别和事件响应混用"><a href="#手势识别和事件响应混用" class="headerlink" title="手势识别和事件响应混用"></a>手势识别和事件响应混用</h4><p>对于如下界面<br><img src="/2021/10/25/iOS事件机制/conflict.png" alt="conflict"><br>backView添加手势,同时增加事件传递的touchBegan方法,btn增加增加target-action,testView增加事件传递的Touch方法.</p><p>1、点击backView:<br><img src="/2021/10/25/iOS事件机制/backclick.png" alt="backclick"></p><p>2、点击testView<br><img src="/2021/10/25/iOS事件机制/testclick.png" alt="testclick"></p><p>3、点击按钮<br><img src="/2021/10/25/iOS事件机制/btnclick.png" alt="btnclick"></p><p>&ensp;&ensp;对于1,2手势和响应链都触发了,但是最后响应链cancel了,说明触摸对象被取消,只有手势(gesture)继续执行了.因此,在手势和事件响应链同时存在时,识别出了手势就会将触摸对象取消.</p><p>&ensp;&ensp;对于场景3,默认控制操作可以防止重叠的手势识别器,对于按钮的默认操作是点击,因此会忽略掉手势动作.</p><p>&ensp;&ensp;综上所述,当一种交互操作识别成功时,另外一种交互操作就会被cancel,不会再往下传递.</p><h4 id="实际开发中遇到的问题"><a href="#实际开发中遇到的问题" class="headerlink" title="实际开发中遇到的问题"></a>实际开发中遇到的问题</h4><p>&ensp;&ensp;实际开发中,为了不让父视图手势识别干扰子视图的点击事件响应和响应链的传递,一般重写UIGestureRecognizerDelegate中的gestureRecognizer:方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch  </span><br><span class="line">&#123;  </span><br><span class="line">     // 若为UITableViewCellContentView（即点击了tableViewCell），</span><br><span class="line">    if ([NSStringFromClass([touch.view class]) isEqualToString:@&quot;UITableViewCellContentView&quot;]) &#123;  </span><br><span class="line">    // cell 不需要响应 父视图的手势，保证didselect 可以正常</span><br><span class="line">        return NO;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //默认都需要响应</span><br><span class="line">    return  YES;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;参考demo,和多线程demo放在一起了<br><a href="https://github.com/SJ110/ios-animation-demo" target="_blank" rel="noopener">iOS事件处理demo</a></p><p>&ensp;&ensp;参考文章</p><p><a href="https://www.jianshu.com/p/c294d1bd963d" target="_blank" rel="noopener">iOS触摸事件全家桶</a></p><p><a href="https://www.jianshu.com/p/53e03e558cbd" target="_blank" rel="noopener">iOS点击事件和手势冲突</a></p><p><a href="https://www.jianshu.com/p/2e074db792ba" target="_blank" rel="noopener">史上最详细的iOS事件传递和响应</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;按照时间顺序,事件的生命周期包括事件的产生和传递(事件从父控件传递到子控件并找到合适的view)和事件的处理(对于事件的响应).其中的重点是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、触摸事件由触屏生成后如何传递到当前应用.&lt;/li&gt;
&lt;li&gt;2、应用接收触摸事件后如何寻找最佳响应者.&lt;/li&gt;
&lt;li&gt;3、响应事件如何沿着响应链流动.&lt;/li&gt;
&lt;li&gt;4、响应链(UIResponder),手势识别器(UIGesture),UIControl之间的关系.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;当用户触碰了屏幕后,整个事件的传递和响应的流程基本如下:&lt;br&gt;1、点击到屏幕上的某一点被封装成为触摸事件添加到UIApplication对象的事件队列中.这个队列按照fifo的顺序执行其中的触摸事件.事件出队列时,UIApplication开始寻找一个最佳响应者,过程称为这个过程称为hit-testing.&lt;br&gt;2、当找到一个最佳响应者后,接下来是事件的传递和响应.事件除了被最佳响应者消耗,还能被手势识别器或者targte-action模式捕捉或者消耗.&lt;br&gt;3、触摸事件要么会被某个响应对象捕获后释放,要么没有找到能够响应的对象,最终被释放.&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>动态item实现的动态化</title>
    <link href="http://yoursite.com/2021/10/24/%E5%8A%A8%E6%80%81item%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A8%E6%80%81%E5%8C%96/"/>
    <id>http://yoursite.com/2021/10/24/%E5%8A%A8%E6%80%81item%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A8%E6%80%81%E5%8C%96/</id>
    <published>2021-10-24T02:25:49.000Z</published>
    <updated>2021-10-24T02:32:01.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;和匹配侧的各位同学一起维护动态item已经有一段时间了,一开始接触感觉这个东西很高深莫测,随着接触时间的增加,相关业务开发的处理,算是对动态item整个渲染过程有一些理解.在这里写一篇日志记录一下.<br>&ensp;&ensp;动态item以更加快速的构建用户ui视图,可以降低app发版诉求甚至在一些场景下可以免于app发版.<br>&ensp;&ensp;其中快速构建视图是通过动态item提前将描述ui视图结构通过描述性语言事先存放,在渲染阶段通过读取描述性的json文件,使用事先规定好的规则将视图渲染上屏.<br>&ensp;&ensp;让app免于发版是通过将描述文件放置到服务端,通过app冷启动接口下发,这样可以做到增量更新,一些新的需求发布之后,只需修改描述文件中的某一项,不需要改动到native代码,即可完成视图的渲染,降低了发版次数.</p><a id="more"></a><h3 id="渲染流程–流程图"><a href="#渲染流程–流程图" class="headerlink" title="渲染流程–流程图"></a>渲染流程–流程图</h3><p>&ensp;&ensp;因为动态item存在这样的特性,相较于一般的ui层渲染,他需要多一个配置文件. 整个渲染流程图如下</p><p><img src="/2021/10/24/动态item实现的动态化/process.png" alt="process"></p><h3 id="渲染流程–配置文件"><a href="#渲染流程–配置文件" class="headerlink" title="渲染流程–配置文件"></a>渲染流程–配置文件</h3><p>&ensp;&ensp;在业务中中动态item主要用于列表的渲染,下面就以列表卡片为例概述下整个流程,因为卡片样式改动较小,并且交互较低.所以一次配置文件完成后,可以较长时间内不在变动.<br>&ensp;&ensp;对于一个列表卡片,渲染流程中主要关注tableview的两个代理方法一个是cellforrow方法,一个是heighforrow方法.其中cellforrow方法需要返回一个卡片,在这个方法内就可以按需进行ui的搭建.<br>&ensp;&ensp;&ensp;&ensp;动态item的ui搭建使用从上到下从做到右的顺序进行每一行作为一个容器,整个卡片又作为一个更大的容器,因此,在内部可以实现递归的UI搭建:以其中一条数据搭建为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      &quot;fontColor&quot;: &quot;#333333&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;fontSize&quot;: 18,</span><br><span class="line"></span><br><span class="line">      &quot;isBold&quot;: 1,</span><br><span class="line"></span><br><span class="line">      &quot;hasTags&quot;: 1,</span><br><span class="line"></span><br><span class="line">      &quot;key&quot;: &quot;startAndEnd&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;maxLines&quot;: 2,</span><br><span class="line"></span><br><span class="line">      &quot;widgetType&quot;: 0</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  &quot;rowStyle&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &quot;marginRight&quot;: 75</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &quot;rowType&quot;: 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染流程–ui"><a href="#渲染流程–ui" class="headerlink" title="渲染流程–ui"></a>渲染流程–ui</h3><p>&ensp;&ensp;这是一个”item“,其中的“key”值,对应从接口取数据的”key“值.“data”是一个数组,表示内部可以容纳多个”item“,”rowstyle“用来描绘该容器的位置 “rowType”描绘该容器的类型,比如是否嵌套等.<br>&ensp;&ensp;”widgetType“ 标识当前视图的类型,可能是view,label,button,image等. 因此对于每一个item,都可以按照类似的方式设置其内部的视图,默认内部视图是从左到右排列的,有了这个实例,可以看到,data内的每一个元素可以做很多的扩展,比如想添加borderline,添加富文本等,都可以新增一个key值去加以标识.最后值的渲染只需要保证前后端约定的”key”的内容一致即可.<br>&ensp;&ensp;cellforrow对数据源做了处理,也约定了卡片某个容器的位置,但是容器需要多大,最终整个卡片需要多高是需要通过heightforrow去处理的.<br>&ensp;&ensp;item中只指定了每个容器和容器内部每个视图间的间隔,因此容器大小和容器内每个视图的大小都需要根据内容进行处理. heightforrow 就是需要统计内部视图最终的高度来得到cell的高度.</p><h3 id="渲染流程–上屏展示"><a href="#渲染流程–上屏展示" class="headerlink" title="渲染流程–上屏展示"></a>渲染流程–上屏展示</h3><p>&ensp;&ensp;当卡片的高度确定,卡片内的内容确定之后就可以通过数据源赋值然后上屏展示了.在页面的滑动过程中,因为会存在cell的复用机制,但是在业务上每个卡片的高度是不统一的,卡片的重用也是通过模版内的一个字段加以控制,就算是字段名相同,业务接口返回的数据也可能缺少某些条目导致卡片高度不同,因此在性能上会造成一定的损耗,不过这也是业务不断变化导致的不可控制的结果.理想情况下动态item创建的卡片应该变化很小,但是业务却不断往卡片中增加内容,导致规范性降低.</p><h3 id="思考和感悟"><a href="#思考和感悟" class="headerlink" title="思考和感悟"></a>思考和感悟</h3><p>&ensp;&ensp;动态item是为了快速搭建ui和解决因业务迭代带来的app发版频次问题,在满帮主要应用在列表卡片上.但是由于以往的ui不规范,加上一开始时间紧迫导致设计的不完整,对于当前的迭代已经显得疲软了.但是动态item的思路是很不错的,他增加了一个配置文件,通过这个桥梁将一些依靠native代码的东西方法哦服务端接口.对于变动不大并且交互较少的视图是很有用的.并且可以在当前能力的基础上在扩展很多其他的能力.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;和匹配侧的各位同学一起维护动态item已经有一段时间了,一开始接触感觉这个东西很高深莫测,随着接触时间的增加,相关业务开发的处理,算是对动态item整个渲染过程有一些理解.在这里写一篇日志记录一下.&lt;br&gt;&amp;ensp;&amp;ensp;动态item以更加快速的构建用户ui视图,可以降低app发版诉求甚至在一些场景下可以免于app发版.&lt;br&gt;&amp;ensp;&amp;ensp;其中快速构建视图是通过动态item提前将描述ui视图结构通过描述性语言事先存放,在渲染阶段通过读取描述性的json文件,使用事先规定好的规则将视图渲染上屏.&lt;br&gt;&amp;ensp;&amp;ensp;让app免于发版是通过将描述文件放置到服务端,通过app冷启动接口下发,这样可以做到增量更新,一些新的需求发布之后,只需修改描述文件中的某一项,不需要改动到native代码,即可完成视图的渲染,降低了发版次数.&lt;/p&gt;</summary>
    
    
    
    <category term="动态化" scheme="http://yoursite.com/categories/动态化/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS多线程</title>
    <link href="http://yoursite.com/2021/10/08/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2021/10/08/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-10-08T07:03:49.000Z</published>
    <updated>2021-12-21T09:52:19.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp; 本文参考自<a href="https://weread.qq.com/web/reader/2ce3297071e2a5172ce5d66ke4d32d5015e4da3b7fbb1fa" target="_blank" rel="noopener">《iOS开发项目化经典教程》</a>第一章,主要讲述iOS实现多线程的四种方式，线程间的安全和通信，GCD的基本操作。NSOperation的基本操作。</p><p>&ensp;&ensp; 多线程概念：由于一个线程同一时间内只能处理一个任务，因此一个线程内的任务需要按顺序执行。因此在遇到网络请求，下载等耗时操作时，需要等待此类操作结束才能进行接下来的操作，这段时间内用户不能进行任何操作，app也不会响应用户的操作。这是一种很糟糕的用户体验。因此在开发过程中，通常把比较耗时的操作放到一个线程中，把和用户交互放到主线程中。保证能够及时响应用户的操作行为。</p><a id="more"></a><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>&ensp;&ensp; 进程:进程是系统中正在运行的程序，进程拥有自己的地址空间，程序加载进内存开始运行时就会变为一个进程。进程是系统进行资源分配和调度的基本单位。有三个特点:1、独立性，进程有独立的资源和地址访问空间。2、动态性，进程是程序在系统中的一次执行过程，进程时一个正在系统中活动的指令的集合，其中加入了时间的概念。具有自己的生命周期和各自不同的状态。3、并发性,进程可以在单个处理器中并发执行，虽然宏观上是并发的，但是从微观上看，cpu在一个时间片内只能执行一条指令，因此在宏观时间内也是各个进程不断相互切换执行。<br>&ensp;&ensp; 线程:线程是任务调度和执行的基本单位，线程扩展了进程的概念，一个进程要运行至少需要一个线程，这个线程成为称为主线程。当进程被初始化后，线程就被创建了。进程内的每个线程是相互独立的。<br>&ensp;&ensp;进程中包含若干线程，这些线程可以利用进程所拥有的资源。由于线程比进程更加轻量，对线程的调用开销就会比进程的开销小的多。因此多线程更能提高系统中多个程序间的并发程度。当使用多线程进行开发时需要注意:1、线程虽然占用资源较低，但是也需要一定的内存空间，如果开启大量线程，就会占用大量内存空间导致程序卡顿。3、开启的线程越多，cpu在进行调度时的开销就越大。因此不要同时开启超过5个线程。3、使用多线程时需要保证数据的统一性。可以采用加锁的方式实现数据的独占访问。</p><h4 id="线程的串行和并行"><a href="#线程的串行和并行" class="headerlink" title="线程的串行和并行"></a>线程的串行和并行</h4><p>&ensp;&ensp;一个进程中如果只包含一个线程，那么当多个任务需要执行时只能由这个线程去一个一个串行执行。如果进程中包含不止一条线程，那每条线程可以同时执行不同的任务，称之为线程的并行，也即多线程。需要注意的是，cpu在同一个时间内只能处理一个线程，也就是同一时间只有一个线程在工作，不过cpu切换很快，用户感知不到。</p><h4 id="多线程分类"><a href="#多线程分类" class="headerlink" title="多线程分类"></a>多线程分类</h4><p>&ensp;&ensp; iOS提供了四种现实多线程的方式，pthread:使用c语言实现，是跨平台的多线程api。NSThread:使用oc实现。GCD:使用c实现，对线程管理进行了封装，是常用的多线程开发手段。NSOperation:基于GCD进行了二次封装，使其使用更加面向对象。</p><p><img src="/2021/10/08/iOS多线程/threads.png" alt="threads"></p><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>&ensp;&ensp;当线程被创建并启动时，线程并不是直接开始执行，而线程开始执行之后也不是一直在执行。而是随着cpu的时间片轮转不停的切换状态。下图是线程的状态切换过程图。</p><p><img src="/2021/10/08/iOS多线程/thread_state.png" alt="thread_state"></p><p>1、创建，当创建一个线程之后，该线程就处于新建的状态，仅由系统分配了内存，初始化了其内部成员变量的值。2、就绪，当线程调用了start方法之后，线程就处于就绪态了，处于就绪态的线程并没有开始执行，只是表示可以开始执行了。何时开始执行由系统控制。 3、运行，当cpu分配的时间片调用当前线程时，其他线程处于挂起状态，该线程处于运行状态。4、终止，当线程执行结束，或者调用exit方式终止，或者执行过程中出现异常，线程变为终止状态。5、阻塞，如果当前线程需要暂停一段时间，则可以调用sleep方法让线程进入阻塞态。</p><h4 id="线程间的安全隐患"><a href="#线程间的安全隐患" class="headerlink" title="线程间的安全隐患"></a>线程间的安全隐患</h4><p>&ensp;&ensp;如果进程中的一块资源被多个线程共享，那么这块资源称为临界资源，当多个线程同时访问一块资源时，会出现资源的抢占和数据错乱等问题。为了实现数据的安全访问，可以使用线程间加锁的方式，下面通过一个卖票的例子展示一下：</p><p><img src="/2021/10/08/iOS多线程/saletickets.png" alt="saletickets"></p><p>&ensp;&ensp;从途中可以看到,多个线程访问临界资源时会发生数据错乱,为了解决这种问题,需要给临界资源加锁,加锁可以保证同一时刻只有一个线程能够访问临界资源,使用@synchronized关键字可以实现加锁.需要注意的是使用同步锁会消耗大量cpu资源,所以应该把同步锁内的代码量尽量减少.<br><img src="/2021/10/08/iOS多线程/thread_state2.png" alt="thread_state2"></p><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><p>&ensp;&ensp;在一个进程中,其线程往往不是孤立存在的,他们之间可以相互通信,比如一个线程需要等到另外一个线程任务执行完毕后才能开始执行.在做任务转换的同时也可能有数据的转换.</p><h3 id="使用NSThread实现多线程"><a href="#使用NSThread实现多线程" class="headerlink" title="使用NSThread实现多线程"></a>使用NSThread实现多线程</h3><p>&ensp;&ensp;下面通过一个实例来演示NSThread的三种创建方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// 需要调用start启动线程</span><br><span class="line">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;</span><br><span class="line"></span><br><span class="line">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</span><br><span class="line"></span><br><span class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg;</span><br></pre></td></tr></table></figure><p>三种不同的线程创建方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    _btn = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">    [_btn setTitle:@&quot;创建线程&quot; forState:UIControlStateNormal];</span><br><span class="line">    [_btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];</span><br><span class="line">    _btn.titleEdgeInsets = UIEdgeInsetsMake(5, 20, 5, 20);</span><br><span class="line">    _btn.frame = CGRectMake(self.view.frame.size.width/2-70, 300, 140, 50);</span><br><span class="line">    [_btn addTarget:self action:@selector(onClick) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:_btn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)onClick &#123;</span><br><span class="line">    NSThread *currentThread = [NSThread currentThread];</span><br><span class="line">    NSLog(@&quot;btnclick--%@--current&quot;,currentThread);</span><br><span class="line">    NSThread *mainThread = [NSThread mainThread];</span><br><span class="line">    NSLog(@&quot;btnclick--%@--main&quot;,mainThread);</span><br><span class="line">//    [self threadCreate1];</span><br><span class="line">//    [self threadCreate2];</span><br><span class="line">    [self threadCreate3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run:(NSString *)params &#123;</span><br><span class="line">    NSThread *cur = [NSThread currentThread];</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        NSLog(@&quot;%@---call run--%@&quot;,cur,params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// 第一种初始化</span><br><span class="line">-(void)threadCreate1 &#123;</span><br><span class="line">    NSThread *threadA = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@&quot;threadA&quot;];</span><br><span class="line">    threadA.name = @&quot;线程A&quot;;</span><br><span class="line">    /// 必须使用start启动线程</span><br><span class="line">    [threadA start];</span><br><span class="line">    NSThread *threadB = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@&quot;threadB&quot;];</span><br><span class="line">    threadB.name = @&quot;线程B&quot;;</span><br><span class="line">    [threadB start];</span><br><span class="line">&#125;</span><br><span class="line">/// 第二种初始化</span><br><span class="line">- (void)threadCreate2 &#123;</span><br><span class="line">    [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;threadCreate2&quot;];</span><br><span class="line">&#125;</span><br><span class="line">/// 第三种初始化</span><br><span class="line">- (void)threadCreate3 &#123;</span><br><span class="line">    [self performSelectorInBackground:@selector(run:) withObject:@&quot;threadCreate3&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;主线程的名字是main，手动创建的线程可以重新命名。</p><h3 id="使用GCD实现多线程"><a href="#使用GCD实现多线程" class="headerlink" title="使用GCD实现多线程"></a>使用GCD实现多线程</h3><p>&ensp;&ensp;使用GCD可以比NSThread更快,更方便的实现多线程的处理,使用GCD需要明确两个概念,队列和任务.队列:队列是GCD中用来存放任务的集合,负责管理开发者提交的任务.队列的核心就是将长期执行的任务分成多个工作单元,并将任务添加到队列中,系统会带为管理这些队列.并放到多线程中执行.队列分为串行队列和并行队列.串行队列内部只维护一个线程,一次只能执行一个任务.任务串行执行.并行队列内部维护了多个线程,可以按照如队列顺序并行执行. 任务:任务时用户提交给队列的工作单元,也就是在队列中执行的代码块.任务提交后会由队列以多线程的方式执行.</p><h4 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h4><p>&ensp;&ensp;全局并发队列,全局并发队列可以并行的执行多个任务,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//identifier 指定队列优先级</span><br><span class="line">// flags 保留字段,方便以后扩展</span><br><span class="line">dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)</span><br><span class="line"></span><br><span class="line">// 实例</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;创建串行队列和并行队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建队列</span><br><span class="line">//label 表示队列的字符串(c字符串)</span><br><span class="line">//attr 标识串行还是并行 DISPATCH_QUEUE_SERIAL 串行, DISPATCH_QUEUE_CONCURRENT 并行</span><br><span class="line">dispatch_queue_t dispatch_queue_create(const char *_Nullable label,dispatch_queue_attr_t _Nullable attr);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;获取主队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// 获取主队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure><h4 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h4><p>&ensp;&ensp;队列创建结束之后,可以通过同步和异步两种方式向队列提交任务. 同步执行:同步执行的任务只会在当前线程执行任务,不会开启新线程.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">///同步执行</span><br><span class="line">/// queue 将要提交到的任务队列, block 执行的代码块</span><br><span class="line">dispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;异步执行任务,异步执行会在新线程中执行任务具备开启新线程的能力,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">///异步执行</span><br><span class="line">///queue 将要提交到的任务队列, block 执行的代码块</span><br><span class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;下面是一个代码实例,展示了串行队列下的同步执行和并行队列下的同步执行,串行队列下的异步执行和并行队列下的异步执行.</p><p>同步执行不会开启新的线程,是在主线程完成任务的,同步的并行也不会开启新线程,两个都是串行执行任务.</p><p><img src="/2021/10/08/iOS多线程/serialSerial.png" alt="syncSerial"></p><p>异步执行串行队列的任务,会开启新线程,但是任务串行执行.</p><p><img src="/2021/10/08/iOS多线程/concerrentSerial.png" alt="asyncSerial"></p><p>异步执行并行队列任务,会开启新线程,任务并行执行.</p><p><img src="/2021/10/08/iOS多线程/asyncConcerrent.png" alt="asyncConcerrent"></p><p>&ensp;&ensp;下表展示了同步执行串行队列任务和并行队列任务,异步执行串行队列任务和并行队列任务的结果</p><p><img src="/2021/10/08/iOS多线程/outcome.png" alt="outcome"></p><h4 id="单次或者重复执行任务"><a href="#单次或者重复执行任务" class="headerlink" title="单次或者重复执行任务"></a>单次或者重复执行任务</h4><p>&ensp;&ensp;如果想要某些操作只执行一次,可以使用dispatch_once()实现,干函数接收两个参数,第一个参数接收一个标识符,用来标识代码代码是否已经执行.第二个参数是只执行一次的代码块.如果想要某些操作重复执行多次,可以使用dispatch_apply();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// iterations 需要执行的次数  queue 任务需要提交的目标队列  block 需要重复执行的代码块</span><br><span class="line">void dispatch_apply(size_t iterations,</span><br><span class="line">dispatch_queue_t DISPATCH_APPLY_QUEUE_ARG_NULLABILITY queue,</span><br><span class="line">DISPATCH_NOESCAPE void (^block)(size_t));</span><br></pre></td></tr></table></figure><h4 id="调度队列组"><a href="#调度队列组" class="headerlink" title="调度队列组"></a>调度队列组</h4><p>&ensp;&ensp;假设有如下一个一个场景,一个音乐app,需要执行多个下载任务,这些下载任务会放到后台的多个线程中执行,当全部下载任务结束之后,弹出一个提示框告知用于下载结束.<br>这种场景可以使用队列组在实现.使用dispatch_group_create()创建队列组,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// 创建队列组</span><br><span class="line">dispatch_group_t dispatch_group_create(void);</span><br></pre></td></tr></table></figure><p>创建队列组后,可以使用dispatch_group_async()函数将需要执行的任务提交到队列组,会异步的执行任务组中的任务,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// 异步执行队列组中的任务 group,队列组  queue,任务需要提交到的队列, block,需要执行的代码块</span><br><span class="line">void dispatch_group_async(dispatch_group_t group,</span><br><span class="line">dispatch_queue_t queue,</span><br><span class="line">dispatch_block_t block);</span><br></pre></td></tr></table></figure><p>任务组中的任务执行完之后可以通过dispatch_group_notify()来通知,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// group, 创建的队列组 queue,将要执行的任务所添加到的队列  block,执行的代码块</span><br><span class="line">void dispatch_group_notify(dispatch_group_t group,</span><br><span class="line">dispatch_queue_t queue,</span><br><span class="line">dispatch_block_t block);</span><br></pre></td></tr></table></figure><p>这里的demo展示的是使用队列组进行图片下载,在图片下载完成后,回到主队列进行渲染和展示.但是队列组中的每一次下载都是新开了线程,并且是并行执行的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)groupImage &#123;</span><br><span class="line">    __block typeof(self) weakSelf=self;</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    __block UIImage *img1 = nil;</span><br><span class="line">    dispatch_group_async(group, global_queque, ^&#123;</span><br><span class="line">        img1 = [weakSelf downloadImage:@&quot;http://statics.888ppt.com/Upload/photothumb/6J93jXFHs24.jpg&quot;];</span><br><span class="line">        NSLog(@&quot;--%@--&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    __block UIImage *img2 = nil;</span><br><span class="line">    dispatch_group_async(group, global_queque, ^&#123;</span><br><span class="line">        img2 = [weakSelf downloadImage:@&quot;http://up.enterdesk.com/edpic/d4/32/68/d43268ae15cefc60c54b8b0f94a46c74.jpg&quot;];</span><br><span class="line">        NSLog(@&quot;--%@--&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_notify(group, global_queque, ^&#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            weakSelf.imgView1.image = img1;</span><br><span class="line">            weakSelf.imgView2.image = img2;</span><br><span class="line">            NSLog(@&quot;--%@--&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用NSOperation实现多线程"><a href="#使用NSOperation实现多线程" class="headerlink" title="使用NSOperation实现多线程"></a>使用NSOperation实现多线程</h3><p>&ensp;&ensp;NSOperation是使用oc封装的基于gcd的多线程处理方式,更加面向对象<strong>1、执行操作</strong>,如果要执行一个NSOperation对象,可以通过1、手动调用start方法实现,这个方法调用之后,就会在当前调用的线程同步执行任务.2、可以将NSOperation添加到NSOperationQueue中,NSOperationQueue会在NSOperation被添加进去后尽快执行,并且是异步执行.<strong>2、取消操作</strong>,当一个operation开始执行后,默认会一直执行到结束,也可以调用cancel取消操作的执行,需要注意的是,如果操作在队列中没有开始执行,这时取消这个操作,并将finished设置为YES,此时操作就直接取消了.如果操作正在执行,设置cancel方法也只能等待操作执行完.<strong>3、添加依赖</strong>,可以将多个耗时的异步操作分成若干部分,当前一个执行完后在执行另一个,可以通过addDependency方法,协调先后关系.注意:两个任务间不能相互依赖,比如A依赖B,B依赖A,这样会导致思索.当每个操作结束后需要将isFinished设置为Yes.<strong>4、监听操作</strong>,使用setCompletionBlock可以在一个operation结束后做一些其他事情.</p><h4 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h4><p>&ensp;&ensp; NSOperationQueue与GCD队列一样,采用先进先出的方式,负责管理系统提交的多个NSOperation对象.NSOperationQueue负责管理其中持有的NSOperation对象,下面是一些常见的方法:<br><strong>1、添加NSOperation到NSOperationQueue中</strong>,将NSOperation添加到队列中,并由队列中的线程池管理和调度,使用如下方法来管理,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// ops,将要添加到队列的操作组, wait 是否等待操作结束后在返回,设置为yes会阻塞主线程</span><br><span class="line">- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait</span><br></pre></td></tr></table></figure><p>也可以使用如下方法来添加任务,添加任务到队列中后不要在手动更改任务的状态,队列会自行进行管理.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// block 将要执行的代码块</span><br><span class="line">- (void)addOperationWithBlock:(void (^)(void))block;</span><br></pre></td></tr></table></figure><p><strong>2、修改NSOperation对象执行顺序</strong>,对于添加到队列中的操作对象,执行顺序依赖亮点,1、操作对象是否已经是就绪态,2、操作对象的优先级高低.可以通过手动设置queuePriority在更改operation的优先级.<br><strong>3、设置操作队列的最大并发数量</strong>,当队列中线程过多时,会影响app的执行效率,因此可以设置对答并发数量来约束队列中的最大进程数<br><strong>4、等待NSOperation操作执行完成</strong>,不要在主线程使用如下方法,这回阻塞主线程.app显示为无响应.<br><strong>5、使用NSOperation子类进行操作</strong>,NSOperation是一个抽象基类,可以自行继承这个类创建自己的操作对象,也可以使用NSInvocationOperation和NSBlockOperatin来进行操作.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)waitUntilFinished ;</span><br><span class="line">- (void)waitUntilAllOperationsAreFinished;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;因此,使用NSOperation和NSOperationQueue两个类结合使用可以实现多线程,1、将需要执行的操作添加到NSOperation中.2、将NSOperation添加到NSOperationQueue中.3、系统自动取出NSOperationQueue中的对象.4、取出的对象会自动创建新线程进行.</p><h4 id="iOS多线程小demo"><a href="#iOS多线程小demo" class="headerlink" title="iOS多线程小demo"></a>iOS多线程小demo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">     NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;3&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;4&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;5&quot;);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上述代码执行结果为13245或者12345,结果是固定的.明确概念,任务是执行在队列上的,队列是运行在线程上的.一个线程上可以同时出现多个队列.同步任务会阻塞线程.异步任务不会阻塞线程.异步任务具有开启新线程的能力.如果是自定义队列,异步执行会为其开启新线程,如果是主队列,异步执行不会开启新线程,在主线程上执行.</p><p>&ensp;&ensp;对于上面代码,首先打印1,然后异步执行串行队列上的任务,不会阻塞当前线程(主线程),打印3,4和5的顺序是固定的,因为4是同步任务,2和4的顺序是固定的,因为两者在同一个队列上,需要按照fifo的顺序执行.因此,只需要考虑2和3谁先谁后即可,应该说都有可能,因此最后结果是13245或者12345.</p><p>&ensp;&ensp;上文中的demo参考<a href="https://github.com/SJ110/ios-animation-demo" target="_blank" rel="noopener">此处</a>即可.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp; 本文参考自&lt;a href=&quot;https://weread.qq.com/web/reader/2ce3297071e2a5172ce5d66ke4d32d5015e4da3b7fbb1fa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《iOS开发项目化经典教程》&lt;/a&gt;第一章,主要讲述iOS实现多线程的四种方式，线程间的安全和通信，GCD的基本操作。NSOperation的基本操作。&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp; 多线程概念：由于一个线程同一时间内只能处理一个任务，因此一个线程内的任务需要按顺序执行。因此在遇到网络请求，下载等耗时操作时，需要等待此类操作结束才能进行接下来的操作，这段时间内用户不能进行任何操作，app也不会响应用户的操作。这是一种很糟糕的用户体验。因此在开发过程中，通常把比较耗时的操作放到一个线程中，把和用户交互放到主线程中。保证能够及时响应用户的操作行为。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS动画基础</title>
    <link href="http://yoursite.com/2021/09/12/iOS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/09/12/iOS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/</id>
    <published>2021-09-12T07:09:54.000Z</published>
    <updated>2022-01-07T12:07:40.372Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;这边博客主要是总结一下最近看到iOS动画开发的一些基础知识。主要包含如下一些知识点。主要参考自<a href="https://weread.qq.com/web/reader/56932a20719b1fcb569e111kf4532c00231f457c545ad3c" target="_blank" rel="noopener">《iOS开发实战：从入门到上架APPsotre》</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、使用UIImageView播放图片组动画</span><br><span class="line">2、使用block回调创建UIView层过渡动画</span><br><span class="line">3、使用block回调创建UIView层转场动画</span><br><span class="line">4、使用commit方式创建UIView层过渡动画</span><br><span class="line">5、使用commit方式创建UIView层转场动画</span><br><span class="line">6、CAlayer层在UI开发中的应用</span><br><span class="line">7、各种CALayer子类的用法</span><br><span class="line">8、coreAnimation核心动画框架的用法</span><br><span class="line">9、视图的transform变换</span><br><span class="line">10、粒子效果动画</span><br><span class="line">11、iOS中播放GIF动态图的方法</span><br><span class="line">12、Flappy Bird动画小游戏</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="使用UIImageView播放图片组动画"><a href="#使用UIImageView播放图片组动画" class="headerlink" title="使用UIImageView播放图片组动画"></a>使用UIImageView播放图片组动画</h4><p>&ensp;&ensp;使用UIImageview的<strong><em>animationImages</em></strong>属性将需要播放的图片加载进去，设置播放时长，和重复次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(30, 100, 170, 460)];</span><br><span class="line">    NSMutableArray *imageArray = @[].mutableCopy;</span><br><span class="line">    for(int i = 1; i &lt;= 4;i++) &#123;</span><br><span class="line">        UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;VC1Image%d&quot;,i]];</span><br><span class="line">        [imageArray addObject:image];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.view addSubview:imageView];</span><br><span class="line">    imageView.animationImages = imageArray;</span><br><span class="line">    imageView.animationDuration = 0.4;</span><br><span class="line">    imageView.animationRepeatCount = 0; ///无限循环</span><br><span class="line">    [imageView startAnimating];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行后就会出现四张图无限轮播的动画效果。</p><h4 id="UIView层动画的应用"><a href="#UIView层动画的应用" class="headerlink" title="UIView层动画的应用"></a>UIView层动画的应用</h4><p>&ensp;&ensp;一般的开发中，对于UIView层的动画是使用非常广泛的。iOS提供在UIView层上进行动画操作的类方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/// NSTimeInterval:动画持续时间</span><br><span class="line">///^(void)animations 需要执行的动画内容</span><br><span class="line">[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; animations:&lt;#^(void)animations#&gt;]</span><br><span class="line"></span><br><span class="line">///NSTimeInterval:同上</span><br><span class="line">///^(void)animations :同上</span><br><span class="line">/// ^(BOOL finished)completion 动画完成需要执行的动作</span><br><span class="line"> [UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;]</span><br><span class="line"></span><br><span class="line">/// UIViewAnimationOptions 动画执行的配置参数 枚举类型，比如淡入淡出效果等</span><br><span class="line">/// 动画配置参数的取值可以参考源码中的枚举定义</span><br><span class="line">/// delay 动画延迟执行时间</span><br><span class="line">[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; options:&lt;#(UIViewAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;]</span><br><span class="line"></span><br><span class="line">// usingSpringWithDamping 取值0-1，设置阻尼度</span><br><span class="line">// initialSpringVelocity 阻尼初速度</span><br><span class="line">[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; usingSpringWithDamping:&lt;#(CGFloat)#&gt; initialSpringVelocity:&lt;#(CGFloat)#&gt; options:&lt;#(UIViewAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 40, 40)];</span><br><span class="line">    view.backgroundColor = [UIColor blueColor];</span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line">    NSTimeInterval times = 3;</span><br><span class="line">    [UIView animateWithDuration:times animations:^&#123;</span><br><span class="line">        view.frame = CGRectMake(200, 200, 80, 80);</span><br><span class="line">        view.backgroundColor = [UIColor redColor];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;运行代码可以看到图从蓝色变为红色 位置偏移，大小变化，持续时间3秒,其他几种动画效果参考demo</p><h5 id="UIView层过渡动画支持的属性"><a href="#UIView层过渡动画支持的属性" class="headerlink" title="UIView层过渡动画支持的属性"></a>UIView层过渡动画支持的属性</h5><p>&ensp;&ensp;动画的执行还可以进行嵌套，可以将动画分成几个部分，执行完某一部分后在其回调中执行下一部分，下面列出一些动画过渡中可以支持的属性</p><pre><code>1、frame:给视图的位置和尺寸实现过渡的动画效果。2、bounds:给视图内部的坐标原点改变和尺寸变化增加过渡效果3、center:为视图的4、transform:给视图的几何变换增加过渡动画5、alpha:给视图透明度增加过渡动画6、backgroundColor:给视图背景色增加动画7、contentStrech给UIImageview改变图片拉伸方式增加动画</code></pre><p>&ensp;&ensp;<strong><em>bounds和frame.使用cgRect设置时，后两个参数决定大小，前两个参数中，frame决定当前视图在父视图中的位置，bounds决定子视图在自身中的坐标原点的位置</em></strong></p><h4 id="使用commit方式进行UIView动画创建"><a href="#使用commit方式进行UIView动画创建" class="headerlink" title="使用commit方式进行UIView动画创建"></a>使用commit方式进行UIView动画创建</h4><p>&ensp;&ensp;在iOS4之前使用传统的commit的方式创建UIView层的动画。这种方式包含四个步骤，1设置动画开始标志，2、设置动画属性，3、设置动画过渡效果，4、提交动画。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    UIView *view = [UIView new];</span><br><span class="line">    view.frame = CGRectMake(100, 100, 80, 80);</span><br><span class="line">    view.backgroundColor = [UIColor redColor];</span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line">    /// 动画开始标志</span><br><span class="line">    [UIView beginAnimations:@&quot;test&quot; context:nil];</span><br><span class="line">    [UIView setAnimationDelegate:self];</span><br><span class="line">    /// 动画属性</span><br><span class="line">    [UIView setAnimationWillStartSelector:@selector(start)];</span><br><span class="line">    [UIView setAnimationDidStopSelector:@selector(stop)];</span><br><span class="line">    [UIView setAnimationDuration:3];</span><br><span class="line">    [UIView setAnimationDelay:1];</span><br><span class="line">    [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];</span><br><span class="line">    [UIView setAnimationRepeatAutoreverses:YES];</span><br><span class="line">    [UIView setAnimationRepeatCount:3];</span><br><span class="line">    /// 动画过渡效果</span><br><span class="line">    view.backgroundColor = [UIColor blueColor];</span><br><span class="line">    view.frame = CGRectMake(200, 200, 80, 80);</span><br><span class="line">    /// 提交动画</span><br><span class="line">    [UIView commitAnimations];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;对比上下两种动画，commit的方式更为传统，需要编写的代码也更多，因为是在iOS4之前，iOS4之后引入UIView的类方法的动画到现在应该是所有版本都适配的，现在基本没有iOS4以下的设备。而且commit创建动画的方式已经在iOS13以后被废弃了。所以还是尽量使用UIView类方法创建动画的方式更好。</p><h4 id="UIView转场动画"><a href="#UIView转场动画" class="headerlink" title="UIView转场动画"></a>UIView转场动画</h4><p>&ensp;&ensp; 相对于过渡动画，转场动画更多用于两个UIView视图的切换或者重绘某个视图。iOS中，UIView的转场动画有两种，一种是对UIView视图内容进行重新绘制，一种是使用新的视图替换旧视图的转场。<br>&ensp;&ensp; 在实际开发中开发者会遇到这样的需求：一个UIView视图中有许多子视图，当用户数据变化时，子视图控件需要重新布局，使得原本视图看来变成新的视图。因为视图的重绘是在瞬间完成的，如果不添加任何转场效果，就会出现闪动，体验效果很差。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 80, 80)];</span><br><span class="line">    view.backgroundColor = [UIColor redColor];</span><br><span class="line">    view2 = [[UIView alloc]initWithFrame:CGRectMake(200, 200, 80, 80)];</span><br><span class="line">    view2.backgroundColor = [UIColor blueColor];</span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    /// 视图自身变化进行转场</span><br><span class="line">    [UIView transitionWithView:view duration:3 options:UIViewAnimationOptionTransitionFlipFromBottom | UIViewAnimationOptionAllowAnimatedContent animations:^&#123;</span><br><span class="line">        self-&gt;view.backgroundColor = [UIColor blueColor];</span><br><span class="line">        self-&gt;view.frame = CGRectMake(200, 200, 80, 80);</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    /// 切换视图转场</span><br><span class="line">//    [UIView transitionFromView:view toView:view2 duration:3 options:UIViewAnimationOptionTransitionFlipFromBottom |UIViewAnimationOptionAllowAnimatedContent  completion:^(BOOL finished) &#123;</span><br><span class="line">//</span><br><span class="line">//    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;切换视图的转场用于开发中整体视图的切换需求，这个操作会将原本的UIView从原本的父视图上移除，再将新的UIView视图添加到父视图上。其中option的定义是一个枚举，其中定义了许多转场的效果，可以进入源码查看其定义。</p><h4 id="coreAnimation动画编程技术"><a href="#coreAnimation动画编程技术" class="headerlink" title="coreAnimation动画编程技术"></a>coreAnimation动画编程技术</h4><p>&ensp;&ensp;使用UIView层的过渡动画和转场动画可以满足绝大部分开发需求，但是也有许多局限性，使用CoreAnimation则可以更加自由的进行iOS动画编程。CoreAnimation是基于OpenGL和CoreGraphics图像处理框架的跨平台动画框架，下图给出了CoreAnimtion的系统结构图</p><p><img src="/2021/09/12/iOS动画基础/coreAnimation.png" alt="coreAnimation"></p><p>&ensp;&ensp;CoreAnimation框架中大多数动画效果都是基于CALayer类实现的。每一个UIView都包含一个CALayer属性。边框，阴影等操作都是和CALayer相关的。</p><p>&ensp;&ensp;<strong>锚点</strong>，所有的CALayer对象都有一个anchorPoint属性，这是CALayer对象的锚点，可以理解为对象动作的参照点，其中x,y都取值在0～1中，CALayer对象锚点值默认为(0,0)是视图的左上角，如果要设置为视图中心，则将锚点设置为(0.5,0.5),当CALayer层执行操作时都是以锚点为参考点进行的。比如一些平移，旋转等。抛开Layer层，view层主要是处理事件接受和用户交互的功能。</p><h5 id="色彩梯度层–CAGradientLayer"><a href="#色彩梯度层–CAGradientLayer" class="headerlink" title="色彩梯度层–CAGradientLayer"></a>色彩梯度层–CAGradientLayer</h5><p>&ensp;&ensp;CAGradientLayer 是继承自CALayer的子类，是专门用来处理颜色梯度渐变的layer层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    CAGradientLayer *layer = [CAGradientLayer layer];</span><br><span class="line">    layer.colors = @[(id)[UIColor redColor].CGColor,(id)[UIColor blueColor].CGColor];</span><br><span class="line">    layer.bounds = CGRectMake(100, 100, 100, 100);</span><br><span class="line">    layer.position = CGPointMake(200, 200);</span><br><span class="line">    layer.locations = @[@0.2,@0.8];</span><br><span class="line">    layer.startPoint = CGPointMake(0, 0);</span><br><span class="line">    layer.endPoint = CGPointMake(1, 1);</span><br><span class="line">    [self.view.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上面代码中colors用于设置颜色梯度，bounds是设置CAlayer类的基础属性，用来设置layer层尺寸，position属性设置layer的位置，locations属性设置颜色梯度分界线，取值为0-1，startPoint，endPoint设置渲染的起始位置，此处为左上角到右下角，locations会渲染0.2部分红色，在渲染0.8部分的蓝色。</p><h5 id="视图拷贝层–CARelicatorLayer"><a href="#视图拷贝层–CARelicatorLayer" class="headerlink" title="视图拷贝层–CARelicatorLayer"></a>视图拷贝层–CARelicatorLayer</h5><p>&ensp;&ensp;CARelicatorLayer可以理解为layer层的一个复制容器，起作用是复制一个已经存在的layer层对象进行复制渲染.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">///CARelicatorLayer</span><br><span class="line">CALayer *baseLayer = [CALayer layer];</span><br><span class="line">baseLayer.bounds = CGRectMake(0, 0, 100, 100);</span><br><span class="line">baseLayer.position = CGPointMake(100, 400);</span><br><span class="line">baseLayer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">CAReplicatorLayer *reLayer = [CAReplicatorLayer layer];</span><br><span class="line">reLayer.instanceRedOffset = -0.2;</span><br><span class="line">reLayer.position = CGPointMake(0, 0);</span><br><span class="line">reLayer.instanceTransform = CATransform3DMakeTranslation(100, 0, 0);</span><br><span class="line">reLayer.instanceCount = 3;</span><br><span class="line">[reLayer addSublayer:baseLayer];</span><br><span class="line">[self.view.layer addSublayer:reLayer];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;此处layer先创建一个layer层作为要复制的原本，作为子layer加到CARelicatorLayer对象中，CARelicatorLayer的instanceRedOffset设置每个复制副本背景色中红色的偏移量，对应还有蓝色，绿色和alpha的偏移量。instanceTransform属性用于设置复制视图的3D变化属性，上面的代码表示将每个复制的layer层沿着x轴正方向偏移100个单位。</p><h5 id="图形渲染层–CAShapeLayer"><a href="#图形渲染层–CAShapeLayer" class="headerlink" title="图形渲染层–CAShapeLayer"></a>图形渲染层–CAShapeLayer</h5><p>&ensp;&ensp;CAShapeLayer是用于绘制图形的layer层，可以用来绘制一些自定义的图形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// CAShapeLayer</span><br><span class="line">CAShapeLayer *shapeLayer = [CAShapeLayer layer];</span><br><span class="line">shapeLayer.position = CGPointMake(0, 0);</span><br><span class="line">CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">CGPathMoveToPoint(path, 0, 300, 600);</span><br><span class="line">CGPathAddLineToPoint(path, 0, 200, 500);</span><br><span class="line">CGPathAddLineToPoint(path, 0, 100, 600);</span><br><span class="line">shapeLayer.path = path;</span><br><span class="line">[self.view.layer addSublayer:shapeLayer];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上面的代码中CGMutablePathRef创建了iOS中的绘图路径对象，CGPathCreateMutable()方法创建了可变的绘图路径对象，CGPathMoveToPoint()方法设置绘图路径起点，CGPathAddLineToPoint()为绘图路径增加一条线。fillColor可以设置图像的填充色。还可以设置线条颜色，线条宽度等内容。</p><h5 id="文本绘制层–CATextLayer"><a href="#文本绘制层–CATextLayer" class="headerlink" title="文本绘制层–CATextLayer"></a>文本绘制层–CATextLayer</h5><p>&ensp;&ensp;CAtextLayer 用于进行视图上文本的绘制，UILable控件就是基于CATextLayer实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// CATextLayer</span><br><span class="line">CATextLayer *textLayer = [CATextLayer layer];</span><br><span class="line">textLayer.bounds = CGRectMake(0, 0, 320, 100);</span><br><span class="line">textLayer.position = CGPointMake(300, 700);</span><br><span class="line">textLayer.string = @&quot;这是一段文字&quot;;</span><br><span class="line">textLayer.fontSize = 25;</span><br><span class="line">textLayer.foregroundColor = [UIColor redColor].CGColor;</span><br><span class="line">textLayer.alignmentMode = kCAAlignmentLeft;</span><br><span class="line">[self.view.layer addSublayer:textLayer];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上面代码中设置了一段在layer上显示的文字。</p><h4 id="CAAnimation动画体系介绍"><a href="#CAAnimation动画体系介绍" class="headerlink" title="CAAnimation动画体系介绍"></a>CAAnimation动画体系介绍</h4><p>&ensp;&ensp;通过前面的介绍，开发者可以通过CALayer设置许多视图UI上的属性，CAAnimation框架作用就是将这些属性的变化都以动画的形式展示出来，由于CALayer相对UIView可以更加灵活的设置更多属性，因此CALayer层的动画操作更自由。下图中是CAAnimation及其子类的继承关系结构图:</p><p><img src="/2021/09/12/iOS动画基础/CAAnimation.png" alt="CAAnimation继承图"></p><p>&ensp;&ensp;CAAnimation分出的三个子类CAPropertyAnimation,CAAnimationGroup,CATranstion分别用于处理三种不同类型的动画.CAPropertyAnimation可以处理视图属性改变的动画。CAAnimationGroup可以处理组合动画，CATranstion可以处理转场动画。CAPropertyAnimation分出两个子类，CABasicAnimation和CAKeyframeAnimation，这两个子类分别用来处理基础类动画和关键帧动画。基础动画的一个子类CASpringAnimation处理阻尼动画。</p><p>&ensp;&ensp;CAAnimation中定义了两个主要属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CAMediaTimingFunction *timingFunction; //动画执行时序方式</span><br><span class="line">BOOL removedOnCompletion; //动画完成时是否移除对象</span><br></pre></td></tr></table></figure><p>&ensp;&ensp; timingFunction中的动画效果是线性执行，淡入，淡出等，点击查看源码可以查看有哪些效果。</p><p>&ensp;&ensp; CAPropertyAnimation定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface CAPropertyAnimation : CAAnimation</span><br><span class="line">///初始化方法</span><br><span class="line">+ (instancetype)animationWithKeyPath:(nullable NSString *)path;</span><br><span class="line">/// 需要执行动画的属性名称，比如背景色渐变动画path可以设置为backgroundColor</span><br><span class="line">@property(nullable, copy) NSString *keyPath;</span><br><span class="line">/// 动画的执行状态是否叠加到视图的原状态上 if true， 第二次动画执行从第一次终点开始</span><br><span class="line">@property(getter=isAdditive) BOOL additive;</span><br><span class="line">/// 动画是否重复执行</span><br><span class="line">@property(getter=isCumulative) BOOL cumulative;</span><br><span class="line">/// 这个属性和transform动画执行相关</span><br><span class="line">@property(nullable, strong) CAValueFunction *valueFunction;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="CABasicAnimation创建基础动画"><a href="#CABasicAnimation创建基础动画" class="headerlink" title="CABasicAnimation创建基础动画"></a>CABasicAnimation创建基础动画</h5><p>&ensp;&ensp;CABasicAnimation是动画框架中最常用的动画执行类，使用CABasicAnimation创建一个渐变色动画</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    /// gradient</span><br><span class="line">    CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;];</span><br><span class="line">    anim.fromValue = (id)[UIColor redColor].CGColor;</span><br><span class="line">    anim.toValue = (id)[UIColor blueColor].CGColor;</span><br><span class="line">    anim.duration = 2;</span><br><span class="line">    [_layer addAnimation:anim forKey:@&quot;&quot;];</span><br><span class="line">    /// rotate</span><br><span class="line">    CABasicAnimation *anima2 = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;];</span><br><span class="line">    anima2.fromValue = @0;</span><br><span class="line">    anima2.toValue = @200;</span><br><span class="line">    anima2.duration = 2;</span><br><span class="line">    anima2.valueFunction =[CAValueFunction functionWithName:kCAValueFunctionTranslateX];</span><br><span class="line">    [_layer addAnimation:anima2 forKey:@&quot;2&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CAKeyFrameAnimation创建关键帧动画"><a href="#CAKeyFrameAnimation创建关键帧动画" class="headerlink" title="CAKeyFrameAnimation创建关键帧动画"></a>CAKeyFrameAnimation创建关键帧动画</h5><p>&ensp;&ensp;通过关键帧创建的动画可以通过设置关键帧的方式自由控制整个动画的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    _layer = [CALayer layer];</span><br><span class="line">    _layer.bounds = CGRectMake(0, 0, 100, 100);</span><br><span class="line">    _layer.position = CGPointMake(160, 200);</span><br><span class="line">    _layer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    CAKeyframeAnimation *ani = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    ani.values = @[[NSValue valueWithCGPoint:CGPointMake(100, 200)],[NSValue valueWithCGPoint:CGPointMake(120, 300)],[NSValue valueWithCGPoint:CGPointMake(140, 400)],[NSValue valueWithCGPoint:CGPointMake(160, 800)]];</span><br><span class="line">    ///设置每段动画的时间占比，第一个位置到第二个位置占比0.5,第二个位置到第三个位置占比0.3</span><br><span class="line">    ani.keyTimes = @[@0,@0.5,@0.8,@1];</span><br><span class="line">    ani.duration = 3;</span><br><span class="line">    [_layer addAnimation:ani forKey:@&quot;&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;运行之后可以看到视图在三秒内进行了位置偏移，切速度逐渐变快</p><h5 id="CATranstion–layer层的转场动画"><a href="#CATranstion–layer层的转场动画" class="headerlink" title="CATranstion–layer层的转场动画"></a>CATranstion–layer层的转场动画</h5><p>&ensp;&ensp;CATransition动画用来处理CAlayer层的转场效果，可以在CALayer对象出现时展示动画效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    CALayer *layer = [CALayer layer];</span><br><span class="line">    layer.bounds = CGRectMake(0, 0, 100, 100);</span><br><span class="line">    layer.position = CGPointMake(100, 300);</span><br><span class="line">    layer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">    CATransition *ani = [CATransition animation];</span><br><span class="line">    ani.type = kCATransitionPush;</span><br><span class="line">    ani.subtype = kCATransitionFromRight;</span><br><span class="line">    ani.duration = 3;</span><br><span class="line">    [layer addAnimation:ani forKey:@&quot;&quot;];</span><br><span class="line">    [self.view.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp; 其中的type用来设置转场动画的类型，subType设置动画执行的方向。</p><h5 id="layer层组合动画–CAAnimationGroup"><a href="#layer层组合动画–CAAnimationGroup" class="headerlink" title="layer层组合动画–CAAnimationGroup"></a>layer层组合动画–CAAnimationGroup</h5><p>&ensp;&ensp;CAAnimationGroup类没有定义特定的动画类型，可以理解为是一个动画容器，在其中加入组合后的动画效果，进行展示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    CABasicAnimation *ani1 = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;];</span><br><span class="line">    ani1.toValue = (id)[UIColor blueColor].CGColor;</span><br><span class="line">    CABasicAnimation *ani2 = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    ani2.toValue = [NSValue valueWithCGPoint:CGPointMake(200, 400)];</span><br><span class="line">    CAAnimationGroup *group = [CAAnimationGroup animation];</span><br><span class="line">    CABasicAnimation *ani3 = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;];</span><br><span class="line">    ani3.fromValue = @0;</span><br><span class="line">    ani3.toValue = @M_PI;</span><br><span class="line">    ani3.valueFunction =[CAValueFunction functionWithName:kCAValueFunctionRotateZ];</span><br><span class="line">    ani3.beginTime = 2;</span><br><span class="line">    group.duration = 3;</span><br><span class="line">    group.animations = @[ani1,ani2,ani3];</span><br><span class="line">    [_layer addAnimation:group forKey:@&quot;&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上述代码给layer增加了三层动画，同时设置了旋转动画从第2秒才开始执行。</p><h5 id="CATransform3D动画"><a href="#CATransform3D动画" class="headerlink" title="CATransform3D动画"></a>CATransform3D动画</h5><p>&ensp;&ensp;任何CALayer对象都有transform属性，这个属性用来设置CALayer对象数学变换的效果。可以实现平移，旋转，放缩等动画效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    UIView *view = [UIView new];</span><br><span class="line">    view.frame = CGRectMake(100, 200, 100, 100);</span><br><span class="line">    view.backgroundColor = [UIColor redColor];</span><br><span class="line">    UIView *view2 = [[UIView alloc]initWithFrame:CGRectMake(100, 200, 100, 100)];</span><br><span class="line">    view2.backgroundColor = [UIColor blueColor];</span><br><span class="line">    /// x平移100 y平移100，z平移0</span><br><span class="line">    CATransform3D trans = CATransform3DTranslate(view2.layer.transform, 100, 100, 0);</span><br><span class="line">    /// x方向缩小0.5，y方向放大2</span><br><span class="line">    CATransform3D trans2 = CATransform3DScale(trans, 0.5, 2, 0);</span><br><span class="line">    ///旋转变换沿着z轴旋转45度</span><br><span class="line">    CATransform3D trans3 = CATransform3DRotate(trans2, M_PI_4, 0, 0, 1);</span><br><span class="line">    view2.layer.transform = trans3;</span><br><span class="line">    /// 用于将要变换的效果进行翻转</span><br><span class="line">    view.layer.transform = CATransform3DInvert(trans2);</span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line">    [self.view addSubview:view2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上面代码在同样位置创建了两个view，然后使用平移变换将其中一个进行了移动。trans2给图像增加了放缩变换，trans3给图像增加了z轴的旋转变换，CATransform3DInvert给将要增加的效果进行翻转。<br>&ensp;&ensp;效果如下<br><img src="/2021/09/12/iOS动画基础/CATransform3D.png" alt="CATransform3D"></p><h4 id="粒子动画效果"><a href="#粒子动画效果" class="headerlink" title="粒子动画效果"></a>粒子动画效果</h4><p>&ensp;&ensp;宏观上有序的，轨迹确定的规则动画可以从过layer层和UIViewAnimation实现，对于微观的，无序的，轨迹无法预测的随机动画，可以使用CAEmitterLayer实现。CAEmitterLayer可以实现效果炫酷的粒子动画，粒子效果分为两部分，一部分是粒子发射器，用于配制粒子的整体效果，另一部分是粒子单元，用于配制粒子的具体属性。CAEmitterLayer继承子CALayer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor blackColor];</span><br><span class="line">    _emitterLayer = [[CAEmitterLayer alloc] init];</span><br><span class="line">    /// 粒子发射器在xy平面的位置</span><br><span class="line">    _emitterLayer.emitterPosition = CGPointMake(self.view.frame.size.width/2, self.view.frame.size.height - 20);</span><br><span class="line">    /// 粒子发射器的大小</span><br><span class="line">    _emitterLayer.emitterSize = CGSizeMake(self.view.frame.size.width-100, 20);</span><br><span class="line">    _emitterLayer.renderMode = kCAEmitterLayerAdditive;</span><br><span class="line">    </span><br><span class="line">    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 10, 10)];</span><br><span class="line">    view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    view.layer.cornerRadius = 5;</span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line">    UIImage *img = [self imageFromView:view];</span><br><span class="line">    /// 火焰发射单元</span><br><span class="line">    /// 粒子单元</span><br><span class="line">    CAEmitterCell *fire = [CAEmitterCell emitterCell];</span><br><span class="line">    /// 粒子的创建速率 默认1/s</span><br><span class="line">    fire.birthRate = 800;</span><br><span class="line">    /// 粒子存活时间，默认1s</span><br><span class="line">    fire.lifetime = 3.0;</span><br><span class="line">    /// 粒子的生存时间容差</span><br><span class="line">    fire.lifetimeRange = 1.5;</span><br><span class="line">    fire.color = [UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1].CGColor;</span><br><span class="line">    fire.name = @&quot;fire&quot;;</span><br><span class="line">    fire.contents = (id)img.CGImage;</span><br><span class="line">    /// 粒子速率</span><br><span class="line">    fire.velocity = 160;</span><br><span class="line">    /// 粒子速率容差</span><br><span class="line">    fire.velocityRange = 80;</span><br><span class="line">    /// 粒子在xy平面的发射角度</span><br><span class="line">    fire.emissionLongitude = M_PI + M_PI_2;</span><br><span class="line">    /// 粒子发射角度容差</span><br><span class="line">    fire.emissionRange = M_PI_2;</span><br><span class="line">    /// 粒子缩放速度</span><br><span class="line">    fire.scaleSpeed = 0.3;</span><br><span class="line">    /// 粒子旋转度</span><br><span class="line">    fire.spin = 0.2;</span><br><span class="line">    /// 烟雾</span><br><span class="line">    CAEmitterCell *smoke = [CAEmitterCell emitterCell];</span><br><span class="line">    smoke.birthRate = 800;</span><br><span class="line">    smoke.lifetime = 6.0;</span><br><span class="line">    smoke.lifetimeRange = 1.5;</span><br><span class="line">    smoke.color = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.05].CGColor;</span><br><span class="line">    smoke.name = @&quot;smoke&quot;;</span><br><span class="line">    smoke.contents = (id)img.CGImage;</span><br><span class="line">    smoke.velocity = 250;</span><br><span class="line">    smoke.velocityRange = 100;</span><br><span class="line">    smoke.emissionLongitude = M_PI+M_PI_2;</span><br><span class="line">    smoke.emissionRange = M_PI_2;</span><br><span class="line">    _emitterLayer.emitterCells = [NSArray arrayWithObjects:smoke,fire, nil];</span><br><span class="line">    [self.view.layer addSublayer:_emitterLayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)imageFromView:(UIView *)view &#123;</span><br><span class="line">    CGSize size = view.frame.size;</span><br><span class="line">    UIGraphicsBeginImageContext(size);</span><br><span class="line">    [view.layer renderInContext:UIGraphicsGetCurrentContext()];</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上述注释中解释了CAEmitterLayer和CAEmitterCell的部分属性，可以点击相关源码查看详细的定义。 最终的效果如下所示：</p><p><img src="/2021/09/12/iOS动画基础/fire.png" alt="fire"></p><h4 id="播放动态gif图"><a href="#播放动态gif图" class="headerlink" title="播放动态gif图"></a>播放动态gif图</h4><p>&ensp;&ensp;由于许多应用在进行某些需求的动画处理时会使用播放GIF图的方式，因此把这一技术也归纳为iOS动画开发技术。一般有两种方式进行GIF图的播放，一种是将其渲染为UIWebView进行播放，一种是将GIF文件中存储的图片数据与图片信息获取出来，使用UIImageView的帧动画进行播放。</p><h5 id="使用UIWebView进行GIF图动态播放"><a href="#使用UIWebView进行GIF图动态播放" class="headerlink" title="使用UIWebView进行GIF图动态播放"></a>使用UIWebView进行GIF图动态播放</h5><p>&ensp;&ensp;GIF图渲染为UIWebView进行渲染具有简单，效能强的特点，缺点是加载GIF图需要一定的时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    ///UIWebView已经废弃，使用WKWebView</span><br><span class="line">    WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(100, 200, 280, 300)];</span><br><span class="line">    /// 注意gif资源不能放在Assests目录下</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;mygif&quot; ofType:@&quot;gif&quot;]];</span><br><span class="line">    [webView loadData:data MIMEType:@&quot;image/gif&quot; characterEncodingName:@&quot;UTF-8&quot; baseURL:[NSURL fileURLWithPath:NSTemporaryDirectory()]];</span><br><span class="line">    [self.view addSubview:webView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用UIImageView帧动画播放gif图"><a href="#使用UIImageView帧动画播放gif图" class="headerlink" title="使用UIImageView帧动画播放gif图"></a>使用UIImageView帧动画播放gif图</h5><p>&ensp;&ensp; gif图是一组包含图片及其信息数据的文件，其中记录着各张图片播放时长等信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/// 使用uiimageView播放gif图</span><br><span class="line">   UIImageView *imgView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 500, 280, 300)];</span><br><span class="line">   [self.view addSubview:imgView];</span><br><span class="line">   NSString *dataPath = [[NSBundle mainBundle] pathForResource:@&quot;mygif&quot; ofType:@&quot;gif&quot;];</span><br><span class="line">   CGImageSourceRef source = CGImageSourceCreateWithURL((CFURLRef)[NSURL fileURLWithPath:dataPath], NULL);</span><br><span class="line">   size_t count = CGImageSourceGetCount(source);</span><br><span class="line">   CGFloat allTime = 0;</span><br><span class="line">   NSMutableArray *imageArray = [[NSMutableArray alloc] init];</span><br><span class="line">   NSMutableArray *timeArray = [[NSMutableArray alloc] init];</span><br><span class="line">   NSMutableArray *heightArray = @[].mutableCopy;</span><br><span class="line">   NSMutableArray *widthArray = @[].mutableCopy;</span><br><span class="line">   for (size_t i = 0; i&lt;count; i++) &#123;</span><br><span class="line">       CGImageRef image = CGImageSourceCreateImageAtIndex(source, i, NULL);</span><br><span class="line">       [imageArray addObject:(__bridge UIImage *)image];</span><br><span class="line">       CGImageRelease(image);</span><br><span class="line">       /// 图片信息</span><br><span class="line">       NSDictionary *info = (__bridge NSDictionary *)CGImageSourceCopyPropertiesAtIndex(source, i, NULL);</span><br><span class="line">       CGFloat width = [[info objectForKey:(__bridge NSString *)kCGImagePropertyPixelWidth] floatValue];</span><br><span class="line">       CGFloat height = [[info objectForKey:(__bridge NSString *)kCGImagePropertyPixelHeight] floatValue];</span><br><span class="line">       [widthArray addObject:[NSNumber numberWithFloat:width]];</span><br><span class="line">       [heightArray addObject:[NSNumber numberWithFloat:height]];</span><br><span class="line">       NSDictionary *timeDic = [info objectForKey:(__bridge NSDictionary *)kCGImagePropertyGIFDictionary];</span><br><span class="line">       CGFloat time = [[timeDic objectForKey:(__bridge NSString *)kCGImagePropertyGIFDelayTime] floatValue];</span><br><span class="line">       allTime +=time;</span><br><span class="line">       [timeArray addObject:[NSNumber numberWithFloat:time]];</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;contents&quot;];</span><br><span class="line">   NSMutableArray *times = @[].mutableCopy;</span><br><span class="line">   CGFloat currentTime = 0;</span><br><span class="line">   for (int i=0; i&lt;imageArray.count; i++) &#123;</span><br><span class="line">       [times addObject:[NSNumber numberWithFloat:currentTime/allTime]];</span><br><span class="line">       currentTime += [timeArray[i] floatValue];</span><br><span class="line">   &#125;</span><br><span class="line">   [animation setKeyTimes:times];</span><br><span class="line">   [animation setValues:imageArray];</span><br><span class="line">   [animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]];</span><br><span class="line">   animation.repeatCount = MAXFLOAT;</span><br><span class="line">   animation.duration = allTime;</span><br><span class="line">   [imgView.layer addAnimation:animation forKey:@&quot;gifAnimation&quot;];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;最后效果和前面的WkWebView相同，展示了一个gif图。不过代码比较繁琐。从中也可以看出，如果要对gif图中的某一部分进行操作也是可以通过这种方式实现的。</p><p><strong>以上代码demo请参考<a href="https://github.com/SJ110/iOS-animation-demo" target="_blank" rel="noopener">这里</a></strong></p><h4 id="小游戏Flappy-Bird设计"><a href="#小游戏Flappy-Bird设计" class="headerlink" title="小游戏Flappy Bird设计"></a>小游戏Flappy Bird设计</h4><p>&ensp;&ensp; flppy bird小游戏是对iOS动画的一个小应用，也是参考书中的一个小demo，其中小鸟的动作通过动画实现。需要抓住的点是背景的移动是通过定时器实现的，在1/60秒内，屏幕上的背景会向左移动一个像素，从而实现了背景的移动。给小鸟所在的屏幕增加一个点击事件，每次点击小鸟的坐标都可以变化一定的像素。通过随机数设置障碍物的位置。下面是两张截图: 源码请参考<a href="https://github.com/SJ110/flappy-bird" target="_blank" rel="noopener">这里</a></p><p><img src="/2021/09/12/iOS动画基础/flappybird1.png" alt="flappybird1"></p><p><img src="/2021/09/12/iOS动画基础/flappybird2.png" alt="flappybird2"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;这边博客主要是总结一下最近看到iOS动画开发的一些基础知识。主要包含如下一些知识点。主要参考自&lt;a href=&quot;https://weread.qq.com/web/reader/56932a20719b1fcb569e111kf4532c00231f457c545ad3c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《iOS开发实战：从入门到上架APPsotre》&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1、使用UIImageView播放图片组动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2、使用block回调创建UIView层过渡动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3、使用block回调创建UIView层转场动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4、使用commit方式创建UIView层过渡动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5、使用commit方式创建UIView层转场动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6、CAlayer层在UI开发中的应用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7、各种CALayer子类的用法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8、coreAnimation核心动画框架的用法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9、视图的transform变换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10、粒子效果动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11、iOS中播放GIF动态图的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12、Flappy Bird动画小游戏&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOSruntime之method_exchange</title>
    <link href="http://yoursite.com/2021/09/05/iOSruntime%E4%B9%8Bmethod-exchange/"/>
    <id>http://yoursite.com/2021/09/05/iOSruntime%E4%B9%8Bmethod-exchange/</id>
    <published>2021-09-05T06:33:54.000Z</published>
    <updated>2021-11-19T06:53:11.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;最近看到工程中对于容器中的生命周期方法hook比较多，有些甚至发生了重复hook的操作。后来组内大佬一同分析之后，无论这个方法背hook了多少次，<br>&ensp;&ensp;所有被hook的方法都是会一直被执行下去的，我之前听的大概差不多懂了，但是今天还是写个小demo见证下效果。</p><a id="more"></a><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>&ensp;&ensp;一般来讲分类的作用是是给一些系统提供的类别增加一些扩展的功能，这样在可以在不侵入原本代码的基础上，做到能力的扩展。举一个例子，想要按钮有一个点击之后按钮晃动的功能，就可以给UIButton增加一个shaking的分类方法，每次在点击按钮之后调用shaking方法。这样这个shaking的能力相当于独立了出来，很方便能够被复用。</p><p>&ensp;&ensp;当然，上面说的都不是重点。iOS方法hook经常也在分类中使用，一般的方式是在+load方法中进行方法交换, load方法在app启动时就会调用，这样可以保证交换的时机尽可能的早。交换之后调用原方法时就相当于调用了交换后的方法，比如下demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    Method originalM = class_getInstanceMethod([self class], @selector(viewDidAppear:));</span><br><span class="line">    Method destinationM = class_getInstanceMethod([self class], @selector(destinationViewDidAppear:));</span><br><span class="line">    BOOL didAddMethod = class_addMethod([self class], @selector(destinationViewDidAppear:), method_getImplementation(destinationM), method_getTypeEncoding(destinationM));</span><br><span class="line">    if (!didAddMethod) &#123;</span><br><span class="line">        method_exchangeImplementations(originalM, destinationM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)destinationViewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    NSLog(@&quot;exchange method1,%@&quot;,NSStringFromClass([self class]));</span><br><span class="line">    [self destinationViewDidAppear:animated];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;其中的destinationViewDidAppear就是交换后的方法。注意到这个方法末尾的调用并不是重复调用这个方法，而是去调用了原方法，这里有点乱，应该这么说，交换后的方法我们不会主动调用，而是去调用原本的方法（此时原方法已经被交换），然后调用完之后继续调用交换方法（此时交换的方法已经是原方法)。 整个过程就相当于是你去公司上班的路上顺便买了早饭然后在继续上路。买早饭这个动作就是交换后的方法。做完在回到原本的路径上继续往下。这就大概是方法交换的整个流程。</p><h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>&ensp;&ensp;多次方法交换后为何每个都继续执行了？下图说明整个过程</p><p><img src="/2021/09/05/iOSruntime之method-exchange/0.png" alt="图0"></p><p><img src="/2021/09/05/iOSruntime之method-exchange/1.png" alt="图1"></p><p><img src="/2021/09/05/iOSruntime之method-exchange/2.png" alt="图2"></p><p>&ensp;交换完成后就变成了这个样子，所以当执行viewDidAppear时其实执行的是exmethod2，然后method2在调用自身，其实是执行method1，然后method1再调用自身，其实执行的是viewDidAppear。</p><p>&ensp;&ensp;也就是说谁先交换，谁就后执行。但是推荐不要这样做，因为每个分类中的load方法执行顺序不确定，所以那个方法先被交换是不确定的。</p><p>&ensp;&ensp;但是要注意每次需要交换的方法不要重名，不然就相当于两次交换回到最初的样子了。两个交换后的方法都不会被执行。</p><p>代码截图如下：</p><p><img src="/2021/09/05/iOSruntime之method-exchange/3.png" alt="图3"></p><p><img src="/2021/09/05/iOSruntime之method-exchange/4.png" alt="图4"></p><p>&ensp;&ensp;执行结果和预期一致。</p><p><img src="/2021/09/05/iOSruntime之method-exchange/5.png" alt="图5"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;最近看到工程中对于容器中的生命周期方法hook比较多，有些甚至发生了重复hook的操作。后来组内大佬一同分析之后，无论这个方法背hook了多少次，&lt;br&gt;&amp;ensp;&amp;ensp;所有被hook的方法都是会一直被执行下去的，我之前听的大概差不多懂了，但是今天还是写个小demo见证下效果。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>SD_webImage调用链路探索</title>
    <link href="http://yoursite.com/2021/09/05/SD-webImage%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2021/09/05/SD-webImage%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E6%8E%A2%E7%B4%A2/</id>
    <published>2021-09-05T06:05:18.000Z</published>
    <updated>2021-09-05T06:21:25.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;关于sd_webImage是这样介绍的。Asynchronous image downloader with cache support with an UIImageView category. (一个异步下载且支持缓存的uiimageview分类)。</p><p>很多时候图片资源都是作为一个远程资源。为了加载图片需要根据url（统一资源定位符）去获取资源。我以前曾亲身体会到使用</p><a id="more"></a> <h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:url]]];///1</span><br><span class="line"> </span><br><span class="line">[self.imageView sd_setImageWithURL:[NSURL URLWithString:self.imageUrl]];///2</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;两者带来极大不同效果。方法1是在主线程中货源图片资源并且加载，如果把这个事情放到列表中去做，滑动列表时会出现明显的卡顿效果，这是因为主线程因为加载资源被阻塞了。</p><p>&ensp;&ensp;使用方法2就是把资源获取通过异步的方式放在子线程中处理，取得之后通过回调的方式在加载图片。列表滑动会变得相当流程。</p><p>&ensp;&ensp;在对SD_webImage常用方法进行探索前，可以先明确一下实现这样一个异步加载器需要些什么。<font color="Crimson">首先是”异步“，可以猜测其中关于根据图片url获取图片的操作不是在主线程进行的。然后是“缓存”，一个常见的缓存包含了内存缓存和磁盘缓存。所以在第一次获取到资源后应该会有一个类似cache保存的操作，减少下次重新下载耗费的时间。也许还会有一个磁盘缓存，app下次启动时如果发现已经存在这个资源也需要再次下载了。要做到这些需要一些缓存策略之类的东西。然后就是”分类”，这是一个对于uiimageView的分类，提供了一些新的分类方法。所以整个流程大概如下，uiimageview在加载图片时首先判断这个图片是否在内存中有无，有的话直接返回，没有的话再去本地路径中查找，有的话就返回，没有再去发起get请求，获取图片资源数据。获取之后再把数据存到内存中，同时存到本地。然后把数据通过回调返回。下面根据一次调用过程去看整个链路是如何工作的。</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">这是我们常用的加载图片的方法。这个方法暴露在 &lt;UIImageView+WebCache.h&gt;中，到实现文件查看，发现，几个同类型的方法最后都走向同一个方法</span><br><span class="line"></span><br><span class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</span><br><span class="line">                  placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                           context:(nullable SDWebImageContext *)context</span><br><span class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(nullable SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(nullable SDInternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这是uiview分类中的方法，因为作者也为buButton和NSButton提供了异步加载图片的能力，所以在他们共同的父类中扩展方法可以使其都可以调用。</p><p>&ensp;&ensp;在这个方法里面首先是一些上下文的操作，以UIImageview为例，首先尝试获取operationkey，对这个operationkey的解释是（pass through the operation key to downstream, which can used for tracing operation or image view class），意思就是方便追踪正在操作的视图类。获取到之后会</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.sd_latestOperationKey = validOperationKey;</span><br><span class="line">[self sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;意思就是如果validOperationKey对应的视图对象正在下载图片，会取消正在下载的操作。<font color="Crimson">感觉这部分理解起来是要表达这么一个意思，因为对于不同的UIImageview对象会生成相同的operationkey，所以每次只会对一个uiimageview对象进行下载操作。（刚才想了下，我的想法有问题，虽然不通的UIImageview对象生成了相同的key，但是不同的对象应该持有的是不同的操作下载队列，不同的uiimageview对象是否同时在下载应该是NSURLSession关心的事情</font>接下来就是把站位图放到视图上。接下来到调用下载方法之间还有一堆操作，大致理解一下就是在下载的过程中，增加一个指示器，根据下载进度更新指示器，完成之后移除指示器。</p><p> &ensp;&ensp;最主要的工作就是下面这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (SDWebImageCombinedOperation *)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                          options:(SDWebImageOptions)options</span><br><span class="line">                                          context:(nullable SDWebImageContext *)context</span><br><span class="line">                                         progress:(nullable SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                                        completed:(nonnull SDInternalCompletionBlock)completedBlock;</span><br><span class="line">///completedBlock</span><br><span class="line"> </span><br><span class="line">typedef void(^SDInternalCompletionBlock)(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL);</span><br><span class="line"> </span><br><span class="line">/// Image Cache Type</span><br><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">  </span><br><span class="line">    SDImageCacheTypeNone,</span><br><span class="line"> </span><br><span class="line">    SDImageCacheTypeDisk,</span><br><span class="line"> </span><br><span class="line">    SDImageCacheTypeMemory,</span><br><span class="line"> </span><br><span class="line">    SDImageCacheTypeAll</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这个方法由SDWebImageManager进行管理，completedBlock中有很多的参数，特别关注下其中的cacheType，查看枚举定义，很明显的看出后面很根据cachetype的值决定是否下载。下载完成的会调用也是处理一些是否下载成功，是否出现错误的保护操作。继续进到下载的方法中查看，首先是对url的一些校验，最关键的还是其中的这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    // Start the entry to load image from cache</span><br><span class="line">    [self callCacheProcessForOperation:operation url:url options:result.options context:result.context progress:progressBlock completed:completedBlock];  ///call</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// Query normal cache process</span><br><span class="line">- (void)callCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation</span><br><span class="line">                                 url:(nonnull NSURL *)url</span><br><span class="line">                             options:(SDWebImageOptions)options</span><br><span class="line">                             context:(nullable SDWebImageContext *)context</span><br><span class="line">                            progress:(nullable SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                           completed:(nullable SDInternalCompletionBlock)completedBlock; /// configeration</span><br><span class="line"> </span><br><span class="line">///</span><br><span class="line">    // Check whether we should query cache</span><br><span class="line">    BOOL shouldQueryCache = !SD_OPTIONS_CONTAINS(options, SDWebImageFromLoaderOnly);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这就是前面说的查询缓存的方法，根据shouldQueryCache 决定是否查询缓存，假定命中了需要查询缓存，然后就是根据url和context查询key值，在根据key值去查询。</p><p>///查询缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (id&lt;SDWebImageOperation&gt;)queryImageForKey:(NSString *)key</span><br><span class="line">                                    options:(SDWebImageOptions)options</span><br><span class="line">                                    context:(SDWebImageContext *)context</span><br><span class="line">                                  cacheType:(SDImageCacheType)cacheType</span><br><span class="line">                                 completion:(SDImageCacheQueryCompletionBlock)completionBlock</span><br><span class="line"> </span><br><span class="line">/// Policy for cache operation</span><br><span class="line">typedef NS_ENUM(NSUInteger, SDImageCachesManagerOperationPolicy) &#123;</span><br><span class="line">    SDImageCachesManagerOperationPolicySerial, // process all caches serially (from the highest priority to the lowest priority cache by order) 串行</span><br><span class="line">    SDImageCachesManagerOperationPolicyConcurrent, // process all caches concurrently。并行</span><br><span class="line">    SDImageCachesManagerOperationPolicyHighestOnly, // process the highest priority cache only 高优先级</span><br><span class="line">    SDImageCachesManagerOperationPolicyLowestOnly // process the lowest priority cache only 低优先级</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;到这里，发现东西越来越杂，看的有点头疼了。但是主要过程大致如下：</p><p>&ensp;&ensp;如果caches为空，直接返回，如果cache中一个值，直接查询，否则根据策略决定使用何种方式查询。选择默认的 SDImageCachesManagerOperationPolicySerial策略看下内部，内部主要调用的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id&lt;SDWebImageOperation&gt;)queryImageForKey:(nullable NSString *)key</span><br><span class="line">                                             options:(SDWebImageOptions)options</span><br><span class="line">                                             context:(nullable SDWebImageContext *)context</span><br><span class="line">                                           cacheType:(SDImageCacheType)cacheType</span><br><span class="line">                                          completion:(nullable SDImageCacheQueryCompletionBlock)completionBlock;</span><br><span class="line">///最终查询方法</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options context:(nullable SDWebImageContext *)context cacheType:(SDImageCacheType)queryCacheType done:(nullable SDImageCacheQueryCompletionBlock)doneBlock;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;在最终内存查询的方法中，就是找到回调中带有image数据，没找到，回调中数据为nil，在末尾终于被我找到了，shouldQueryMemoryOnly，如果要执行disk查找的话，  shouldQueryMemoryOnly返回no。最终都会返回一个doneBlock给外部。好，现在回到外层，如果一开始就认为不用查询缓存，就会执行下载操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Download process</span><br><span class="line">- (void)callDownloadProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation</span><br><span class="line">                                    url:(nonnull NSURL *)url</span><br><span class="line">                                options:(SDWebImageOptions)options</span><br><span class="line">                                context:(SDWebImageContext *)context</span><br><span class="line">                            cachedImage:(nullable UIImage *)cachedImage</span><br><span class="line">                             cachedData:(nullable NSData *)cachedData</span><br><span class="line">                              cacheType:(SDImageCacheType)cacheType</span><br><span class="line">                               progress:(nullable SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                              completed:(nullable SDInternalCompletionBlock)completedBlock;</span><br><span class="line"> </span><br><span class="line">/// 接口请求图片</span><br><span class="line">- (nullable id&lt;SDWebImageOperation&gt;)requestImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                options:(SDWebImageOptions)options</span><br><span class="line">                                                context:(nullable SDWebImageContext *)context</span><br><span class="line">                                               progress:(nullable SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                                              completed:(nullable SDImageLoaderCompletedBlock)completedBlock;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这一步就会去调用接口请求数据了，这个方法里面还有一个for循环，所以应该还存在并行调用的场景，最终的下载方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                   context:(nullable SDWebImageContext *)context</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"> </span><br><span class="line">///存储</span><br><span class="line"> // Continue store cache process</span><br><span class="line">[self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;通过这个方法会去下载图片，如果下载成功，就会调用存储方法：存储之后在讲对应的回调返回出去。</p><p>&ensp;&ensp;以上就是一次图片下载经过的整个过程，大致流程和一开始预测的过程类似。但是其中包含了设计者相当多的设计思路，尽量保证每一种场景case都考虑在内，所以其中if，esle场景判断相当多。</p><p>&ensp;&ensp;其次是其中代码的管理也相当规范，可以看到暴露给用户的就是一个简单的sd_setImageWithURL方法，但是内部完成的动作可以说是相当复杂。而且其中还有很多我当前没理解到的地方，比如说context的管理， 各个manager对于多种operation的管理。还有内部代码多是使用block回调处理的，很容易一下就看不明白了。</p><p>&ensp;&ensp;只能说这次缕了一下简单的过程，其中代码管理，各个模块协调的部分还需要继续往下看才行。</p><p>&ensp;&ensp;参考<br><a href="https://github.com/SJ110/analyze/blob/master/contents/SDWebImage/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20—%20SDWebImage.md" target="_blank" rel="noopener">https://github.com/SJ110/analyze/blob/master/contents/SDWebImage/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20—%20SDWebImage.md</a> </p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;关于sd_webImage是这样介绍的。Asynchronous image downloader with cache support with an UIImageView category. (一个异步下载且支持缓存的uiimageview分类)。&lt;/p&gt;
&lt;p&gt;很多时候图片资源都是作为一个远程资源。为了加载图片需要根据url（统一资源定位符）去获取资源。我以前曾亲身体会到使用&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>masonry链式调用探索</title>
    <link href="http://yoursite.com/2021/08/23/masonry%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2021/08/23/masonry%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%8E%A2%E7%B4%A2/</id>
    <published>2021-08-23T10:31:19.000Z</published>
    <updated>2021-08-23T12:21:26.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;最近刚好看了一篇对masonry这个库做了分析的文章，讲的挺清楚，有兴趣可以参考。<br><a href="https://github.com/SJ110/analyze/blob/master/contents/Masonry/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20---%20Masonry.md" target="_blank" rel="noopener">https://github.com/SJ110/analyze/blob/master/contents/Masonry/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20---%20Masonry.md</a><br>看完之后虽然对于这个链式调用的过程有了一定的认识，但是想要搞清楚还是需要实际跟着这个过程走一下。</p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>&ensp;&ensp;以下是对一个uiview构建布局时的masonry代码。下面分析其调用过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.bottomBackGroundImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.left.right.bottom.mas_equalTo(self);</span><br><span class="line">    make.top.mas_equalTo(self.mas_top).offset(35+KSafeAreaTopHeight);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (NSArray *)mas_makeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这个方法是定义在uiview的一个分类中的，这种方式便于只需要引入masonry头文件后就可以使用masonry的相关功能。看下内部实现，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    self.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    return [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;首先是将 translatesAutoresizingMaskIntoConstraints 这个属性设置为NO，这样之后使用autolayout布局才会生效。<br>然后是初始化了一个MASConstraintMaker对象，这个maker对象初始化时会创建一个narray数组叫做constraints,这个数组就用来保存block中编写的约束内容。用来最后布局。<br>block中是用来布局约束的代码。</p><p>[constraintMaker install] 回去执行block回调中拿到的约束布局数据，去进行布局。</p><p>make.left.right.bottom.mas_equalTo(self);</p><p>这个链式调用需要重点关注一下，</p><p>进入MASConstraintMaker.m看其中的实现，发现其中的约束都是通过调用</p><p>addConstraintWithLayoutAttribute来添加的，而每一个方向的约束都会返回一个MASConstraint 对象，所以返回的每个MASConstraint对象都可以继续往下调用，但是其中每一次的调用对于下一次</p><p>来说是无感的。</p><p>addConstraintWithLayoutAttribute方法最后会调用</p><ul><li>(MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute;</li></ul><p>这个方法内会将传递进来的布局属性layoutAttribute 创建一个 MASViewAttribute对象，在用 MASViewAttribute创建一个约束对象 MASViewConstraint。然后将这个约束对象放到之前的数组constraints中。</p><p>对于make.left.right.bottom.mas_equalTo(self);来说，前三个链式调用结束之后因为返回的MASConstraint对象，所以继续往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(id))equalTo &#123;</span><br><span class="line">    return ^id(id attribute) &#123;</span><br><span class="line">        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (MASConstraint * (^)(id))mas_equalTo &#123;</span><br><span class="line">    return ^id(id attribute) &#123;</span><br><span class="line">        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;可以看到mas_equalTo和equalTo实现其实是完全一致的。这个方法接受一个id对象，返回一个MASConstraint的block对象，到这里可以说已经很混乱了，先是链式调用，之后又是block类型的方法。</p><p>休息一下再看。</p><p>&ensp;&ensp;继续往下看到内部调用了一个equalToWithRelation的block，这个所以这个block是定义在 MASConstraint+Private.h中，在 MASConstraint.h和其子类中的，之前没注意到我还觉得奇怪，为什么父类中的私有方法会被子类调用。原来是定义在了一个第三方的类中。找到MASConstraint的子类 MASViewConstraint.m中，</p><ul><li>(MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation； 方法也是一个block函数，接受一个id类型和一个 NSLayoutRelation的参数，他会把传进来的两个赋值给MASConstraint的两个属性，然后在返回自身实例。</li></ul><p>&ensp;&ensp;再看下MASViewConstraint这个类中的一个set方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSecondViewAttribute:(id)secondViewAttribute &#123;</span><br><span class="line">    if ([secondViewAttribute isKindOfClass:NSValue.class]) &#123;</span><br><span class="line">        [self setLayoutConstantWithValue:secondViewAttribute];</span><br><span class="line">    &#125; else if ([secondViewAttribute isKindOfClass:MAS_VIEW.class]) &#123;</span><br><span class="line">        _secondViewAttribute = [[MASViewAttribute alloc] initWithView:secondViewAttribute layoutAttribute:self.firstViewAttribute.layoutAttribute];</span><br><span class="line">    &#125; else if ([secondViewAttribute isKindOfClass:MASViewAttribute.class]) &#123;</span><br><span class="line">        _secondViewAttribute = secondViewAttribute;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSAssert(NO, @&quot;attempting to add unsupported attribute: %@&quot;, secondViewAttribute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;可以看到其不仅可以接受一个value类型的变量，也可以接受一个uiview类型的变量和MASViewAttribute类型的变量这也是为什么我们在链式调用时可以mas_equalTo(self),mas_equalTo(20),mas_equalTo(self.mas_left),但是mas_equalTo(self.left)就会报错，因为self.left类型是MASConstraint类型。</p><p>&ensp;&ensp;这一切动作都结束之后，此时sconstraints数组中已经包含了约束布局数据，进行install，</p><p>&ensp;&ensp;其中的核心方法时系统提供的对两个视图进行约束的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(nullable id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c。</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;还会做一些前置判断，比如要约束的视图a，是否能找到到其相对布局的视图b的共同父视图。已经进行过约束，则直接返回，需要更新约束，将新的约束替换旧的约束等等。到此工作才算完全结束。</p><p>&ensp;&ensp;总结：和自己直接去读源码相比，有了一定的调用链路，加上别人的分析之后，在看源码变得方便许多。这是一个不错的学习源码的方式。不过不要完全把别人的观点带过来，别人的观点也可能出错。</p><p>&ensp;&ensp;再有就是masonry的代码确实有点复杂。看的头大</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;最近刚好看了一篇对masonry这个库做了分析的文章，讲的挺清楚，有兴趣可以参考。&lt;br&gt;&lt;a href=&quot;https://github.com/SJ110/analyze/blob/master/contents/Masonry/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20---%20Masonry.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SJ110/analyze/blob/master/contents/Masonry/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20---%20Masonry.md&lt;/a&gt;&lt;br&gt;看完之后虽然对于这个链式调用的过程有了一定的认识，但是想要搞清楚还是需要实际跟着这个过程走一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS属性修饰符copy</title>
    <link href="http://yoursite.com/2021/08/23/ios%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6copy/"/>
    <id>http://yoursite.com/2021/08/23/ios%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6copy/</id>
    <published>2021-08-23T10:19:31.000Z</published>
    <updated>2021-11-19T06:51:29.988Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>&ensp;&ensp;iOS开发中，对于NSString，NSDictionary，NSArray一般都会使用copy来进行修饰，其实用strong的话也没有问题。只是copy修饰在进行赋值时会进行内存的拷贝，相当于赋值之后和被赋值的对象指向不同的内存地址。这样做的好处是防止修改了被赋值对象（等号右边）导致了等号左边的属性发生变化。</p><a id="more"></a><p>&ensp;&ensp;当然如果属性本身是对外不可见的，怎么修改都放在.m文件中，这样外界就无法修改类的属性，类的属性只受内部控制，这样可以使用strong来修饰，不过也只是降低了被修改的风险而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) SJPAnimationViewController *vc;</span><br><span class="line">@property (nonatomic, copy) NSString *str;</span><br><span class="line">@property (nonatomic, copy) NSDictionary *dict;</span><br><span class="line">@property (nonatomic, copy) NSArray *arr;</span><br><span class="line">//@property (nonatomic, strong) NSString *str;</span><br><span class="line">//@property (nonatomic, strong) NSDictionary *dict;</span><br><span class="line">//@property (nonatomic, strong) NSArray *arr;</span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">@implementation SJPTabBarController</span><br><span class="line"> </span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self initTabBarVc];</span><br><span class="line">    NSMutableString *mStr = [NSMutableString stringWithString:@&quot;123&quot;];</span><br><span class="line">    NSMutableDictionary *mDict = [NSMutableDictionary dictionaryWithDictionary:@&#123;@&quot;test1&quot;:@&quot;123&quot;,@&quot;test2&quot;:@&quot;456&quot;&#125;];</span><br><span class="line">    NSMutableArray *mArr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;]];</span><br><span class="line">    self.str = mStr;</span><br><span class="line">    self.dict = mDict;</span><br><span class="line">    self.arr = mArr;</span><br><span class="line">    /// 修改数据</span><br><span class="line">    mStr.string = @&quot;12345&quot;;</span><br><span class="line">    [mDict removeObjectForKey:@&quot;test1&quot;];</span><br><span class="line">    [mArr removeObjectAtIndex:0];</span><br><span class="line">    NSLog(@&quot;mstring 地址：@%p, 数据:@%@\n&quot;,mStr,mStr);</span><br><span class="line">    NSLog(@&quot;string 地址：@%p, 数据:@%@\n\n\n&quot;,self.str,self.str);</span><br><span class="line">    NSLog(@&quot;marray 地址:@%p, 数据@%@\n&quot;,mArr,mArr);</span><br><span class="line">    NSLog(@&quot;array 地址:@%p, 数据@%@\n\n\n&quot;,self.arr,self.arr);</span><br><span class="line">    NSLog(@&quot;mdict 地址：@%p, 数据：@%@\n&quot;,mDict,mDict);</span><br><span class="line">    NSLog(@&quot;dict 地址：@%p, 数据：@%@\n&quot;,self.dict,self.dict);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上图是demo代码，下图是表现结果.</p><p><img src="/2021/08/23/ios属性修饰符copy/pic1.png" alt="picture1"></p><p>&ensp;&ensp;使用copy修饰的结果，修改了原数据，不会导致赋值之后的数据发生改变。因为指向了不同的地址。</p><p><img src="/2021/08/23/ios属性修饰符copy/pic2.png" alt="picture2"></p><p>&ensp;&ensp;使用strong修饰的结果，修改了原数据，赋值之后的数据也发生了改变，因为指向了相同的地址。</p><p><img src="/2021/08/23/ios属性修饰符copy/pic3.png" alt="picture3"></p><p>&ensp;&ensp;另外追加一点，为何nsstring的值给定之后可以重复修改，nsdictionary和nsarray值给定之后需要修改却不行。</p><p>&ensp;&ensp;上面这个说法其实是错误的。并不是nssrting可以重复修改，只是string类型修改起来比较容易，重新赋值之后其实本身已经指向了新的内存地址。因此，nsdict和nsarray想要修改值要做的就是修改本身的内存地址，只不过内部可能包含更多数据，所以比起string来说更加繁琐。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;iOS开发中，对于NSString，NSDictionary，NSArray一般都会使用copy来进行修饰，其实用strong的话也没有问题。只是copy修饰在进行赋值时会进行内存的拷贝，相当于赋值之后和被赋值的对象指向不同的内存地址。这样做的好处是防止修改了被赋值对象（等号右边）导致了等号左边的属性发生变化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ios常见面试题</title>
    <link href="http://yoursite.com/2021/06/07/ios%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2021/06/07/ios%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-06-07T11:19:14.000Z</published>
    <updated>2021-10-25T07:13:06.686Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要收录一些Ios面试中常会问到的一些题目</p><h3 id="1、frame和bounds的区别"><a href="#1、frame和bounds的区别" class="headerlink" title="1、frame和bounds的区别"></a>1、frame和bounds的区别</h3><p>&ensp; &ensp; 1、frame：该view在父视图坐标系中的位置和大小，参考坐标系为父视图。 2、bounds：该view在自己坐标系中位置和大小，参考坐标系为自己。3、要想知道自身的坐标，只需要知道其在父视图中的坐标即可。因此当一个父视图包含一个子视图时，可以通过修改父视图的bounds属性修改其在父视图中的相对位置。 因为bounds参考坐标系为自身，因此修改bounds的x,y坐标相当于修改其自身坐标原点的位置，从而修改了子视图参考父视图的位置。</p><a id="more"></a><h3 id="2、面向协议编程-pop-即-protocol-oriented-programming"><a href="#2、面向协议编程-pop-即-protocol-oriented-programming" class="headerlink" title="2、面向协议编程(pop  即 protocol oriented programming)"></a>2、面向协议编程(pop  即 protocol oriented programming)</h3><p>&ensp; &ensp; 讲到pop现将oop（面向对象编程）,oop具有如下优点。1、<strong>封装和权限控制</strong>，在.h文件中申明公有方法和属性，在.m文件中申明私有方法和属性。2、<strong>扩展性</strong>，在oc中可以通过分类的方式在不破坏原本封装性的同时增加新的方法。还可以通过协议（protocol）和代理（delegate）实现类的灵活扩展。3、<strong>继承和多态</strong>，将公有的属性和方法放在父类中，子类继承时根据自身需要扩展新的方法和属性，增加代码灵活性。在ios中，消息可能会转发给不同的对象，需要根据消息类型确定转发的对象，从而调用不同的类别的方法，这种称为运行时多态，也是动态多态。</p><p>&ensp; &ensp; oop的缺点1、<strong>隐式共享</strong>，说动隐式共享就需要提到深拷贝和浅拷贝，在对变量向另一个变量赋值时，如果该变量只是一个值引用类型，那么赋值后的两个变量都会指向同一块内存区域。造成数据混乱。需要需要对数据进行区分，需要重新向内存区申请一块新的地址存放新的数据。</p><p>&ensp; &ensp; pop相比oop的优势：1、<strong>更加灵活</strong>，比如当希望一个类需要具有某种能力时，可以使用protocol的方式，如果该类继承了该协议，并且实现了协议方法，就说明其具有处理这种场景的能力。这样的好处是不必去基类种增加方法。降低的冗余性。2、<strong>降低依赖</strong>，需要 这种能力的类就去实现这个协议，否则就不必实现，这样可以使得父类的只有通用的方法。</p><p>&ensp; &ensp; 考虑下面的场景，如果给一个button添加一个点击后带有抖动的效果，如何实现。1、实现一个自定义的Uibutton类，在其中添加shake方法。这种方式的代码缺乏复用性，如果其他地方需要这个能力，就必须重新实现一遍shake方法。2、写一个UIbutton类的分类，扩展其自身的能力。这种方式虽然可以解决问题，但是如果不同的场景需要不同shake方式，就需要增加条件判断，而且并不是所有人都知道存在这个分类方法。3、定义一个protocol协议，继承了该协议的类就需要实现shake方法。这种方法具有高度的定制划，需要什么类型的shake就自行定义。代码扩展能力很强。</p><h3 id="3、IOS-MVC和MVVM"><a href="#3、IOS-MVC和MVVM" class="headerlink" title="3、IOS MVC和MVVM"></a>3、IOS MVC和MVVM</h3><p>&ensp; &ensp; 在公司中一般编程都是采用MVC的设计方式，即view和model进行交互，model的来源又由controller管理，同时controller持有view，当数据来源变更时会由view触发model的变化，model变化反过来影响view的展示。大致这样一个过程。在听说MVVM的设计方式后，感觉没有用过总是不知道是如何实现的。网上搜博客也是简单的给出两个图，一个是MVC，一个是MVVM，光看图还是难以理解两者之间的真正差别。此处就不在介绍MVC模式的方式，这种方式也比较简单上手，理解比较容易。</p><p>&ensp; &ensp; <a href="https://www.jianshu.com/p/548980de876a" target="_blank" rel="noopener">https://www.jianshu.com/p/548980de876a</a> 这篇博客中给出了一个demo比较简单的一个MVVM架构。可以做一定的参考。下面根据博客内容对MVVM模式做一个简单介绍。</p><p>&ensp; &ensp; <img src="/2021/06/07/ios常见面试题/mvvm.png" alt="MVVM"></p><p>&ensp; &ensp; 如图中所示：1、VC还是管理view的生命周期，但是view不在和model进行数据交互，而是和Viewmodel进行交互。2、model的数据更新不在告知view需要更新视图。而是通过viewmodel，viewmodel告知view需要更新视图。3、大致流程可以理解为，服务端数据来之后VC触发viewmodel更新，viewmodel更新引起model和View的更新。这个流程里面数据变化引起的视图变化主要工作交给了Viewmodel去处理。这样可以使VC中的代码量大大降低。</p><p>&ensp; &ensp; 文中demo也大致如下，当列表刷新时会触发tableView的reloaddata方法，从而调用cellforrow重新渲染数据，在cellforRow中viewModel通过indexpath去为每个cell创建一个model，但是这个model是由ViewModel持有的，看起来model和cell之间没有任何关系。（就是在model和cell之间加了一个屏障，这个屏障基本做了之前model和cell之间要做的事。）既然Viewmodel持有了model，那么所有model内的数据就可以轻松拿到了。</p><h3 id="4、Ios-method-swizzling"><a href="#4、Ios-method-swizzling" class="headerlink" title="4、Ios method swizzling"></a>4、Ios method swizzling</h3><p>&ensp; &ensp; 方法交换在很多app内都有运用，<a href="https://www.jianshu.com/p/ff19c04b34d0" target="_blank" rel="noopener">https://www.jianshu.com/p/ff19c04b34d0</a> ，这篇博客对其解释的比较详细，可以参考一下。其原理祖耀是利用oc的runtime时候的消息发送机制。使用method swizzling将两个method进行互换。</p><p>&ensp; &ensp; 我现在所在公司主要是做货运相关的，app内有很多的货源列表，试想这样一种场景，给所有列表增加一个页面时长统计的功能，1、我们可以给在每一个列表的viewWillappear中开始计时，然后在dealloc里面结束计时。这样的话工作量是比较大的。2、可以让所有的列表都有继承自同一个基类列表，这样只需要在基类列表中做处理即可。我们公司如今就是这样的处理方案。3、给viewcontrlloer增加一个分类，使用method swizzling，交换需要实现的方法和viewWillappear方法。</p><p>使用method swizzling主要有几个方法比较重要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">///获取一个实例方法method 第一个参数实该类的类名，第二个参数是方法的选择子</span><br><span class="line">class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)</span><br><span class="line">///获取一个类方法</span><br><span class="line">class_getClassMethod(Class _Nullable cls, SEL _Nonnull name)</span><br><span class="line">/*</span><br><span class="line">第一个参数是该类类名，第二个参数是要被添加的方法的选择子，第三个参数是添加的新方法的指针，第四个参数是新添加方法的参数列表</span><br><span class="line">如果方法交换成功返回yes，否则no</span><br><span class="line">*/</span><br><span class="line">class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) </span><br><span class="line">/// 进行原方法和目的方法的交换</span><br><span class="line">method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)</span><br></pre></td></tr></table></figure><h4 id="Method-Swizzling类簇"><a href="#Method-Swizzling类簇" class="headerlink" title="Method Swizzling类簇"></a>Method Swizzling类簇</h4><p>&ensp; &ensp; 在项目开发中经常容易遇见NSArray数组越界或者NSDictionary取到的vlaue/key为nil导致crash，苹果的这种做法有些狠了。但是在使用method swizzling为数组越界做判断时，却发现不起作用。这是因为method swizzling对NSarray类簇不起作用，其内部有很多继承子当前类的子类，比如 objectAtIndex:这个方法会在内部创建不同的抽象类进行操作，所以我们进行method swizzling时实际操作的是NSArray的父类。 可以使用runtime方法获取其真正的类。</p><h3 id="5、-UITabBarController-amp-amp-UINavigationController"><a href="#5、-UITabBarController-amp-amp-UINavigationController" class="headerlink" title="5、 UITabBarController &amp;&amp; UINavigationController"></a>5、 UITabBarController &amp;&amp; UINavigationController</h3><p>&ensp; &ensp; 今天主要梳理了下tabBarcontroller和navigationController的运用。首先和和同事商量了一下app页面的组织形式。目前常见的app页面形式主要是首页底部一个tabbar，顶部一个navi，中间是用于展示的视图。也就是底部一个tabBarController持有了一个navigationcontroller,然后navi由持有了一个用于展示的视图。</p><p>&ensp; &ensp; 当前我公司大致也是这种设计思路。如果想操作tabBar，可以自行实现tabBar的相关协议。如果想修改Navi，可以通过uiViewController的navigationItem取到相关属性进行操作。</p><p>&ensp; &ensp; 如果想要设置navi上的背景色，可以如下使用，否则navi可能会看起来有一层蒙层一般。这种效果在app内一般设置在基类中，免得所有继承的子类都要重新设置一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//背景色</span><br><span class="line">[nav.navigationBar setBarTintColor:[UIColor orangeColor]];</span><br><span class="line">//元素颜色</span><br><span class="line">[nav.navigationBar setTintColor:[UIColor whiteColor]];</span><br><span class="line">[nav.navigationBar setTitleTextAttributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:19],</span><br><span class="line">                                                                      NSForegroundColorAttributeName:[UIColor redColor]&#125;];</span><br></pre></td></tr></table></figure><h3 id="6、iOS开发中-property的属性nonatomic-retain-readonly-strong等介绍"><a href="#6、iOS开发中-property的属性nonatomic-retain-readonly-strong等介绍" class="headerlink" title="6、iOS开发中@property的属性nonatomic retain readonly strong等介绍"></a>6、iOS开发中@property的属性nonatomic retain readonly strong等介绍</h3><h4 id="nonatomic和atomic"><a href="#nonatomic和atomic" class="headerlink" title="nonatomic和atomic"></a>nonatomic和atomic</h4><p>&ensp; &ensp; 默认是有这个atomic这个属性的，这是为了保证在多线程情况下编译器自动生成互斥锁代码防止读写不同步。如果该对象无需考虑多线程的场景，使用nonatomic修饰。</p><h4 id="copy，assign，retain"><a href="#copy，assign，retain" class="headerlink" title="copy，assign，retain"></a>copy，assign，retain</h4><p>&ensp; &ensp; assgin:默认类型，setter方法直接赋值，不进行热河retain操作，不改变引用计数，一般用于处理基本的数据类型。（float，double，integer）。  retain：释放旧的对象，将旧对象的值赋值给新对象，再另新对象的引用计数为1.应该是拷贝一份原来的指针，赋值给新的对象，再将原来的对象释放。 copy：copy和retain处理流程比较类似，释放旧对象，copy新对象，但是会重新申请一块内存，使用copy需要保证对象符合NSCopying协议，如果是NSArray对象，copy只会是浅拷贝，即将原Array的地址赋值一份。</p><h4 id="assign和retain"><a href="#assign和retain" class="headerlink" title="assign和retain"></a>assign和retain</h4><p>&ensp; &ensp; assign主要是用于修饰一些基础数据类型，并且没有引用计数，retain会有引用计数，只有当一个属性的引用计数为0时才会销毁。</p><h4 id="copy与retain"><a href="#copy与retain" class="headerlink" title="copy与retain"></a>copy与retain</h4><p>&ensp; &ensp; retain 和copy的区别主要是是否重新创建一块新地址。如果是copy，会重新申请一块内存保存新的属性。如果是retain，赋值时引用计数加1.两者会指向同一块内存区。</p><h4 id="strong和weak"><a href="#strong和weak" class="headerlink" title="strong和weak"></a>strong和weak</h4><p>&ensp; &ensp; 一般来讲使用weak是为了防止出现循环引用的问题，外层调用了内层的属性，内层将某些方法放到外层调用（delegate），使用strong会出现retain cycle。 声明weak的指针，在指针被释放时，本身会指向nil，防止野指针问题。 还有一遍类的内部属性使用strong，在外部时比如（delegate）为weak</p><h3 id="7、iOS-block原理浅析"><a href="#7、iOS-block原理浅析" class="headerlink" title="7、iOS block原理浅析"></a>7、iOS block原理浅析</h3><p>&ensp;&ensp; block底层是一个结构体，该结构体中有一个isa指针，本质是一个OC对象，block的变量捕获方式：局部变量通过值传递的形式，因此在block外部定义的局部变量，在block内部改变值大小时block内部是不会改变的，因为局部变量有可能在block执行时已经销毁。 局部静态变量的访问方式是指针传递，因为指针存放在堆区，在block运行时可以捕获到。全局变量：全局变量具有全局作用域，不需要block传值，内部可以直接访问修改。</p><p>&ensp; &ensp; block类型，在以下几种情况下，编译器会自动将栈上的block复制到堆上。1、block作为函数返回值时。2、block使用strong修饰时，3、block作为gcdAPI的方法参数时。堆上的block内部持有强引用的变量时，会造成变量无法释放，造成内存泄漏。正确的做法是在block内部弱引用变量，消除循环。</p><p>&ensp; &ensp; __block修饰符, __block可以用来解决block内部无法修改局部变量值的问题， __block不能修饰全局变量，静态变量。 __block作用是将变量使用一个结构体包装起来，其内部使用一个指针指向包装的结构体，使得block内部通过指针访问到变量修改值。</p><h3 id="8-copy-mutabelCopy"><a href="#8-copy-mutabelCopy" class="headerlink" title="8.copy mutabelCopy"></a>8.copy mutabelCopy</h3><p>&ensp;&ensp;对于常见的oc数据类型,包括string,array,dictionary都包含可变和不可变两种类型,对两者分类调用copy和mutableCopy时是否创建新的空间如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                          copy是否产生新对象    新对象类型    mutableCopy是否产生新对象      新对象类型</span><br><span class="line">NSString                    否                                  是                      NSMutableString</span><br><span class="line">NSMutableString             是                NSString          是                      NSMutableString</span><br><span class="line"></span><br><span class="line">NSArray                     否                                  是                      NSMutableArray</span><br><span class="line">NSMutableArray              是                NSArray           是                      NSMutableArray</span><br><span class="line"> </span><br><span class="line">NSDictionary                否                                  是                      NSMutableDictionary</span><br><span class="line">NSMutableDictionary         是                NSDictionary      是                      NSMutableDictionary</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文主要收录一些Ios面试中常会问到的一些题目&lt;/p&gt;
&lt;h3 id=&quot;1、frame和bounds的区别&quot;&gt;&lt;a href=&quot;#1、frame和bounds的区别&quot; class=&quot;headerlink&quot; title=&quot;1、frame和bounds的区别&quot;&gt;&lt;/a&gt;1、frame和bounds的区别&lt;/h3&gt;&lt;p&gt;&amp;ensp; &amp;ensp; 1、frame：该view在父视图坐标系中的位置和大小，参考坐标系为父视图。 2、bounds：该view在自己坐标系中位置和大小，参考坐标系为自己。3、要想知道自身的坐标，只需要知道其在父视图中的坐标即可。因此当一个父视图包含一个子视图时，可以通过修改父视图的bounds属性修改其在父视图中的相对位置。 因为bounds参考坐标系为自身，因此修改bounds的x,y坐标相当于修改其自身坐标原点的位置，从而修改了子视图参考父视图的位置。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>dart学习笔记</title>
    <link href="http://yoursite.com/2021/05/31/dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/05/31/dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-31T11:24:52.000Z</published>
    <updated>2021-08-23T12:19:57.204Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp; &ensp; 本文记载dart入门的一些基础<br>参考 <a href="https://flutter.cn/docs/development/ui/interactive" target="_blank" rel="noopener">https://flutter.cn/docs/development/ui/interactive</a></p><h3 id="有状态和无状态widgets"><a href="#有状态和无状态widgets" class="headerlink" title="有状态和无状态widgets"></a>有状态和无状态widgets</h3><p>&ensp; &ensp; 在flutter中，渲染在界面上的视图都可以堪称是一个个的widget构成，类比ios中的视图view，一些widget是无状态的，都是stateleesWidget的子集，比如Icon，Text，IconButton等，其他widget是有状态的，是statefulWidget的子集。这些widget可以通过和用户的交互改变自身的状态和表现出来的样式，比如：CheckBox，Slider，Form等。</p><a id="more"></a><p>&ensp; &ensp; 一个有状态的widget包含两个子类，一个statefulWidget子类和一个state子类，state累包含该widget的可变状态并定义该widget的build()方法。当wedget状态变化时，State对象调用setState(),告诉框架重新绘制widegt。</p><h4 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h4><p>&ensp; &ensp;如何决定widget的状态管理可以通过以下原则：如果状态是用户数据，滑块的位置等最好由父widget进行管理。 如果状态有关界面外观效果，比如动画，状态最好由widget本身进行管理。</p><h3 id="动画概览"><a href="#动画概览" class="headerlink" title="动画概览"></a>动画概览</h3><p>&ensp; &ensp;flutter中的动画系统基于animation，Widget可以直接讲这些动画合并到子集的build方法中来读取他们的当前值或者监听他们的状态变化，也可以讲其作为复杂动画的基础传递给其他widget。</p><h4 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h4><p>&ensp; &ensp;动画的收腰组成部分就是Animation类，一个动画表现在在其生命周期内发生变化的特定类型的值。大多需要执行动画的wiget都需要接受一个Animation对象作为参数，从而获取动画的当前状态值以及应当监听的值的更改。</p><h4 id="addListener"><a href="#addListener" class="headerlink" title="addListener"></a>addListener</h4><p>&ensp; &ensp; 每当动画的状态发生变化时，动画会通知所有通过addListener添加的监听器。然后正在监听动画的state调用自身的setState方法，根据状态来进行widget重新构建。</p><h4 id="addStatusListener"><a href="#addStatusListener" class="headerlink" title="addStatusListener"></a>addStatusListener</h4><p>&ensp; &ensp; 动画还提供了AnimationStatus，表示动画讲如何随时间进行变化，当动画状态发生变化时，动画都会通知addStatusListener添加的监听器。</p><h3 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h3><p>&ensp; &ensp; 补间动画本身值定义了如何在两个值件进行插值。要获取动画当前帧的具体值，需要一个动画来确定当前状态，有两种方法可以讲补间动画与动画组合在一起以获得动画具体值。 1、 使用evaluate方法处理动画的当前值获得一个对应的插值。 2、使用animate方法处理一个动画。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp; &amp;ensp; 本文记载dart入门的一些基础&lt;br&gt;参考 &lt;a href=&quot;https://flutter.cn/docs/development/ui/interactive&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://flutter.cn/docs/development/ui/interactive&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;有状态和无状态widgets&quot;&gt;&lt;a href=&quot;#有状态和无状态widgets&quot; class=&quot;headerlink&quot; title=&quot;有状态和无状态widgets&quot;&gt;&lt;/a&gt;有状态和无状态widgets&lt;/h3&gt;&lt;p&gt;&amp;ensp; &amp;ensp; 在flutter中，渲染在界面上的视图都可以堪称是一个个的widget构成，类比ios中的视图view，一些widget是无状态的，都是stateleesWidget的子集，比如Icon，Text，IconButton等，其他widget是有状态的，是statefulWidget的子集。这些widget可以通过和用户的交互改变自身的状态和表现出来的样式，比如：CheckBox，Slider，Form等。&lt;/p&gt;</summary>
    
    
    
    <category term="dart" scheme="http://yoursite.com/categories/dart/"/>
    
    
    <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>iOS消息传递机制和消息转发机制</title>
    <link href="http://yoursite.com/2021/04/01/iOS%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/04/01/iOS%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/</id>
    <published>2021-04-01T05:53:15.000Z</published>
    <updated>2021-08-23T12:20:21.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>&ensp; &ensp; objective-c是一门动态语言，是c语言的超集。在c语言中，编译期间就必须根据代码执行的顺序决定运行时期的执行结果。在编译结束之后就知道代码最终会走进哪一个方法。在objectvie-c中，方法是动态绑定的，对象在运行过程中根据消息转发机制对相应的方法做出响应。</p><a id="more"></a><h3 id="iOS消息传递"><a href="#iOS消息传递" class="headerlink" title="iOS消息传递"></a>iOS消息传递</h3><p>&ensp; &ensp; 一般来说消息传递是指对象在进行方法调用时，如果在该对象中找不到对应的方法实现，就会到改对象的父类中查找对应的方法实现。如果找到则继续执行下去。如果没有找到继续到父类中寻找对应的方法实现，如果到基类中还是没有找到对应的方法实现，则会触发消息转发机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id returnValue = [someObject messgeName:parameter];</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; 上面示例中，someObject是方法调用着，messaName是方法名，也称为selector（选择子），选择子和其所带的参数合称为消息。运行过程中，编译器会将商法消息转化为objc_msgSend()进行调用。原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void objc_msgSend(id self, SEL cmd, ...)</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>&ensp; &ensp;  第一个参数是方法调用者，第二个参数是选择子（应该是指向对应c语言方法实现的一个指针），后面的可变参数是消息所携带的参数。</p><p>消息传递完整流程：</p><p>&ensp; &ensp; 1、方法调用者根据isa指针找到自己所属类的方法列表，首先会去cache中查找是否有方法实现，如果有则找到直接运行。如果没有则道方法列表中寻找对应的方法实现。如果该类实现了这个方法，那么会将这个方法加入到cache中，并执行这个方法。</p><p>&ensp; &ensp; 2、如果在该类的方法别表中找不到对应的方法实现，会到这个类的父类中使用相同的方式查找相对应的方法实现。</p><p>&ensp; &ensp; 3、如果到基类中都没有找到objc_msgSend()中的选择子的方法。那么将会触发消息转发机制。</p><h3 id="iOS消息转发"><a href="#iOS消息转发" class="headerlink" title="iOS消息转发"></a>iOS消息转发</h3><p>&ensp; &ensp;  在开发过程中经常会遇到，<strong><em>xxx: unrecognized selector sent to instance</em></strong>,类似报错都是iOS方法在触发消息转发机制后，找不到对应的方法实现抛出的问题。其完成的流程图如下：</p><p><img src="/2021/04/01/iOS消息传递机制和消息转发机制/iOS%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="ios消息转发流程"></p><p>&ensp; &ensp; 从图中可以看到，消息转发主要包括三个步骤</p><p>1、 method resolution</p><p>2、 fast forwarding</p><p>3、 normal forwarding</p><p>如果想要最后不会抛出<strong><em>unrecognized selector</em></strong>的异常，那么就必须在消息转发中的某一个步骤拯救。</p><h4 id="method-resolution"><a href="#method-resolution" class="headerlink" title="method resolution"></a>method resolution</h4><p>&ensp; &ensp; 如果调用了实例方法会进行<strong><em>+(BOOL)resolveInstanceMethod:(SEL)sel</em></strong>判断，如果调用了类方法，则会进行<strong><em>+(BOOL)resolveClassMethod:(SEL)sel</em></strong>，返回yes则表示可以进行消息处理，否则进入到第二步。</p><h4 id="fast-forwarding"><a href="#fast-forwarding" class="headerlink" title="fast forwarding"></a>fast forwarding</h4><p> &ensp; &ensp; 如果第一步返回NO，进入<br> <strong><em>-(id)forwardingTargetForSelector:(SEL)aSelector</em></strong>，并在其中使用替代的类型方法去响应。</p><h4 id="Normal-forwarding"><a href="#Normal-forwarding" class="headerlink" title="Normal forwarding"></a>Normal forwarding</h4><p>&ensp; &ensp; 如果第2步返回self或者nil,则说明没有可以响应的目标 则进入第三步。<br>第三步的消息转发机制本质上跟第二步是一样的都是切换接受消息的对象，但是第三步切换响应目标更复杂一些，第二步里面只需返回一个可以响应的对象就可以了，第三步还需要手动将响应方法切换给备用响应对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1)-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;&amp;ensp; &amp;ensp; objective-c是一门动态语言，是c语言的超集。在c语言中，编译期间就必须根据代码执行的顺序决定运行时期的执行结果。在编译结束之后就知道代码最终会走进哪一个方法。在objectvie-c中，方法是动态绑定的，对象在运行过程中根据消息转发机制对相应的方法做出响应。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS drawRect&amp;drawTextInRect</title>
    <link href="http://yoursite.com/2021/03/27/iOS-drawRect-drawTextInRect/"/>
    <id>http://yoursite.com/2021/03/27/iOS-drawRect-drawTextInRect/</id>
    <published>2021-03-27T01:47:36.000Z</published>
    <updated>2021-08-23T10:32:04.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>&ensp; &ensp; 最近在给一段文字增加padding时，使用了系统API <strong>boundingRectWithSize:options:attributes:context</strong>来计算可变文案的size，然后通过在该size下增加一个水平和垂直的padding并且文案居中对齐获得label/view的size。这样的做法在极端情况下会出现异常情况，由于view/label的最大size是固定好的，因此就算使用计算得到size最后还是只能使用label可以展示的最大size。最后的结果是正常长度的文案可以显示padding，但是过长的文案padding无效。</p><a id="more"></a>  <p><img src="/2021/03/27/iOS-drawRect-drawTextInRect/%E6%AD%A3%E5%B8%B8%E5%B1%95%E7%A4%BA.png" alt="正常展示"></p><p><img src="/2021/03/27/iOS-drawRect-drawTextInRect/%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B1%95%E7%A4%BA.png" alt="不正常展示"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>&ensp; &ensp; 这个问题的解决方式可以通过自行操作label中文案显示来解决。大致意思就是给定一个空的label，如何展示以及展示在什么位置由自己决定。</p><h4 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect"></a>drawRect</h4><p>&ensp; &ensp; 使用这个方法可以在视图中绘制一些自己想要的图案。但是有一些注意事项：<br>1.这个方法不需要手动触发，当视图需要重新渲染或者视图发生变化会调用。2.可以通过在继承自uiView的子类中调用该方法来绘制图形。 具体的使用方式可以参考这篇文章中的写法。</p><p><a href="https://www.jianshu.com/p/1aae00b4e440" target="_blank" rel="noopener">https://www.jianshu.com/p/1aae00b4e440</a></p><h4 id="drawTextInRect"><a href="#drawTextInRect" class="headerlink" title="drawTextInRect"></a>drawTextInRect</h4><p>&ensp; &ensp; 使用此方法会在视图渲染的时候触发，只需要在其中设置文案的inset和rect。其中rect是渲染前已经是确定好的，因此只需要设置需要padding的值即可。</p><p>&ensp; &ensp; 最终决定的解决方案是使用drawTextInrect</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawTextInRect:(CGRect)rect &#123;</span><br><span class="line">    UIEdgeInsets insets = &#123;0, 5, 0, 5&#125;;</span><br><span class="line">    [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;&amp;ensp; &amp;ensp; 最近在给一段文字增加padding时，使用了系统API &lt;strong&gt;boundingRectWithSize:options:attributes:context&lt;/strong&gt;来计算可变文案的size，然后通过在该size下增加一个水平和垂直的padding并且文案居中对齐获得label/view的size。这样的做法在极端情况下会出现异常情况，由于view/label的最大size是固定好的，因此就算使用计算得到size最后还是只能使用label可以展示的最大size。最后的结果是正常长度的文案可以显示padding，但是过长的文案padding无效。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>一年多以后的再一次更新</title>
    <link href="http://yoursite.com/2021/03/15/%E4%B8%80%E5%B9%B4%E5%A4%9A%E4%BB%A5%E5%90%8E%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2021/03/15/%E4%B8%80%E5%B9%B4%E5%A4%9A%E4%BB%A5%E5%90%8E%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E6%9B%B4%E6%96%B0/</id>
    <published>2021-03-15T09:43:48.000Z</published>
    <updated>2021-08-23T12:17:05.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp; &ensp; 距离上一次更新已经是一年多以前了。回想起来这一年多过的老快了，好像啥也没做就过去了。自己也已经步入社会10个月了吧。年前的几个月感觉没什么区别，现在慢慢接触的人和东西多了以后感觉进入社会还真的和学校不太一样，不知道是不是因为公司里同龄人比较少的原因。大多数的人好像把甩锅放到了首位，而不是想第一时间先解决问题。官场气息有点高，总感觉自己比别人早来一段时间要厉害一些。有一股子颐指气使的味道。我自己还是很讨厌这种氛围的。感觉在这种环境中自己也会变成这样的人。努力保证自己变得慢一点吧。</p><a id="more"></a> <p> &ensp; &ensp; 说到自己其他的变化，好像变得不喜欢出门了。也许是这边没有认识的人的缘故吧。总感觉出门到处溜达如果不是认识的人一起会变得好累。还不如呆在屋子里就这样躺着发呆。我还真是闲的一。）</p><p>&ensp; &ensp; 再说说能力吧，写码能力确实相比之前提升了一丢丢，但是还是差了好多。后续还是要开始刷leetcode了吧，不然自己的思维能力总是会差一些。面对一些问题，有时自己的思维总是要稍微差一点。对一个问题的思考方式也需要改变。我只希望在自己的不断业务开发里面能稍微提高一下自己的思考方式。</p><p>&ensp; &ensp; 接下来几个月，我尽量保证自己一周更新一篇文章吧，也算是给自己定一个目标，然后积累自己最近了解的一些东西。然后一些题解，一些自己的观点啥的。那就从这一篇开始吧。</p><h3 id="ios阴影不展示"><a href="#ios阴影不展示" class="headerlink" title="ios阴影不展示"></a>ios阴影不展示</h3><p>&ensp; &ensp; 记录一下今天遇到的阴影不展示的问题，这篇博客里面做出了详细的指导，感谢原作者。下面放了链接。</p><p><a href="https://www.jianshu.com/p/0f24ad35788d" target="_blank" rel="noopener">https://www.jianshu.com/p/0f24ad35788d</a></p><p>&ensp; &ensp; 先描述一下今天遇到的问题，我在给一个view设置阴影的时候发现无论如何设置阴影都无法展示。一开始以为设置的方式有问题，然后查了一下阴影相关的一些属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(CGColorRef *) shadowColor//阴影颜色</span><br><span class="line">(float) shadowOpacity//阴影透明度</span><br><span class="line">(CGSize) shadowOffset//阴影偏移量</span><br><span class="line">(CGFloat) shadowRadius//模糊计算的半径</span><br><span class="line">(CGPathRef *) shadowPath//阴影路径</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; 需要特别注意的一点是：在设置阴影的时候必须给view指定一个背景色，否则阴影是无法显示的。但是我这次遇到的这个问题是其他原因。当给一个view同时设置圆角和阴影时，圆角的效果可以展示，但是阴影的效果是没有的。这是因为在设置圆角是需要设置一个maskToBounds = yes的属性，这个动作会将子视图超过父视图的部分给clips掉，然后就会导致边缘的阴影是无法展示的。</p><p>&ensp; &ensp; 因此正确的做法应该是重新引入一个视图作为当前视图的父视图，然后子视图只设置圆角，父视图负责设置阴影。当然这样做当子视图没有填满父视图的时候，会导致圆角看起来没有生效，所以这一点还是需要小心的。</p><h3 id="ios-协议"><a href="#ios-协议" class="headerlink" title="ios 协议"></a>ios 协议</h3><p>&ensp; &ensp; 这里主要总结一下iOS协议的一些基本只是和用法，主要包括以下两个部分。1、iOS协议的声明和使用。2、iOS协议，代理，委托，几个名词的含义和关系。3、iOS在协议中声明属性。</p><h4 id="1、iOS协议的声明和使用"><a href="#1、iOS协议的声明和使用" class="headerlink" title="1、iOS协议的声明和使用"></a>1、iOS协议的声明和使用</h4><p>&ensp; &ensp;iOS协议的声明类似于C++中的纯虚函数。告诉外界如果遵守（继承）了这个协议，就有能力实现协议中声明的方法，进而完成一些类本身无法完成的事。</p><p>&ensp; &ensp; 这样看起来和继承没什么区别。接下来加一些限制，在iOS开发中，伴随着协议还有一个名词，那就是代理（delegate）。试想这样一个场景，在一个页面容器中，包含两个子页面成为子页面1和子页面2。其中子页面2的数据来源需要依靠子页面1.现在的问题就是如何从子页面2拿到子页面1提供的数据。这里就可以使用协议了。方法如下：</p><p>&ensp; &ensp; 声明一个协议A，子页面2继承协议A，但是子页面2无法完成协议A中的方法，因此使用代理将这些方法交给子页面1或者父容器去实现。具体要做的事就是取到子页面1中提供的数据，然后为子页面2提供数据源。这样就是一个协议完成工作的整个流程了。</p><h4 id="2、iOS协议，代理，委托"><a href="#2、iOS协议，代理，委托" class="headerlink" title="2、iOS协议，代理，委托"></a>2、iOS协议，代理，委托</h4><p>&ensp; &ensp; 协议：提供了可以解决一些问题的方法声明，但是没有实现，需要有能力实现的类去实现。（任务）</p><p>&ensp; &ensp; 代理（delegate）：上面所说的子页面2，子页面2无法完成数据请求，需要继承协议。那协议的实现需要其他类去帮忙完成。因此设置一个代理属性。（boss）</p><p>&ensp; &ensp; 委托：实现协议的类。最后能够实现协议，完成功能的类。（开发）</p><h4 id="3、iOS在协议中声明属性"><a href="#3、iOS在协议中声明属性" class="headerlink" title="3、iOS在协议中声明属性"></a>3、iOS在协议中声明属性</h4><p>&ensp; &ensp; 在协议中是可以声明属性的。在一般的类中声明属性（property）的同时编译器会自动生成该属性的setter和getter方法和一个成员。但是在协议中声明属性的话是无法自动生成读取方法的。在继承协议时会有编译器警告，可以手动添加读取方法也可以使用关键字synthesize自动补全。同样的效果也发生在分类上。</p><h3 id="tableview-cell重用机制"><a href="#tableview-cell重用机制" class="headerlink" title="tableview cell重用机制"></a>tableview cell重用机制</h3><p>&ensp; &ensp; iOS tableview cell 的重用在节约了很大的内存空间，并且在滑动过程中通过重用机制可以提升性能。而且通过model进行数据传递还可以解决滑动过程中cell重复的问题。</p><p>&ensp; &ensp; 在重用机制主要依靠<strong>两个mutableArray：visiableCells和reusabelCells</strong>。如果某一次接口返回了20条数据，但是屏幕一次只能展示6条数据，那么前6条数据的展示就需要 initWithStyle:reuseIdentifier:初始化6个cell来展示，此时6个cell都是visible的，当滑动屏幕时，会创建第7个visible的cell，因为此时的reuseableCells是没有可用cell的。当出现第7个cell时第一个cell会消失，存储到reusableCells中，并从visibleCell中移除。然后继续滑动到第8个cell时，会通过”Identifier“字段判断当前cell是否可重用，如果可以重用，那么就从不在创建新的cell，而是使用第一个cell来进行展示 <em>（1）</em>。如果不可重用，那么创建一个新的cell并指定一个新的”identifer“。</p><p>&ensp; &ensp; 需要注意的点：1.重用机制是通过reuseIdentify来实现的，要保证不出现问题，只需要保证数据类型一致。如果是特殊的数据，就重新使用一个identify来创建一个新的cell。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp; &amp;ensp; 距离上一次更新已经是一年多以前了。回想起来这一年多过的老快了，好像啥也没做就过去了。自己也已经步入社会10个月了吧。年前的几个月感觉没什么区别，现在慢慢接触的人和东西多了以后感觉进入社会还真的和学校不太一样，不知道是不是因为公司里同龄人比较少的原因。大多数的人好像把甩锅放到了首位，而不是想第一时间先解决问题。官场气息有点高，总感觉自己比别人早来一段时间要厉害一些。有一股子颐指气使的味道。我自己还是很讨厌这种氛围的。感觉在这种环境中自己也会变成这样的人。努力保证自己变得慢一点吧。&lt;/p&gt;</summary>
    
    
    
    <category term="回顾" scheme="http://yoursite.com/categories/回顾/"/>
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>blog record</title>
    <link href="http://yoursite.com/2020/06/16/blog-record/"/>
    <id>http://yoursite.com/2020/06/16/blog-record/</id>
    <published>2020-06-16T10:32:15.000Z</published>
    <updated>2020-06-16T15:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>现在是2020年6月16日晚23：02，明天是我成为社畜的第一天，本想早几天记录下从武汉毕业到南京这几天心路历程，偷懒到只能在现在写点什么了。在没动手前觉得自己可以写好多东西的，现在就感觉之前所想到的好像都忘记了一样。不过没事，随便记录一下表示自己也是一个有感情的人吧。</p><a id="more"></a> <h3 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h3><p>撒西不理啦，上次写日志还是在好几个月前，说来也惭愧，疫情导致自己一直再找借口不学习。好在从现在开始如果我不去学习只有等着被淘汰，所以我应该会好好学点什么的吧。</p><p>七号晚上到达武汉，在是否能够进校毕业这件事上又给自己弄出了好些问题，好在最后成功进校，完成了算是近年来的第一个小目标吧。见到了那么久都没有见过的同学。虽然又一两个在游戏听到了声音，但是见到总还是觉得很开心。进行了象征性的毕业聚餐。照了几张毕业照，可是好烦啊，为什么在家呆了小半年我又变黑了，淦！</p><p>11号离开了武汉，10和两个好朋友吃了个简单的散伙饭。这两个b是真的见色忘义，为了晚上和女朋友玩直接抛弃我？还好良心发现知道请我吃顿好的（原本这餐饭是该我请的）。那这个问题久跳过吧。</p><p>不知道是不是这段时间来二次元看多了，有时候自己好想学着那些主角的性格做事，好中二! 不过我还是发现了自己确实做不到别人那种地步，毕竟咱还是活在三次元的。有时候知晓自己的性格，不要给别人带去麻烦我觉得是很重要的，我所说的不是搞清楚自己喜欢吃什么，喜欢什么运动。而是在和其他人相处时自己能做的久不要随意使唤他人了。至少目前这是我的观点，当然在好朋友面前这个观点不成立（这也是我的观点，禁止套娃！）。</p><p>都这样了，还是贴一张最后聚餐的照片吧，说到这，我忽然想起对班长说的一句话，比起拍照，我更喜欢用眼睛记录下那些美好的瞬间。我也不清楚这是不是我的真心话，有时候我也幻想自己可以拍一些搞笑二比的照片，但是好像没怎么实现，可能还是我出于对自己在照片中样貌的厌恶吧（也许）。</p><p><img src="/2020/06/16/blog-record/fir.jpg" alt="pic"></p><p>这个b还闭着眼，啧啧。</p><h3 id="chapter2"><a href="#chapter2" class="headerlink" title="chapter2"></a>chapter2</h3><p>到了南京首要任务就是找房子住了，我是真没想到最后为了付房租需要花费我几大千。现在只能寄希望于入职后下个月的工资了。</p><p>反正8到12号这几天走的我怀疑人生就是了。原本在这里有好多想写的，现在要下笔了却又不知道写啥了。有些东西感悟过就行，不过希望真的对于我能起到一点点作用，我现在还记得前段时间自己不断狂立flag，然后狂倒flag的惨烈景象。</p><p>室友比较好相处还是不错的，大家性格都优点大大咧咧，目前看来是这样，还是希望之后能好好相处，不然出啥乱子了面子上还是不太挂得住。希望不要遇到之前脑子想的那些情况，对彼此有意见却一直不说，到了某一天再爆发那就很恐怖了。<br>为了防止那种情况发生，还是要注意下自己的言行，不要或者少做出过激行为，有时候自己会头脑发热搞些屁事出来，我还是承认这一点的。</p><h3 id="chapter3"><a href="#chapter3" class="headerlink" title="chapter3"></a>chapter3</h3><p>哎，又觉得没得说了，哦对了，拍了一张离开宿舍时的照片，还是放一下吧，留个念想，下次再去不知道什么时候了。</p><p><img src="/2020/06/16/blog-record/sec.jpg" alt="pic"></p><p>还有就是和室友做了最后道别了，不，是一次愉快的道别。希望他研究生能够成为大腿吧，以后也许可以抱一抱（\卑微.jpg）。</p><p>所以啊，我觉得有时候一些自己所认为的好朋友还是一起稍微呆一段时间久好好做各自的事情为好。不然总会发现别人性格中的自己厌恶的地方。要是找不到？那也许就是知己吧（我瞎说的）。要说有什么后悔的嘛，感觉很多的来着，但是现在却一条也想不起来了。也许是我又想偷懒了，想睡觉不想写了。</p><p>感觉这四年来对于自己也没啥好总结的，性格应该变了一些，对了后悔就是自己这段时间没有好好看玩一本书了。这原本是我已经培养了快两年的爱好，之后一定要继续下去。</p><p>虽然好多人调侃说今年的愿望是活下去。我也不知道说什么。困难的事请总会来临，但是过了之后感觉也就那样了。所以痛苦的感觉我也记不清了，但是经历的时候是真的痛苦。开心的时候也是真的开心。</p><p>那就祝自己工作上少犯点错。尽快学会自己解决问题吧。 就不用照片镇楼了。之后还得继续更新自己博客哦。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;现在是2020年6月16日晚23：02，明天是我成为社畜的第一天，本想早几天记录下从武汉毕业到南京这几天心路历程，偷懒到只能在现在写点什么了。在没动手前觉得自己可以写好多东西的，现在就感觉之前所想到的好像都忘记了一样。不过没事，随便记录一下表示自己也是一个有感情的人吧。&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/其他/"/>
    
    
    <category term="感悟" scheme="http://yoursite.com/tags/感悟/"/>
    
  </entry>
  
  <entry>
    <title>swift语法基础(四)</title>
    <link href="http://yoursite.com/2020/01/23/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%9B%9B/"/>
    <id>http://yoursite.com/2020/01/23/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%9B%9B/</id>
    <published>2020-01-23T07:12:12.000Z</published>
    <updated>2020-02-07T05:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>swift统一的函数语法非常灵活，可以用来表示任何函数，包括最简单的没有参数名字的c风格函数，到复杂的带局部外部参数名的OC风格参数，参数可以听过默认值，以简化函数调用。参数也可以及当作传入参数，也当作传出参数。也就是说，一旦函数执行，传入的参数值会被修改。</p><p>swift中每一个函数都有一个由函数的参数类型和返回值类型组成的类型。可以把函数类型当作任何其他变量类型处理。这样可以简单的把函数当作别的函数的参数。也可以从其他函数中返回函数。函数定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现封装。</p><a id="more"></a><h4 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h4><p>当定义一个函数时，可以定义一个或多个有名字和类型的值，作为函数的输入，称为参数，也可以定义某种类型的值作为函数执行结束的输出作为返回类型。</p><p>每个函数有一个函数名，用来描述函数执行的任务，使用函数时，用函数名调用。并传给它匹配的输入值（实参），函数的实参必须与函数参数表里参数顺序一致。</p><p>下面是一个 greet函数例子:</p><pre><code>func greet(person: String) -&gt; String {    let greeting = &quot;Hello, &quot; + person + &quot;!&quot;    return greeting}print(greetAgain(person: &quot;Anna&quot;))// 打印“Hello again, Anna!”</code></pre><p>所有这些信息汇总起来称为函数定义，以func作为前缀。 -&gt; 后跟返回类型。</p><h4 id="函数参数与返回值"><a href="#函数参数与返回值" class="headerlink" title="函数参数与返回值"></a>函数参数与返回值</h4><ul><li><p>无参函数</p><p>函数可以没有参数，这个函数就是一个无参数函数。但是函数名后面还是需要圆括号。</p></li><li><p>多参数函数</p></li></ul><p>函数可以有多种输入参数，这些参数被包含在函数的括号中，用逗号分隔。</p><pre><code>func greet(person: String, alreadyGreeted: Bool) -&gt; String {if alreadyGreeted {    return greetAgain(person: person)} else {    return greet(person: person)}}print(greet(person: &quot;Tim&quot;, alreadyGreeted: true))// 打印“Hello again, Tim!”</code></pre><ul><li>无返回值函数</li></ul><p>函数可以没有返回值，如下：</p><pre><code>func greet(person: String) {    print(&quot;Hello, \(person)!&quot;)}greet(person: &quot;Dave&quot;)// 打印“Hello, Dave!”</code></pre><ul><li>多重返回值函数</li></ul><p>可以用元组类型让多个值作为一个复合值从函数中返回。如下:</p><pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int) {var currentMin = array[0]var currentMax = array[0]for value in array[1..&lt;array.count] {    if value &lt; currentMin {        currentMin = value    } else if value &gt; currentMax {        currentMax = value    }}    return (currentMin, currentMax)}</code></pre><p>该函数返回一个包含两个Int的元组，这些值被标记为min和max。</p><pre><code>let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)// 打印“min is -6 and max is 109”</code></pre><p>需要注意的是元组成员不需要在元组从函数中返回时命名。因为名字已经在返回类型中指定了。</p><ul><li>可选元组返回类型</li></ul><p>如果函数返回的元组类型可能整个元组都没有值，可以使用可选的元组作为返回类型反映元组是nil。可以通过在元组类型的右括号后放置一个问号来定义一个可选元组。例如:(Int,Int)?或者 (String,Bool,Int)?</p><p>前面minmax(array:)函数返回一个包含两个Int值的元组，但是函数不会对传入的数组执行任何安全检查，如果array是一个空数组，在执行时会触发错误。所以为了解决这个问题，函数改写为使用可选元组返回类型，当数组为空时返回nil:</p><pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {if array.isEmpty { return nil }var currentMin = array[0]var currentMax = array[0]for value in array[1..&lt;array.count] {    if value &lt; currentMin {        currentMin = value    } else if value &gt; currentMax {        currentMax = value    }}    return (currentMin, currentMax)}</code></pre><ul><li>隐式返回的函数</li></ul><p>如果一个函数的整个函数体是单行表达式，这个函数可以隐式的返回这个表达式。</p><h4 id="函数标签和参数名称"><a href="#函数标签和参数名称" class="headerlink" title="函数标签和参数名称"></a>函数标签和参数名称</h4><p>每个函数都有一个参数标签以及一个参数名称，参数标签在调用函数的时候使用，调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用，默认情况下，函数参数使用参数名称来作为参数标签。</p><ul><li>指定参数标签</li></ul><p>可以在参数名称前指定参数标签，中间用空格分隔:</p><pre><code>func someFunction(argumentLabel parameterName: Int) {// 在函数体内，parameterName 代表参数值}</code></pre><p>一个新版greet例子:</p><pre><code>func greet(person: String, from hometown: String) -&gt; String {return &quot;Hello \(person)!  Glad you could visit from \(hometown).&quot;}print(greet(person: &quot;Bill&quot;, from: &quot;Cupertino&quot;))// 打印“Hello Bill!  Glad you could visit from Cupertino.”</code></pre><p>参数标签能够让函数在调用是更有表达力。</p><ul><li>忽略参数标签</li></ul><p>如果不希望为某个参数添加一个标签，使用下划线代替:</p><pre><code>func someFunction(_ firstParameterName: Int, secondParameterName: Int) { // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值}someFunction(1, secondParameterName: 2)</code></pre><ul><li>默认参数值</li></ul><p>可以在函数体中通过给参数赋值来为任意一个参数定义默认值，默认值被定义后，调用这个函数时可以忽略这个参数。一般将带有默认值的参数放在末尾。</p><ul><li>可变参数</li></ul><p>可变参数可以接受0个或者多个值，函数调用时，可以用可变参数来指定函数参数可以被传入不确定的输入值。在变量类型名后加入(…)表示可变参数。</p><pre><code>func arithmeticMean(_ numbers: Double...) -&gt; Double {var total: Double = 0for number in numbers {    total += number} return total / Double(numbers.count)} //使用可变参数计算任意长度数字的平均数arithmeticMean(1, 2, 3, 4, 5)// 返回 3.0, 是这 5 个数的平均数。arithmeticMean(3, 8.25, 18.75)// 返回 10.0, 是这 3 个数的平均数。</code></pre><p><strong>notice：</strong>一个函数最多由一个可变参数。</p><ul><li>输入输出参数</li></ul><p>如果函数参数是常量，则不能在函数内修改。如果想要修改参数的值，并且想在这些修改在函数调用后任然存在，需要将参数定义为输入输出参数。</p><p>定义一个输入输出参数时，在参数顶以前加<strong>inout</strong>关键字，一个输入输出参数由传入函数的值，这个值被函数修改，然后传出函数。</p><p>只能传递变量给输入输出参数，当传入的参数作为输入输出参数时，需要在参数名前加 &amp;，表示这个值可以被函数修改。 例子如下：</p><pre><code>func swapTwoInts(_ a: inout Int, _ b: inout Int) {    let temporaryA = a    a = b    b = temporaryA}//调用如下var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)// 打印“someInt is now 107, and anotherInt is now 3”</code></pre><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>每个函数都有中特定的函数类型，函数的类型由函数的参数类型和返回类型组成。</p><pre><code>func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {    return a + b}func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int {    return a * b}</code></pre><p>这两个函数的类型为(Int,Int)-&gt;Int</p><pre><code>func printHelloWorld() {    print(&quot;hello, world&quot;)}//函数类型为 ()-&gt; void</code></pre><ul><li>使用函数类型</li></ul><p>使用函数类型可以：定义一个类型为函数的常量或者变量，将适当的函数赋值给他。</p><pre><code>var mathFunction: (Int, Int) -&gt; Int = addTwoInts</code></pre><p>上面代码解读为: 定义一个mathFunction的变量，类型是一个有两个Int的参数，并返回一个Int的函数。让这个新变量指向addTwoInts函数。</p><p>现在可以使用mathFunction调用被复制的函数。</p><pre><code>print(&quot;Result: \(mathFunction(2, 3))&quot;)// Prints &quot;Result: 5&quot;</code></pre><p>也可以将相同类型匹配的不同函数赋值给同一个变量：</p><pre><code>mathFunction = multiplyTwoIntsprint(&quot;Result: \(mathFunction(2, 3))&quot;)// Prints &quot;Result: 6&quot;</code></pre><p>也可以简单写法，使用swift的推断机制，推出变量为函数类型：</p><pre><code>let anotherMathFunction = addTwoInts// anotherMathFunction 被推断为 (Int, Int) -&gt; Int 类型</code></pre><ul><li>函数类型作为参数类型</li></ul><p>使用(Int,Int)-&gt;Int 这样的函数作为另一个函数的参数类型，这样可以将函数的一部分实现留给函数的调用者提供。如下例子：</p><pre><code>func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {print(&quot;Result: \(mathFunction(a, b))&quot;)}printMathResult(addTwoInts, 3, 5)// 打印“Result: 8”</code></pre><p>如上定义了一个 printMathResult(<em>:</em>:_:)函数，有三个参数，第一个参数为函数类型，可以传入任何类型的这个函数。它不关心传入的函数如何实现，只关心传入函数是不是一个正确的类型。</p><ul><li>函数类型作为返回类型</li></ul><p>可以用函数类型作为另一个函数的返回类型，需要做的是在返回箭头(-&gt;)后写一个完成的函数类型，例子如下：</p><pre><code>func stepForward(_ input: Int) -&gt; Int {    return input + 1}func stepBackward(_ input: Int) -&gt; Int {    return input - 1}func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {    return backward ? stepBackward : stepForward}//chooseStepFunction返回类型是(Int)-&gt;(Int),</code></pre><p>现在可以使用如下方式调用该函数:</p><pre><code>var currentValue = 3let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero 现在指向 stepBackward() 函数。</code></pre><p>现在 moveNearToZero是一个函数类型，可以像函数那样使用它:</p><pre><code>print(&quot;Counting to zero:&quot;)// Counting to zero:while currentValue != 0 {    print(&quot;\(currentValue)... &quot;)    currentValue = moveNearerToZero(currentValue)}print(&quot;zero!&quot;)// 3...// 2...// 1...// zero!</code></pre><ul><li>嵌套函数</li></ul><p>函数可以定义在别的函数体中，称为嵌套函数，默认情况下,嵌套函数对外界不可见，但是可以被他们的外围函数调用，一个外围函数可以返回他的某个嵌套函数，使得这个函数可以在其他域中被使用。下面例子chooseStepFunction(backward:) 函数：</p><pre><code>func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {func stepForward(input: Int) -&gt; Int { return input + 1 }func stepBackward(input: Int) -&gt; Int { return input - 1 }return backward ? stepBackward : stepForward}var currentValue = -4let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero now refers to the nested stepForward() functionwhile currentValue != 0 {    print(&quot;\(currentValue)... &quot;)    currentValue = moveNearerToZero(currentValue)}print(&quot;zero!&quot;)// -4...// -3...// -2...// -1...// zero!</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是自包含的函数代码块，可以在代码中被传递和使用。闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。swift会管理在捕获过程中涉及的所有内存操作。前面介绍的全局和嵌套函数实际也是特殊的闭包。闭包采用如下三种形式之一:</p><pre><code>1. 全局函数是一个有名字但不会捕获任何值得闭包2. 嵌套函数是一个有名字并可以捕获其封闭函数域内值得闭包3. 闭包表达式是一个利用轻量级语法所写的可以捕获上写问中变量或常量的匿名闭包。</code></pre><p>swift的闭包表达式风格简单，鼓励在常见场景中进行语法优化，主要优化如下：</p><pre><code>1. 利用上下文推断参数和返回值类型2. 隐式返回单表达式闭包，即表达式闭包可以省略return关键字3. 参数名称缩写4. 尾随闭包语法</code></pre><h4 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h4><p>闭包表达式是一种构建内敛闭包的方式，语法简洁，在保证不丢失它语法清晰明了的同时，闭包表达式提供了几种优化的语法简写形式，下面例子通过对sorted(by:)这个案例的多次迭代改进来展示这个过程：</p><p> swift标准库提供了 sorted(by:)的方法。会基于提供的闭包表达式的判断结果对数组中的值进行排序，一旦完成排序过程，该方法返回一个与就数组大小相同类型的新数组，该数组的元素有着正确的排序顺序，原数组不会被该方法修改。</p><p>sorted(by:)方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔值表明排序顺序。</p><pre><code>let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]func backward(_ s1: String, _ s2: String) -&gt; Bool {    return s1 &gt; s2} //倒序排列var reversedNames = names.sorted(by: backward)// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</code></pre><ul><li>闭包表达式语法</li></ul><p>闭包表达式有如下一般形式:</p><pre><code>{ (parameters) -&gt; return type in    statements}</code></pre><p>闭包表达式参数可以是inout参数，但不能设定默认值，如果命名了可变参数，可以使用可变参数，元组也可以作为参数和返回值。如下是backward函数对应闭包表达式代码：</p><pre><code>reversedNames = names.sorted(by: { (s1: String, s2:     String) -&gt; Bool in        return s1 &gt; s2})</code></pre><p>需要注意的是内敛闭包参数和返回值类型声明与backward(<em>:</em>:)类型声明相同。但在内连闭包表达式中，<strong>函数和返回值类型都写在大括号内而不是大括号外</strong>。<strong>闭包的函数体部分由关键字in</strong>引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。 </p><ul><li>根据上下文推断类型</li></ul><p>sorted(by:)方法的参数是传入的，swift可以推断其参数和返回值类型，sorted被一个字符串数组调用，因此参数必须为(string,string)-&gt;bool类型的函数。这意味者(string,string) 和bool类型不需要作为闭包表达式的一部分，因为所有的类型都可以被正确推断，返回箭头和围绕在参数周围的括号也可以省略：</p><pre><code>reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )//类型推断省略了参数类型以及箭头</code></pre><p>实际上，通过闭包表达式构造的闭包作为参数传递给函数或者方法时，总是可以推断出闭包的参数和返回值类型。因此可以不需要完整的格式构造内联闭包。</p><ul><li>但表达式闭包的隐式返回</li></ul><p>单行表达式闭包可以通过省略return来隐式返回单行表达式的结果。</p><pre><code>reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )</code></pre><ul><li>参数名称缩写</li></ul><p>swift自动为内联闭包提供了参数名称缩写，可以通过$0,$1,$2…来顺序调用闭包参数。</p><p>如果在闭包表达式中使用名称缩写，可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。in关键字也可以省略，因为此时闭包表达式完全由闭包函数体构成。</p><pre><code>reversedNames = names.sorted(by: { $0 &gt; $1 } )</code></pre><ul><li>运算符方法</li></ul><p>swift中的string类型定义了关于大于号(&gt;)的字符串实现，其作为一个函数接受两个string类型的参数并返回bool类型。刚好满足sorted函数的参数要求。因此可以如下:</p><pre><code>reversedNames = names.sorted(by: &gt;)</code></pre><ul><li>尾随闭包</li></ul><p>如果<strong>需要将一个很长的闭包表达式作为最后一个参数传递给函数</strong>，这个闭包替换成尾随闭包的形式效果更好。尾随闭包格式如下：</p><pre><code>    func someFunctionThatTakesAClosure(closure: () -&gt; Void) {    // 函数体部分}// 以下是不使用尾随闭包进行函数调用someFunctionThatTakesAClosure(closure: {    // 闭包主体部分})// 以下是使用尾随闭包进行函数调用someFunctionThatTakesAClosure() {    // 闭包主体部分}</code></pre><p>在闭包表达式语法章节字符串闭包可以作为尾随闭包的形式改写为：</p><pre><code>reversedNames = names.sorted() { $0 &gt; $1 }</code></pre><p>当闭包表达式时函数或者方法的唯一参数，当你使用尾随闭包时，可以省略为如下：</p><pre><code>reversedNames = names.sorted { $0 &gt; $1 } //省略括号</code></pre><p>当闭包非常长不能一行书写时，尾随闭包非常有用。举例来说，下面介绍了如何在map(_:)方法中使用尾随闭包将Int类型数组[16,58,510]转换为包含对应string类型的值的数组。</p><pre><code>let digitNames = [0: &quot;Zero&quot;, 1: &quot;One&quot;, 2: &quot;Two&quot;,   3: &quot;Three&quot;, 4: &quot;Four&quot;,5: &quot;Five&quot;, 6: &quot;Six&quot;, 7: &quot;Seven&quot;, 8: &quot;Eight&quot;, 9: &quot;Nine&quot;]let numbers = [16, 58, 510]</code></pre><p>上述代码创建了一个整型数位和他们英文名映射的字典，和一个转换数组。现在可以通过传递一个尾随闭包给numbers数组的map(_:)方法来创建对应的字符串版本数组。</p><pre><code>let strings = numbers.map {(number) -&gt; String invar number = numbervar output = &quot;&quot;repeat {    output = digitNames[number % 10]! + output    number /= 10} while number &gt; 0return output}// strings 常量被推断为字符串类型数组，即 [String]// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code></pre><p>上述例子中，number为前面定义的局部变量，因此可以在闭包函数体内对其进行修改。闭包表达式指定了返回类型为string。闭包表达式每次调用时创建一个output并返回结果。</p><ul><li>值捕获</li></ul><p>闭包可以在其被定义的上下文中捕获常量或者变量。即使定义这些常量的原作用域已经不存在，但是闭包任然可以在闭包函数体内引用和修改这些值。swift中捕获值得最简单形式是嵌套函数，嵌套函数可以捕获其外部函数得所有参数以及定义得常量和变量。</p><ul><li>闭包是引用类型</li></ul><p>无论是将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或者变量的值设置为对应函数或闭包的引用。这意味着将闭包赋值给两个不同的常量或者变量，两个值都指向同一个闭包。</p><p>逃逸闭包，自动闭包参考<a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/07_closures" target="_blank" rel="noopener">https://swiftgg.gitbook.io/swift/swift-jiao-cheng/07_closures</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h3&gt;&lt;p&gt;swift统一的函数语法非常灵活，可以用来表示任何函数，包括最简单的没有参数名字的c风格函数，到复杂的带局部外部参数名的OC风格参数，参数可以听过默认值，以简化函数调用。参数也可以及当作传入参数，也当作传出参数。也就是说，一旦函数执行，传入的参数值会被修改。&lt;/p&gt;
&lt;p&gt;swift中每一个函数都有一个由函数的参数类型和返回值类型组成的类型。可以把函数类型当作任何其他变量类型处理。这样可以简单的把函数当作别的函数的参数。也可以从其他函数中返回函数。函数定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现封装。&lt;/p&gt;</summary>
    
    
    
    <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
    <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
</feed>
