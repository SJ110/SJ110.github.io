<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaopingpp</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-10-27T10:11:45.913Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xiaopingpp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS事件机制</title>
    <link href="http://yoursite.com/2021/10/25/iOS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/10/25/iOS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-10-25T03:09:39.000Z</published>
    <updated>2021-10-27T10:11:45.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;按照时间顺序,事件的生命周期包括事件的产生和传递(事件从父控件传递到子控件并找到合适的view)和事件的处理(对于事件的响应).其中的重点是:1、触摸事件由触屏生成后如何传递到当前应用.2、应用接收触摸事件后如何寻找最佳响应者.3、响应事件如何沿着响应链流动.4、响应链(UIResponder),手势识别器(UIGesture),UIControl之间的关系.</p><p>&ensp;&ensp;当用户触碰了屏幕后,整个事件的传递和响应的流程基本如下:<br>1、点击到屏幕上的某一点被封装成为触摸事件添加到UI Application对象的事件队列中.这个队列按照fifo的顺序执行其中的触摸事件.事件出队列时,UIApplication开始寻找一个最佳响应者,过程称为这个过程称为hit-testing.<br>2、当找到一个最佳响应者后,接下来是事件的传递和响应.事件除了被最佳响应者消耗,还能被手势识别器或者targte-action模式捕捉或者消耗.<br>3、触摸事件要么会被某个响应对象捕获后释放,要么没有找到能够响应的对象,最终被释放.</p><a id="more"></a><h3 id="触摸-事件-响应者"><a href="#触摸-事件-响应者" class="headerlink" title="触摸,事件,响应者"></a>触摸,事件,响应者</h3><h4 id="触摸–UITouch"><a href="#触摸–UITouch" class="headerlink" title="触摸–UITouch"></a>触摸–UITouch</h4><p>&ensp;&ensp;当手指触摸屏幕时,会生成一个UItaouch对象,如果多个手指同时触摸,会生成多个对象.如果两个手指以前以后触摸同一位置(双击),那么第一次触摸生成UITouch对象,第二次触摸更新这个对象,UItouch对象的tapCount从1变为2. 如果两个手指以前以后触摸位置不同,将生成两个UITouch对象,两者之间没有联系.每一个UITouch对象记录了触摸的一些信息,包括触摸事件,位置,阶段,所处的视图,窗口等信息.</p><h4 id="UIEvent"><a href="#UIEvent" class="headerlink" title="UIEvent"></a>UIEvent</h4><p>&ensp;&ensp;一个触摸事件对应一个UIEvent对象,其中的type属性标识了事件的类型(事件类型不只有触摸类型).UIEvent对象中包含了出发该事件的触摸对象集合,因为一个触摸事件可能包含多个UITouch对象.</p><h4 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h4><p>&ensp;&ensp;每一个响应者都是一个UIResponder对象或者是其子类.本身都具有相应事件的能力,<br>1、UIView<br>2、UIViewcontroller<br>3、UIApplication<br>4、Appdelegate<br>响应者之所以能响应事件,是因为UIResponder提供了如下四个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//手指触碰屏幕，触摸开始</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">//手指在屏幕上移动</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">//手指离开屏幕，触摸结束</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">//触摸结束前，某个系统事件中断了触摸，例如电话呼入</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure><p>这些方法会在响应者对象接收到事件的时候调用,用于对事件做出响应.</p><h3 id="寻找事件的最佳响应者"><a href="#寻找事件的最佳响应者" class="headerlink" title="寻找事件的最佳响应者"></a>寻找事件的最佳响应者</h3><p>&ensp;&ensp;当触摸事件产生时,因为触摸位置所在的视图不止一个,需要找到一个最适合响应的视图,这个过程叫做hit-testing,命中的最佳响应者称为hit-tested view.<br>1、应用程序收到事件后,如何寻找最佳响应者.2、寻找到最佳响应者过程中事件的拦截</p><h4 id="寻找最佳响应者-自上而下"><a href="#寻找最佳响应者-自上而下" class="headerlink" title="寻找最佳响应者-自上而下"></a>寻找最佳响应者-自上而下</h4><p>&ensp;&ensp;1、队列中的事件出队列后,application将事件传递给当前展示的window,2、如果window能响应事件,则传递给子视图.3、自视图如果能响应,则继续往下寻找,不能则传递给同级视图往下寻找.4、如果当前视图没有能响应事件的子视图了,则该视图就是最佳响应者.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIApplication-&gt;window-&gt;view-&gt;...-&gt;view</span><br></pre></td></tr></table></figure><p>需要注意的一点是,当寻找当前视图的子视图时,是从后(后添加)往前(先添加)寻找,判断是否可以响应.因为后添加的视图总是位于更上层.</p><h4 id="如何判断视图是否响应事件"><a href="#如何判断视图是否响应事件" class="headerlink" title="如何判断视图是否响应事件"></a>如何判断视图是否响应事件</h4><p>&ensp;&ensp;1、不允许交互:userInteractionEnabled = NO;2、视图隐藏:如果父视图hidden = yes,那么自视图也会隐藏,隐藏的视图无法接受事件.3、透明度:如果视图的alpha&lt;0.01,那么会认为视图透明,无法响应事件.</p><h4 id="hitTest-withEvent"><a href="#hitTest-withEvent" class="headerlink" title="hitTest:withEvent:"></a>hitTest:withEvent:</h4><p>&ensp;&ensp;hitTest:withEvent是每个view都可以响应的方法,如果当前视图无法响应事件,那么返回nil.如果当前视图可以响应事件,但是无子视图可以响应事件,则返回自身作为当前视图层级中事件响应者.如果当前视图可以响应,并且自视图也可以响应,则返回子视图中的响应者.<br>&ensp;&ensp;UIApplication响应hitTest:withEvent方法,传递UIWindow判断是否可以响应事件,如果可以,在调用UIWindow的子视图的hitTest:withEvent方法.最终返回一个结果给UIApplication.下面是hitTest:withEvent方法的大致实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    //3种状态无法响应事件</span><br><span class="line">     if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha &lt;= 0.01) return nil; </span><br><span class="line">    //触摸点若不在当前视图上则无法响应事件</span><br><span class="line">    if ([self pointInside:point withEvent:event] == NO) return nil; </span><br><span class="line">    //从后往前遍历子视图数组 </span><br><span class="line">    int count = (int)self.subviews.count; </span><br><span class="line">    for (int i = count - 1; i &gt;= 0; i--) </span><br><span class="line">    &#123; </span><br><span class="line">        // 获取子视图</span><br><span class="line">        UIView *childView = self.subviews[i]; </span><br><span class="line">        // 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标</span><br><span class="line">        CGPoint childP = [self convertPoint:point toView:childView]; </span><br><span class="line">        //询问子视图层级中的最佳响应视图</span><br><span class="line">        UIView *fitView = [childView hitTest:childP withEvent:event]; </span><br><span class="line">        if (fitView) </span><br><span class="line">        &#123;</span><br><span class="line">            //如果子视图中有更合适的就返回</span><br><span class="line">            return fitView; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    //没有在子视图中找到更合适的响应视图，那么自身就是最合适的</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中pointInside:withEvent方法,判断如果坐标在自身坐标范围内则返回true,否则返回false.<br>&ensp;&ensp;对于如下视图,点击图中的view查看效果</p><p><img src="/2021/10/25/iOS事件机制/views.png" alt="views"></p><p>当点击view4的时候,可以看到其中的hitview的传递过程和响应链的传递过程</p><p><img src="/2021/10/25/iOS事件机制/consequens.png" alt="consequens"><br>&ensp;&ensp;因为是从最上层的view开始遍历,因此直接找到了view4,找到之后,开始事件的响应链传递,一层层传递到了application中.</p><h4 id="hit—testing过程中的事件拦截"><a href="#hit—testing过程中的事件拦截" class="headerlink" title="hit—testing过程中的事件拦截"></a>hit—testing过程中的事件拦截</h4><p>&ensp;&ensp;实际开发时会遇到一些特殊的交互需求,例如对tabbar中建的按钮,对于超过tabbar的部分点击是没有响应的,<br><img src="/2021/10/25/iOS事件机制/tabbar.png" alt="tabbar"></p><p>&ensp;&ensp;分析途中的事件触摸事件传递过程 window-rootview-tabbar-circlbutton,如果点击位置在tabbar内部,事件是可以传递到circlebutton的,但是点击在tabbar外部时,事件传递到tabbar后,因为点击区域在其之外,所以hit-testing返回了nil,认为其不可以响应事件,传递到tabbar的之外的视图上.<br>&ensp;&ensp;这个问题的解决方案是,当点击圆圈上部时,当事件传递到tabbar,pointInside:方法返回了no,因此,可以重写tabbar的pointInside:方法,如果触摸点在圆圈内部则返回true,否则才返回no,这样才可以让事件传递到源泉内部.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//TabBar</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    //将触摸点坐标转换到在CircleButton上的坐标</span><br><span class="line">    CGPoint pointTemp = [self convertPoint:point toView:_CircleButton];</span><br><span class="line">    //若触摸点在CricleButton上则返回YES</span><br><span class="line">    if ([_CircleButton pointInside:pointTemp withEvent:event]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    //否则返回默认的操作</span><br><span class="line">    return [super pointInside:point withEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件的响应及在响应链中传递"><a href="#事件的响应及在响应链中传递" class="headerlink" title="事件的响应及在响应链中传递"></a>事件的响应及在响应链中传递</h4><p>&ensp;&ensp;确定了最佳响应者之后,同时事件(UIevent)也会从uiwindow一起传递到视图上.通过重写uirsponder的触摸方法,可以实现截获对事件的处理,实现对视图的拖动和画图等功能.</p><p>&ensp;&ensp;响应链,响应者对于触摸事件的拦截和传递通过touchesBegan:方法控制,该方法,默认是将响应链向上进行传递.如果进行重写,可以做如下处理:<br>1、不拦截,继续往下传递<br>2、拦截,自行处理事件,但是不在继续往下传递.<br>3、拦截,自行处理事件,同时继续将事件往下传递.<br>事件向下继续传递通过super调用方法实现.向下传递是将事件传递给nextResponder, 对于UIView,nextResponder是其父视图,对于UIViewcontroller,nextResponder是presenting view controller或者UIWindow.UIWindow的nextResponder为UIApplication对象。<br>在touchBegin方法中调用如下方法可以查看nextResponder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)printResponderChain</span><br><span class="line">&#123;</span><br><span class="line">    UIResponder *responder = self;</span><br><span class="line">    printf(&quot;%s&quot;,[NSStringFromClass([responder class]) UTF8String]);</span><br><span class="line">    while (responder.nextResponder) &#123;</span><br><span class="line">        responder = responder.nextResponder;</span><br><span class="line">        printf(&quot; --&gt; %s&quot;,[NSStringFromClass([responder class]) UTF8String]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UIResponder-UIgestureRecognier-UIControl"><a href="#UIResponder-UIgestureRecognier-UIControl" class="headerlink" title="UIResponder,UIgestureRecognier, UIControl"></a>UIResponder,UIgestureRecognier, UIControl</h3><p>&ensp;&ensp;除了responder,手势和UIControl都可以处理事件,当他们同时出现时,会有什么结果呢?</p><h4 id="几个结论"><a href="#几个结论" class="headerlink" title="几个结论"></a>几个结论</h4><p>&ensp;&ensp;1、手势响应优先级最高(UIgestureRecognier),点击事件响应链优先级较低.很多的手势冲突都是事件的优先级没有捋清.<br>2、单击事件优先传递给手势响应,如果手势识别成功,那么就取消事件响应链的传递.<br>3、如果手势识别晒白,那么触摸事件就会继续在响应链中传递下去.</p><h4 id="事件的几个概念"><a href="#事件的几个概念" class="headerlink" title="事件的几个概念"></a>事件的几个概念</h4><p>1、UITouch,当一根手指触摸屏幕时,会创建一个与之关联的UITouch对象.手指离开屏幕时对象销毁.<br>2、UIEvent,一个UIEvent对象对应多个UITouch对象,从第一个手指触摸屏幕到最后一个手指离开屏幕.<br>3、UIResponder,所有继承了UIResponder的对象都可以接受并处理事件.</p><h4 id="手势识别和事件响应混用"><a href="#手势识别和事件响应混用" class="headerlink" title="手势识别和事件响应混用"></a>手势识别和事件响应混用</h4><p>对于如下界面<br><img src="/2021/10/25/iOS事件机制/conflict.png" alt="conflict"><br>backView添加手势,同事增加事件传递的touch方法,btn增加增加target-action,testView增加事件传递的Touch方法.</p><p>1、点击backView:<br><img src="/2021/10/25/iOS事件机制/backclick.png" alt="backclick"></p><p>2、点击testView<br><img src="/2021/10/25/iOS事件机制/testclick.png" alt="testclick"></p><p>3、点击按钮<br><img src="/2021/10/25/iOS事件机制/btnclick.png" alt="btnclick"></p><p>4、按住testView,过5秒松开<br><img src="/2021/10/25/iOS事件机制/testviewreclick.png" alt="testviewreclick"></p><p>&ensp;&ensp;对于1,2手势和响应链都触发了,但是最后响应链cancel了,说明触摸对象被取消,只有手势继续执行了.因此,在手势和事件响应链同时存在时,识别出了手势就会将触摸对象取消.</p><p>&ensp;&ensp;对于场景3,默认控制操作可以防止重叠的手势识别器,对于按钮的默认操作是点击,因此会忽略掉手势动作.</p><p>&ensp;&ensp;对于场景4,长按testView,tap手势会识别失败,手势识别失败后,就用事件调用链进行处理.</p><h4 id="实际开发中遇到的问题"><a href="#实际开发中遇到的问题" class="headerlink" title="实际开发中遇到的问题"></a>实际开发中遇到的问题</h4><p>&ensp;&ensp;实际开发中,为了不让父视图手势识别干扰子视图的点击事件响应和响应链的传递,一般重写UIGestureRecognizerDelegate中的gestureRecognizer:方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch  </span><br><span class="line">&#123;  </span><br><span class="line">     // 若为UITableViewCellContentView（即点击了tableViewCell），</span><br><span class="line">    if ([NSStringFromClass([touch.view class]) isEqualToString:@&quot;UITableViewCellContentView&quot;]) &#123;  </span><br><span class="line">    // cell 不需要响应 父视图的手势，保证didselect 可以正常</span><br><span class="line">        return NO;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //默认都需要响应</span><br><span class="line">    return  YES;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;参考文章</p><p><a href="https://www.jianshu.com/p/c294d1bd963d" target="_blank" rel="noopener">iOS触摸事件全家桶</a></p><p><a href="https://www.jianshu.com/p/53e03e558cbd" target="_blank" rel="noopener">iOS点击事件和手势冲突</a></p><p><a href="https://www.jianshu.com/p/2e074db792ba" target="_blank" rel="noopener">史上最详细的iOS事件传递和响应</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;按照时间顺序,事件的生命周期包括事件的产生和传递(事件从父控件传递到子控件并找到合适的view)和事件的处理(对于事件的响应).其中的重点是:1、触摸事件由触屏生成后如何传递到当前应用.2、应用接收触摸事件后如何寻找最佳响应者.3、响应事件如何沿着响应链流动.4、响应链(UIResponder),手势识别器(UIGesture),UIControl之间的关系.&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;当用户触碰了屏幕后,整个事件的传递和响应的流程基本如下:&lt;br&gt;1、点击到屏幕上的某一点被封装成为触摸事件添加到UI Application对象的事件队列中.这个队列按照fifo的顺序执行其中的触摸事件.事件出队列时,UIApplication开始寻找一个最佳响应者,过程称为这个过程称为hit-testing.&lt;br&gt;2、当找到一个最佳响应者后,接下来是事件的传递和响应.事件除了被最佳响应者消耗,还能被手势识别器或者targte-action模式捕捉或者消耗.&lt;br&gt;3、触摸事件要么会被某个响应对象捕获后释放,要么没有找到能够响应的对象,最终被释放.&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>动态item实现的动态化</title>
    <link href="http://yoursite.com/2021/10/24/%E5%8A%A8%E6%80%81item%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A8%E6%80%81%E5%8C%96/"/>
    <id>http://yoursite.com/2021/10/24/%E5%8A%A8%E6%80%81item%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A8%E6%80%81%E5%8C%96/</id>
    <published>2021-10-24T02:25:49.000Z</published>
    <updated>2021-10-24T02:32:01.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;和匹配侧的各位同学一起维护动态item已经有一段时间了,一开始接触感觉这个东西很高深莫测,随着接触时间的增加,相关业务开发的处理,算是对动态item整个渲染过程有一些理解.在这里写一篇日志记录一下.<br>&ensp;&ensp;动态item以更加快速的构建用户ui视图,可以降低app发版诉求甚至在一些场景下可以免于app发版.<br>&ensp;&ensp;其中快速构建视图是通过动态item提前将描述ui视图结构通过描述性语言事先存放,在渲染阶段通过读取描述性的json文件,使用事先规定好的规则将视图渲染上屏.<br>&ensp;&ensp;让app免于发版是通过将描述文件放置到服务端,通过app冷启动接口下发,这样可以做到增量更新,一些新的需求发布之后,只需修改描述文件中的某一项,不需要改动到native代码,即可完成视图的渲染,降低了发版次数.</p><a id="more"></a><h3 id="渲染流程–流程图"><a href="#渲染流程–流程图" class="headerlink" title="渲染流程–流程图"></a>渲染流程–流程图</h3><p>&ensp;&ensp;因为动态item存在这样的特性,相较于一般的ui层渲染,他需要多一个配置文件. 整个渲染流程图如下</p><p><img src="/2021/10/24/动态item实现的动态化/process.png" alt="process"></p><h3 id="渲染流程–配置文件"><a href="#渲染流程–配置文件" class="headerlink" title="渲染流程–配置文件"></a>渲染流程–配置文件</h3><p>&ensp;&ensp;在业务中中动态item主要用于列表的渲染,下面就以列表卡片为例概述下整个流程,因为卡片样式改动较小,并且交互较低.所以一次配置文件完成后,可以较长时间内不在变动.<br>&ensp;&ensp;对于一个列表卡片,渲染流程中主要关注tableview的两个代理方法一个是cellforrow方法,一个是heighforrow方法.其中cellforrow方法需要返回一个卡片,在这个方法内就可以按需进行ui的搭建.<br>&ensp;&ensp;&ensp;&ensp;动态item的ui搭建使用从上到下从做到右的顺序进行每一行作为一个容器,整个卡片又作为一个更大的容器,因此,在内部可以实现递归的UI搭建:以其中一条数据搭建为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      &quot;fontColor&quot;: &quot;#333333&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;fontSize&quot;: 18,</span><br><span class="line"></span><br><span class="line">      &quot;isBold&quot;: 1,</span><br><span class="line"></span><br><span class="line">      &quot;hasTags&quot;: 1,</span><br><span class="line"></span><br><span class="line">      &quot;key&quot;: &quot;startAndEnd&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;maxLines&quot;: 2,</span><br><span class="line"></span><br><span class="line">      &quot;widgetType&quot;: 0</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  &quot;rowStyle&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &quot;marginRight&quot;: 75</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &quot;rowType&quot;: 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染流程–ui"><a href="#渲染流程–ui" class="headerlink" title="渲染流程–ui"></a>渲染流程–ui</h3><p>&ensp;&ensp;这是一个”item“,其中的“key”值,对应从接口取数据的”key“值.“data”是一个数组,表示内部可以容纳多个”item“,”rowstyle“用来描绘该容器的位置 “rowType”描绘该容器的类型,比如是否嵌套等.<br>&ensp;&ensp;”widgetType“ 标识当前视图的类型,可能是view,label,button,image等. 因此对于每一个item,都可以按照类似的方式设置其内部的视图,默认内部视图是从左到右排列的,有了这个实例,可以看到,data内的每一个元素可以做很多的扩展,比如想添加borderline,添加富文本等,都可以新增一个key值去加以标识.最后值的渲染只需要保证前后端约定的”key”的内容一致即可.<br>&ensp;&ensp;cellforrow对数据源做了处理,也约定了卡片某个容器的位置,但是容器需要多大,最终整个卡片需要多高是需要通过heightforrow去处理的.<br>&ensp;&ensp;item中只指定了每个容器和容器内部每个视图间的间隔,因此容器大小和容器内每个视图的大小都需要根据内容进行处理. heightforrow 就是需要统计内部视图最终的高度来得到cell的高度.</p><h3 id="渲染流程–上屏展示"><a href="#渲染流程–上屏展示" class="headerlink" title="渲染流程–上屏展示"></a>渲染流程–上屏展示</h3><p>&ensp;&ensp;当卡片的高度确定,卡片内的内容确定之后就可以通过数据源赋值然后上屏展示了.在页面的滑动过程中,因为会存在cell的复用机制,但是在业务上每个卡片的高度是不统一的,卡片的重用也是通过模版内的一个字段加以控制,就算是字段名相同,业务接口返回的数据也可能缺少某些条目导致卡片高度不同,因此在性能上会造成一定的损耗,不过这也是业务不断变化导致的不可控制的结果.理想情况下动态item创建的卡片应该变化很小,但是业务却不断往卡片中增加内容,导致规范性降低.</p><h3 id="思考和感悟"><a href="#思考和感悟" class="headerlink" title="思考和感悟"></a>思考和感悟</h3><p>&ensp;&ensp;动态item是为了快速搭建ui和解决因业务迭代带来的app发版频次问题,在满帮主要应用在列表卡片上.但是由于以往的ui不规范,加上一开始时间紧迫导致设计的不完整,对于当前的迭代已经显得疲软了.但是动态item的思路是很不错的,他增加了一个配置文件,通过这个桥梁将一些依靠native代码的东西方法哦服务端接口.对于变动不大并且交互较少的视图是很有用的.并且可以在当前能力的基础上在扩展很多其他的能力.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;和匹配侧的各位同学一起维护动态item已经有一段时间了,一开始接触感觉这个东西很高深莫测,随着接触时间的增加,相关业务开发的处理,算是对动态item整个渲染过程有一些理解.在这里写一篇日志记录一下.&lt;br&gt;&amp;ensp;&amp;ensp;动态item以更加快速的构建用户ui视图,可以降低app发版诉求甚至在一些场景下可以免于app发版.&lt;br&gt;&amp;ensp;&amp;ensp;其中快速构建视图是通过动态item提前将描述ui视图结构通过描述性语言事先存放,在渲染阶段通过读取描述性的json文件,使用事先规定好的规则将视图渲染上屏.&lt;br&gt;&amp;ensp;&amp;ensp;让app免于发版是通过将描述文件放置到服务端,通过app冷启动接口下发,这样可以做到增量更新,一些新的需求发布之后,只需修改描述文件中的某一项,不需要改动到native代码,即可完成视图的渲染,降低了发版次数.&lt;/p&gt;</summary>
    
    
    
    <category term="动态化" scheme="http://yoursite.com/categories/动态化/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS多线程</title>
    <link href="http://yoursite.com/2021/10/08/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2021/10/08/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-10-08T07:03:49.000Z</published>
    <updated>2021-10-19T05:45:00.550Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp; 本文参考自<a href="https://weread.qq.com/web/reader/2ce3297071e2a5172ce5d66ke4d32d5015e4da3b7fbb1fa" target="_blank" rel="noopener">《iOS开发项目化经典教程》</a>第一章,主要讲述iOS实现多线程的四种方式，线程间的安全和通信，GCD的基本操作。NSOperation的基本操作。</p><p>&ensp;&ensp; 多线程概念：由于一个线程同一时间内只能处理一个任务，因此一个线程内的任务需要按顺序执行。因此在遇到网络请求，下载等耗时操作时，需要等待此类操作结束才能进行接下来的操作，这段时间内用户不能进行任何操作，app也不会响应用户的操作。这是一种很糟糕的用户体验。因此在开发过程中，通常把比较耗时的操作放到一个线程中，把和用户交互放到主线程中。保证能够及时响应用户的操作行为。</p><a id="more"></a><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>&ensp;&ensp; 进程:进程是系统中正在运行的程序，进程拥有自己的地址空间，程序加载进内存开始运行时就会变为一个进程。进程是系统进行资源分配和调度的基本单位。有三个特点:1、独立性，进程有独立的资源和地址访问空间。2、动态性，进程是程序在系统中的一次执行过程，进程时一个正在系统中活动的指令的集合，其中加入了时间的概念。具有自己的生命周期和各自不同的状态。3、并发性,进程可以在单个处理器中并发执行，虽然宏观上是并发的，但是从微观上看，cpu在一个时间片内只能执行一条指令，因此在宏观时间内也是各个进程不断相互切换执行。<br>&ensp;&ensp; 线程:线程是任务调度和执行的基本单位，线程扩展了进程的概念，一个进程要运行至少需要一个线程，这个线程成为称为主线程。当进程被初始化后，线程就被创建了。进程内的每个线程是相互独立的。<br>&ensp;&ensp;进程中包含若干线程，这些线程可以利用进程所拥有的资源。由于线程比进程更加轻量，对线程的调用开销就会比进程的开销小的多。因此多线程更能提高系统中多个程序间的并发程度。当使用多线程进行开发时需要注意:1、线程虽然占用资源较低，但是也需要一定的内存空间，如果开启大量线程，就会占用大量内存空间导致程序卡顿。3、开启的线程越多，cpu在进行调度时的开销就越大。因此不要同时开启超过5个线程。3、使用多线程时需要保证数据的统一性。可以采用加锁的方式实现数据的独占访问。</p><h4 id="线程的串行和并行"><a href="#线程的串行和并行" class="headerlink" title="线程的串行和并行"></a>线程的串行和并行</h4><p>&ensp;&ensp;一个进程中如果只包含一个线程，那么当多个任务需要执行时只能由这个线程去一个一个串行执行。如果进程中包含不止一条线程，那每条线程可以同时执行不同的任务，称之为线程的并行，也即多线程。需要注意的是，cpu在同一个时间内只能处理一个线程，也就是同一时间只有一个线程在工作，不过cpu切换很快，用户感知不到。</p><h4 id="多线程分类"><a href="#多线程分类" class="headerlink" title="多线程分类"></a>多线程分类</h4><p>&ensp;&ensp; iOS提供了四种现实多线程的方式，pthread:使用c语言实现，是跨平台的多线程api。NSThread:使用oc实现。GCD:使用c实现，对线程管理进行了封装，是常用的多线程开发手段。NSOperation:基于GCD进行了二次封装，使其使用更加面向对象。</p><p><img src="/2021/10/08/iOS多线程/threads.png" alt="threads"></p><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>&ensp;&ensp;当线程被创建并启动时，线程并不是直接开始执行，而线程开始执行之后也不是一直在执行。而是随着cpu的时间片轮转不停的切换状态。下图是进程的状态切换过程图。</p><p><img src="/2021/10/08/iOS多线程/thread_state.png" alt="thread_state"></p><p>1、创建，当创建一个线程之后，该线程就处于新建的状态，仅由系统分配了内存，初始化了其内部成员变量的值。2、就绪，当线程调用了start方法之后，线程就处于就绪态了，处于就绪态的线程并没有开始执行，只是表示可以开始执行了。何时开始执行由系统控制。 3、运行，当cpu分配的时间片调用当前线程时，其他线程处于挂起状态，该线程处于运行状态。4、终止，当线程执行结束，或者调用exit方式终止，或者执行过程中出现异常，线程变为终止状态。5、阻塞，如果当前线程需要暂停一段时间，则可以调用sleep方法让线程进入阻塞态。</p><h4 id="线程间的安全隐患"><a href="#线程间的安全隐患" class="headerlink" title="线程间的安全隐患"></a>线程间的安全隐患</h4><p>&ensp;&ensp;如果进程中的一块资源被多个线程共享，那么这块资源称为临界资源，当多个线程同时访问一块资源时，会出现资源的抢占和数据错乱等问题。为了实现数据的安全访问，可以使用线程间加锁的方式，下面通过一个卖票的例子展示一下：</p><p><img src="/2021/10/08/iOS多线程/saletickets.png" alt="saletickets"></p><p>&ensp;&ensp;从途中可以看到,多个线程访问临界资源时会发生数据错乱,为了解决这种问题,需要给临界资源加锁,加锁可以保证同一时刻只有一个线程能够访问临界资源,使用<strong>@synchronized</strong>关键字可以实现加锁.需要注意的是使用同步锁会消耗大量cpu资源,所以应该把同步锁内的代码量尽量减少.<br><img src="/2021/10/08/iOS多线程/thread_state2.png" alt="thread_state2"></p><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><p>&ensp;&ensp;在一个进程中,其线程往往不是孤立存在的,他们之间可以相互通信,比如一个线程需要等到另外一个线程任务执行完毕后才能开始执行.在做任务转换的同时也可能有数据的转换.</p><h3 id="使用NSThread实现多线程"><a href="#使用NSThread实现多线程" class="headerlink" title="使用NSThread实现多线程"></a>使用NSThread实现多线程</h3><p>&ensp;&ensp;下面通过一个实例来演示NSThread的三种创建方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// 需要调用start启动线程</span><br><span class="line">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;</span><br><span class="line"></span><br><span class="line">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</span><br><span class="line"></span><br><span class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg;</span><br></pre></td></tr></table></figure><p>三种不同的线程创建方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    _btn = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">    [_btn setTitle:@&quot;创建线程&quot; forState:UIControlStateNormal];</span><br><span class="line">    [_btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];</span><br><span class="line">    _btn.titleEdgeInsets = UIEdgeInsetsMake(5, 20, 5, 20);</span><br><span class="line">    _btn.frame = CGRectMake(self.view.frame.size.width/2-70, 300, 140, 50);</span><br><span class="line">    [_btn addTarget:self action:@selector(onClick) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:_btn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)onClick &#123;</span><br><span class="line">    NSThread *currentThread = [NSThread currentThread];</span><br><span class="line">    NSLog(@&quot;btnclick--%@--current&quot;,currentThread);</span><br><span class="line">    NSThread *mainThread = [NSThread mainThread];</span><br><span class="line">    NSLog(@&quot;btnclick--%@--main&quot;,mainThread);</span><br><span class="line">//    [self threadCreate1];</span><br><span class="line">//    [self threadCreate2];</span><br><span class="line">    [self threadCreate3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run:(NSString *)params &#123;</span><br><span class="line">    NSThread *cur = [NSThread currentThread];</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        NSLog(@&quot;%@---call run--%@&quot;,cur,params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// 第一种初始化</span><br><span class="line">-(void)threadCreate1 &#123;</span><br><span class="line">    NSThread *threadA = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@&quot;threadA&quot;];</span><br><span class="line">    threadA.name = @&quot;线程A&quot;;</span><br><span class="line">    /// 必须使用start启动线程</span><br><span class="line">    [threadA start];</span><br><span class="line">    NSThread *threadB = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@&quot;threadB&quot;];</span><br><span class="line">    threadB.name = @&quot;线程B&quot;;</span><br><span class="line">    [threadB start];</span><br><span class="line">&#125;</span><br><span class="line">/// 第二种初始化</span><br><span class="line">- (void)threadCreate2 &#123;</span><br><span class="line">    [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;threadCreate2&quot;];</span><br><span class="line">&#125;</span><br><span class="line">/// 第三种初始化</span><br><span class="line">- (void)threadCreate3 &#123;</span><br><span class="line">    [self performSelectorInBackground:@selector(run:) withObject:@&quot;threadCreate3&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;主线程的名字是main，手动创建的线程可以重新命名。</p><h3 id="使用GCD实现多线程"><a href="#使用GCD实现多线程" class="headerlink" title="使用GCD实现多线程"></a>使用GCD实现多线程</h3><p>&ensp;&ensp;使用GCD可以比NSThread更快,更方便的实现多线程的处理,使用GCD需要明确两个概念,队列和任务.队列:队列时GCD中用来存放任务的集合,负责管理开发者提交的任务.队列的核心就是将长期执行的任务分成多个工作单元,并将任务添加到队列中,系统会带为管理这些队列.并放到多线程中执行.队列分为串行队列和并行队列.串行队列内部只维护一个线程,一次只能执行一个任务.任务串行执行.并行队列内部维护了多个线程,可以按照如队列顺序并行执行. 任务:任务时用户提交给队列的工作单元,也就是在队列中执行的代码块.任务提交后会由队列以多线程的方式执行.</p><h4 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h4><p>&ensp;&ensp;全局并发队列,全局并发队列可以并行的执行多个任务,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//identifier 指定队列优先级</span><br><span class="line">// flags 保留字段,方便以后扩展</span><br><span class="line">dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)</span><br><span class="line"></span><br><span class="line">// 实例</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;创建串行队列和并行队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建队列</span><br><span class="line">//label 表示队列的字符串(c字符串)</span><br><span class="line">//attr 标识串行还是并行 DISPATCH_QUEUE_SERIAL 串行, DISPATCH_QUEUE_CONCURRENT 并行</span><br><span class="line">dispatch_queue_t dispatch_queue_create(const char *_Nullable label,dispatch_queue_attr_t _Nullable attr);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;获取主队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// 获取主队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure><h4 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h4><p>&ensp;&ensp;队列创建结束之后,可以通过同步和异步两种方式想队列提交任务. 同步执行:同步执行的任务只会在当前线程执行任务,不会开启新线程.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">///同步执行</span><br><span class="line">/// queue 将要提交到的任务队列, block 执行的代码块</span><br><span class="line">dispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;异步执行任务,异步执行会在新线程中执行任务具备开启新线程的能力,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">///异步执行</span><br><span class="line">///queue 将要提交到的任务队列, block 执行的代码块</span><br><span class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;下面是一个代码实例,展示了串行队列下的同行执行和并行队列下的同步执行,串行队列下的异步执行和并行队列下的异步执行.</p><p>同步执行不会开启新的线程,是在主线程完成任务的,同步的并行也不会开启新线程,两个都是串行执行任务.<br><img src="/2021/10/08/iOS多线程/serialSerial.png" alt="syncSerial"></p><p>异步执行串行队列的任务,会开启新线程,但是任务串行执行.<br><img src="/2021/10/08/iOS多线程/concerrentSerial.png" alt="asyncSerial"></p><p>异步执行并行队列任务,会开启新线程,任务并行执行.<br><img src="/2021/10/08/iOS多线程/asyncConcerrent.ong" alt="asyncConcerrent"></p><p>&ensp;&ensp;下表展示了同步执行串行队列任务和并行队列任务,异步执行串行队列任务和并行队列任务的结果<br><img src="/2021/10/08/iOS多线程/outcome.ong" alt="outcome"></p><h4 id="单次或者重复执行任务"><a href="#单次或者重复执行任务" class="headerlink" title="单次或者重复执行任务"></a>单次或者重复执行任务</h4><p>&ensp;&ensp;如果想要某些操作只执行一次,可以使用dispatch_once()实现,干函数接收两个参数,第一个参数接收一个标识符,用来标识代码代码是否已经执行.第二个参数是只执行一次的代码块.如果想要某些操作重复执行多次,可以使用dispatch_apply();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// iterations 需要执行的次数  queue 任务需要提交的目标队列  block 需要重复执行的代码块</span><br><span class="line">void dispatch_apply(size_t iterations,</span><br><span class="line">dispatch_queue_t DISPATCH_APPLY_QUEUE_ARG_NULLABILITY queue,</span><br><span class="line">DISPATCH_NOESCAPE void (^block)(size_t));</span><br></pre></td></tr></table></figure><h4 id="调度队列组"><a href="#调度队列组" class="headerlink" title="调度队列组"></a>调度队列组</h4><p>&ensp;&ensp;假设有如下一个一个场景,一个音乐app,需要执行多个下载任务,这些下载任务会放到后台的多个线程中执行,当全部下载任务结束之后,弹出一个提示框告知用于下载结束.<br>这种场景可以使用队列组在实现.使用dispatch_group_create()创建队列组,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// 创建队列组</span><br><span class="line">dispatch_group_t dispatch_group_create(void);</span><br></pre></td></tr></table></figure><p>创建队列组后,可以使用dispatch_group_async()函数将需要执行的任务提交到队列组,会异步的执行任务组中的任务,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// 异步执行队列组中的任务 group,队列组  queue,任务需要提交到的队列, block,需要执行的代码块</span><br><span class="line">void dispatch_group_async(dispatch_group_t group,</span><br><span class="line">dispatch_queue_t queue,</span><br><span class="line">dispatch_block_t block);</span><br></pre></td></tr></table></figure><p>任务组中的任务执行完之后可以通过dispatch_group_notify()来通知,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// group, 创建的队列组 queue,将要执行的任务所添加到的队列  block,执行的代码块</span><br><span class="line">void dispatch_group_notify(dispatch_group_t group,</span><br><span class="line">dispatch_queue_t queue,</span><br><span class="line">dispatch_block_t block);</span><br></pre></td></tr></table></figure><p>这里的demo展示的是使用队列组进行图片下载,在图片下载完成后,回到主队列进行渲染和展示.但是队列组中的每一次下载都是新开了线程,并且是并行执行的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)groupImage &#123;</span><br><span class="line">    __block typeof(self) weakSelf=self;</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    __block UIImage *img1 = nil;</span><br><span class="line">    dispatch_group_async(group, global_queque, ^&#123;</span><br><span class="line">        img1 = [weakSelf downloadImage:@&quot;http://statics.888ppt.com/Upload/photothumb/6J93jXFHs24.jpg&quot;];</span><br><span class="line">        NSLog(@&quot;--%@--&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    __block UIImage *img2 = nil;</span><br><span class="line">    dispatch_group_async(group, global_queque, ^&#123;</span><br><span class="line">        img2 = [weakSelf downloadImage:@&quot;http://up.enterdesk.com/edpic/d4/32/68/d43268ae15cefc60c54b8b0f94a46c74.jpg&quot;];</span><br><span class="line">        NSLog(@&quot;--%@--&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_notify(group, global_queque, ^&#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            weakSelf.imgView1.image = img1;</span><br><span class="line">            weakSelf.imgView2.image = img2;</span><br><span class="line">            NSLog(@&quot;--%@--&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用NSOperation实现多线程"><a href="#使用NSOperation实现多线程" class="headerlink" title="使用NSOperation实现多线程"></a>使用NSOperation实现多线程</h3><p>&ensp;&ensp;NSOperation是使用oc封装的基于gcd的多线程处理方式,更加面向对象<strong>1、执行操作</strong>,如果要执行一个NSOperation对象,可以通过1、手动调用start方法实现,这个方法调用之后,就会在当前调用的线程同步执行任务.2、可以将NSOperation添加到NSOperationQueue中,NSOperationQueue会在NSOperation被添加进去后尽快执行,并且是异步执行.<strong>2、取消操作</strong>,当一个operation开始执行后,默认会一直执行到结束,也可以调用cancel取消操作的执行,需要注意的是,如果操作在队列中没有开始执行,这时取消这个操作,并将finished设置为YES,此时操作就直接取消了.如果操作正在执行,设置cancel方法也只能等待操作执行完.<strong>3、添加依赖</strong>,可以将多个耗时的异步操作分成若干部分,当前一个执行完后在执行另一个,可以通过addDependency方法,协调先后关系.注意:两个任务间不能相互依赖,比如A依赖B,B依赖A,这样会导致思索.当每个操作结束后需要将isFinished设置为Yes.<strong>4、监听操作</strong>,使用setCompletionBlock可以在一个operation结束后做一些其他事情.</p><h4 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h4><p>&ensp;&ensp; NSOperationQueue与GCD队列一样,采用先进先出的方式,负责管理系统提交的多个NSOperation对象.NSOperationQueue负责管理其中持有的NSOperation对象,下面是一些常见的方法:<br><strong>1、添加NSOperation到NSOperationQueue中</strong>,将NSOperation添加到队列中,并由队列中的线程池管理和调度,使用如下方法来管理,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// ops,将要添加到队列的操作组, wait 是否等待操作结束后在返回,设置为yes会阻塞主线程</span><br><span class="line">- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait</span><br></pre></td></tr></table></figure><p>也可以使用如下方法来添加任务,添加任务到队列中后不要在手动更改任务的状态,队列会自行进行管理.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// block 将要执行的代码块</span><br><span class="line">- (void)addOperationWithBlock:(void (^)(void))block;</span><br></pre></td></tr></table></figure><p><strong>2、修改NSOperation对象执行顺序</strong>,对于添加到队列中的操作对象,执行顺序依赖亮点,1、操作对象是否已经是就绪态,2、操作对象的优先级高低.可以通过手动设置queuePriority在更改operation的优先级.<br><strong>3、设置操作队列的最大并发数量</strong>,当队列中线程过多时,会影响app的执行效率,因此可以设置对答并发数量来约束队列中的最大进程数<br><strong>4、等待NSOperation操作执行完成</strong>,不要在主线程使用如下方法,这回阻塞主线程.app显示为无响应.<br><strong>5、使用NSOperation子类进行操作</strong>,NSOperation是一个抽象基类,可以自行继承这个类创建自己的操作对象,也可以使用NSInvocationOperation和NSBlockOperatin来进行操作.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)waitUntilFinished ;</span><br><span class="line">- (void)waitUntilAllOperationsAreFinished;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;因此,使用NSOperation和NSOperationQueue两个类结合使用可以实现多线程,1、将需要执行的操作添加到NSOperation中.2、将NSOperation添加到NSOperationQueue中.3、系统自动取出NSOperationQueue中的对象.4、取出的对象会自动创建新线程进行.</p><p>&ensp;&ensp;上文中的demo参考<a href="https://github.com/SJ110/ios-animation-demo" target="_blank" rel="noopener">此处</a>即可.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp; 本文参考自&lt;a href=&quot;https://weread.qq.com/web/reader/2ce3297071e2a5172ce5d66ke4d32d5015e4da3b7fbb1fa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《iOS开发项目化经典教程》&lt;/a&gt;第一章,主要讲述iOS实现多线程的四种方式，线程间的安全和通信，GCD的基本操作。NSOperation的基本操作。&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp; 多线程概念：由于一个线程同一时间内只能处理一个任务，因此一个线程内的任务需要按顺序执行。因此在遇到网络请求，下载等耗时操作时，需要等待此类操作结束才能进行接下来的操作，这段时间内用户不能进行任何操作，app也不会响应用户的操作。这是一种很糟糕的用户体验。因此在开发过程中，通常把比较耗时的操作放到一个线程中，把和用户交互放到主线程中。保证能够及时响应用户的操作行为。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS动画基础</title>
    <link href="http://yoursite.com/2021/09/12/iOS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/09/12/iOS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/</id>
    <published>2021-09-12T07:09:54.000Z</published>
    <updated>2021-10-05T04:16:54.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;这边博客主要是总结一下最近看到ios动画开发的一些基础知识。主要包含如下一些知识点。主要参考自<a href="https://weread.qq.com/web/reader/56932a20719b1fcb569e111kf4532c00231f457c545ad3c" target="_blank" rel="noopener">《iOS开发实战：从入门到上架APPsotre》</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、使用UIImageView播放图片组动画</span><br><span class="line">2、使用block回调创建UIView层过渡动画</span><br><span class="line">3、使用block回调创建UIView层转场动画</span><br><span class="line">4、使用commit方式创建UIView层过渡动画</span><br><span class="line">5、使用commit方式创建UIView层转场动画</span><br><span class="line">6、CAlayer层在UI开发中的应用</span><br><span class="line">7、各种CALayer子类的用法</span><br><span class="line">8、coreAnimation核心动画框架的用法</span><br><span class="line">9、视图的transform变换</span><br><span class="line">10、粒子效果动画</span><br><span class="line">11、ios中播放GIF动态图的方法</span><br><span class="line">12、Flappy Bird动画小游戏</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="使用UIImageView播放图片组动画"><a href="#使用UIImageView播放图片组动画" class="headerlink" title="使用UIImageView播放图片组动画"></a>使用UIImageView播放图片组动画</h4><p>&ensp;&ensp;使用UIImageview的<strong><em>animationImages</em></strong>属性将需要播放的图片加载进去，设置播放时长，和重复次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(30, 100, 170, 460)];</span><br><span class="line">    NSMutableArray *imageArray = @[].mutableCopy;</span><br><span class="line">    for(int i = 1; i &lt;= 4;i++) &#123;</span><br><span class="line">        UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;VC1Image%d&quot;,i]];</span><br><span class="line">        [imageArray addObject:image];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.view addSubview:imageView];</span><br><span class="line">    imageView.animationImages = imageArray;</span><br><span class="line">    imageView.animationDuration = 0.4;</span><br><span class="line">    imageView.animationRepeatCount = 0; ///无限循环</span><br><span class="line">    [imageView startAnimating];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行后就会出现四张图无限轮播的动画效果。</p><h4 id="UIView层动画的应用"><a href="#UIView层动画的应用" class="headerlink" title="UIView层动画的应用"></a>UIView层动画的应用</h4><p>&ensp;&ensp;一般的开发中，对于UIView层的动画是使用非常广泛的。ios提供在UIView层上进行动画操作的类方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/// NSTimeInterval:动画持续时间</span><br><span class="line">///^(void)animations 需要执行的动画内容</span><br><span class="line">[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; animations:&lt;#^(void)animations#&gt;]</span><br><span class="line"></span><br><span class="line">///NSTimeInterval:同上</span><br><span class="line">///^(void)animations :同上</span><br><span class="line">/// ^(BOOL finished)completion 动画完成需要执行的动作</span><br><span class="line"> [UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;]</span><br><span class="line"></span><br><span class="line">/// UIViewAnimationOptions 动画执行的配置参数 枚举类型，比如淡入淡出效果等</span><br><span class="line">/// 动画配置参数的取值可以参考源码中的枚举定义</span><br><span class="line">/// delay 动画延迟执行时间</span><br><span class="line">[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; options:&lt;#(UIViewAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;]</span><br><span class="line"></span><br><span class="line">// usingSpringWithDamping 取值0-1，设置阻尼度</span><br><span class="line">// initialSpringVelocity 阻尼初速度</span><br><span class="line">[UIView animateWithDuration:&lt;#(NSTimeInterval)#&gt; delay:&lt;#(NSTimeInterval)#&gt; usingSpringWithDamping:&lt;#(CGFloat)#&gt; initialSpringVelocity:&lt;#(CGFloat)#&gt; options:&lt;#(UIViewAnimationOptions)#&gt; animations:&lt;#^(void)animations#&gt; completion:&lt;#^(BOOL finished)completion#&gt;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 40, 40)];</span><br><span class="line">    view.backgroundColor = [UIColor blueColor];</span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line">    NSTimeInterval times = 3;</span><br><span class="line">    [UIView animateWithDuration:times animations:^&#123;</span><br><span class="line">        view.frame = CGRectMake(200, 200, 80, 80);</span><br><span class="line">        view.backgroundColor = [UIColor redColor];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;运行代码可以看到图从蓝色变为红色 位置偏移，大小变化，持续时间3秒,其他几种动画效果参考demo</p><h5 id="UIView层过渡动画支持的属性"><a href="#UIView层过渡动画支持的属性" class="headerlink" title="UIView层过渡动画支持的属性"></a>UIView层过渡动画支持的属性</h5><p>&ensp;&ensp;动画的执行还可以进行嵌套，可以将动画分成几个部分，执行完某一部分后在其回调中执行下一部分，下面列出一些动画过渡中可以支持的属性</p><pre><code>1、frame:给视图的位置和尺寸实现过渡的动画效果。2、bounds:给视图内部的坐标原点改变和尺寸变化增加过渡效果3、center:为视图的4、transform:给视图的几何变换增加过渡动画5、alpha:给视图透明度增加过渡动画6、backgroundColor:给视图背景色增加动画7、contentStrech给UIImageview改变图片拉伸方式增加动画</code></pre><p>&ensp;&ensp;<strong><em>bounds和frame.使用cgRect设置时，后两个参数决定大小，前两个参数中，frame决定当前视图在父视图中的位置，bounds决定子视图在自身中的坐标原点的位置</em></strong></p><h4 id="使用commit方式进行UIView动画创建"><a href="#使用commit方式进行UIView动画创建" class="headerlink" title="使用commit方式进行UIView动画创建"></a>使用commit方式进行UIView动画创建</h4><p>&ensp;&ensp;在iOS4之前使用传统的commit的方式创建UIView层的动画。这种方式包含四个步骤，1设置动画开始标志，2、设置动画属性，3、设置动画过渡效果，4、提交动画。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    UIView *view = [UIView new];</span><br><span class="line">    view.frame = CGRectMake(100, 100, 80, 80);</span><br><span class="line">    view.backgroundColor = [UIColor redColor];</span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line">    /// 动画开始标志</span><br><span class="line">    [UIView beginAnimations:@&quot;test&quot; context:nil];</span><br><span class="line">    [UIView setAnimationDelegate:self];</span><br><span class="line">    /// 动画属性</span><br><span class="line">    [UIView setAnimationWillStartSelector:@selector(start)];</span><br><span class="line">    [UIView setAnimationDidStopSelector:@selector(stop)];</span><br><span class="line">    [UIView setAnimationDuration:3];</span><br><span class="line">    [UIView setAnimationDelay:1];</span><br><span class="line">    [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];</span><br><span class="line">    [UIView setAnimationRepeatAutoreverses:YES];</span><br><span class="line">    [UIView setAnimationRepeatCount:3];</span><br><span class="line">    /// 动画过渡效果</span><br><span class="line">    view.backgroundColor = [UIColor blueColor];</span><br><span class="line">    view.frame = CGRectMake(200, 200, 80, 80);</span><br><span class="line">    /// 提交动画</span><br><span class="line">    [UIView commitAnimations];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;对比上下两种动画，commit的方式更为传统，需要编写的代码也更多，因为是在ios4之前，ios4之后引入UIView的类方法的动画到现在应该是所有版本都适配的，现在基本没有ios4以下的设备。而且commit创建动画的方式已经在ios13以后被废弃了。所以还是尽量使用UIView类方法创建动画的方式更好。</p><h4 id="UIView转场动画"><a href="#UIView转场动画" class="headerlink" title="UIView转场动画"></a>UIView转场动画</h4><p>&ensp;&ensp; 相对于过渡动画，转场动画更多用于两个UIView视图的切换或者重绘某个视图。iOS中，UIView的转场动画有两种，一种时对UIView视图内容进行重新绘制，一种是使用新的视图替换旧视图的转场。<br>&ensp;&ensp; 在实际开发中开发者会遇到这样的需求：一个UIView视图中有许多子视图，当用户数据变化时，子视图控件需要重新布局，使得原本视图看来变成新的视图。因为视图的重绘是在瞬间完成的，如果不添加任何转场效果，就会出现闪动，体验效果很差。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 80, 80)];</span><br><span class="line">    view.backgroundColor = [UIColor redColor];</span><br><span class="line">    view2 = [[UIView alloc]initWithFrame:CGRectMake(200, 200, 80, 80)];</span><br><span class="line">    view2.backgroundColor = [UIColor blueColor];</span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    /// 视图自身变化进行转场</span><br><span class="line">    [UIView transitionWithView:view duration:3 options:UIViewAnimationOptionTransitionFlipFromBottom | UIViewAnimationOptionAllowAnimatedContent animations:^&#123;</span><br><span class="line">        self-&gt;view.backgroundColor = [UIColor blueColor];</span><br><span class="line">        self-&gt;view.frame = CGRectMake(200, 200, 80, 80);</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    /// 切换视图转场</span><br><span class="line">//    [UIView transitionFromView:view toView:view2 duration:3 options:UIViewAnimationOptionTransitionFlipFromBottom |UIViewAnimationOptionAllowAnimatedContent  completion:^(BOOL finished) &#123;</span><br><span class="line">//</span><br><span class="line">//    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;切换视图的转场用于开发中整体视图的切换需求，这个操作会将原本的UIView从原本的父视图上移除，再将新的UIView视图添加到父视图上。其中option的定义是一个枚举，其中定义了许多转场的效果，可以进入源码查看其定义。</p><h4 id="coreAnimation动画编程技术"><a href="#coreAnimation动画编程技术" class="headerlink" title="coreAnimation动画编程技术"></a>coreAnimation动画编程技术</h4><p>&ensp;&ensp;使用UIView层的过渡动画和转场动画可以满足绝大部分开发需求，但是也有许多局限性，使用CoreAnimation则可以更加自由的进行iOS动画编程。CoreAnimation是基于OpenGL和CoreGraphics图像处理框架的跨平台动画框架，下图给出了CoreAnimtion的系统结构图</p><p><img src="/2021/09/12/iOS动画基础/coreAnimation.png" alt="coreAnimation"></p><p>&ensp;&ensp;CoreAnimation框架中大多数动画效果都是基于CALayer类实现的。每一个UIView都包含一个CALayer属性。边框，阴影等操作都是和CALayer相关的。</p><p>&ensp;&ensp;<strong>锚点</strong>，所有的CALayer对象都有一个anchorPoint属性，这是CALayer对象的锚点，可以理解为对象动作的参照点，其中x,y都取值在0～1中，CALayer对象锚点值默认为(0,0)是视图的左上角，如果要设置为视图中心，则将锚点设置为(0.5,0.5),当CALayer层执行操作时都是以锚点为草考点进行的。比如一些平移，旋转等。抛开Layer层，view层主要是处理事件接受和用户交互的功能。</p><h5 id="色彩梯度层–CAGradientLayer"><a href="#色彩梯度层–CAGradientLayer" class="headerlink" title="色彩梯度层–CAGradientLayer"></a>色彩梯度层–CAGradientLayer</h5><p>&ensp;&ensp;CAGradientLayer 是继承自CALayer的子类，是专门用来处理颜色梯度渐变的layer层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    CAGradientLayer *layer = [CAGradientLayer layer];</span><br><span class="line">    layer.colors = @[(id)[UIColor redColor].CGColor,(id)[UIColor blueColor].CGColor];</span><br><span class="line">    layer.bounds = CGRectMake(100, 100, 100, 100);</span><br><span class="line">    layer.position = CGPointMake(200, 200);</span><br><span class="line">    layer.locations = @[@0.1];</span><br><span class="line">    layer.startPoint = CGPointMake(0, 0);</span><br><span class="line">    layer.endPoint = CGPointMake(1, 1);</span><br><span class="line">    [self.view.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上面代码中colors用于设置颜色梯度，bounds是设置CAlayer类的基础属性，用来设置layer层尺寸，position属性设置layer的位置，locations属性设置颜色梯度分界线，取值为0-1，startPoint，endPoint设置渲染的起始位置，此处为左上角到右下角，locations会渲染0.2部分红色，在渲染0.8部分的蓝色。</p><h5 id="视图拷贝层–CARelicatorLayer"><a href="#视图拷贝层–CARelicatorLayer" class="headerlink" title="视图拷贝层–CARelicatorLayer"></a>视图拷贝层–CARelicatorLayer</h5><p>&ensp;&ensp;CARelicatorLayer可以理解为layer层的一个复制容器，起作用是复制一个已经存在的layer层对象进行复制渲染.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">///CARelicatorLayer</span><br><span class="line">CALayer *baseLayer = [CALayer layer];</span><br><span class="line">baseLayer.bounds = CGRectMake(0, 0, 100, 100);</span><br><span class="line">baseLayer.position = CGPointMake(100, 400);</span><br><span class="line">baseLayer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">CAReplicatorLayer *reLayer = [CAReplicatorLayer layer];</span><br><span class="line">reLayer.instanceRedOffset = -0.2;</span><br><span class="line">reLayer.position = CGPointMake(0, 0);</span><br><span class="line">reLayer.instanceTransform = CATransform3DMakeTranslation(100, 0, 0);</span><br><span class="line">reLayer.instanceCount = 3;</span><br><span class="line">[reLayer addSublayer:baseLayer];</span><br><span class="line">[self.view.layer addSublayer:reLayer];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;此处layer先创建一个layer层作为要复制的原本，作为子layer加到CARelicatorLayer对象中，CARelicatorLayer的instanceRedOffset设置每个复制副本背景色中红色的偏移量，对应还有蓝色，绿色和alpha的偏移量。instanceTransform属性用于设置复制视图的3D变化属性，上面的代码表示将每个复制的layer层沿着x轴正方向偏移100个单位。</p><h5 id="徒刑渲染层–CAShapeLayer"><a href="#徒刑渲染层–CAShapeLayer" class="headerlink" title="徒刑渲染层–CAShapeLayer"></a>徒刑渲染层–CAShapeLayer</h5><p>&ensp;&ensp;CAShapeLayer是用于绘制图形的layer层，可以用来绘制一些自定义的图形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// CAShapeLayer</span><br><span class="line">CAShapeLayer *shapeLayer = [CAShapeLayer layer];</span><br><span class="line">shapeLayer.position = CGPointMake(0, 0);</span><br><span class="line">CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">CGPathMoveToPoint(path, 0, 300, 600);</span><br><span class="line">CGPathAddLineToPoint(path, 0, 200, 500);</span><br><span class="line">CGPathAddLineToPoint(path, 0, 100, 600);</span><br><span class="line">shapeLayer.path = path;</span><br><span class="line">[self.view.layer addSublayer:shapeLayer];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上面的代码中CGMutablePathRef创建了ios中的绘图路径对象，CGPathCreateMutable()方法创建了可变的绘图路径对象，CGPathMoveToPoint()方法设置绘图路径起点，CGPathAddLineToPoint()为绘图路径增加一条线。fillColor可以设置图像的填充色。还可以设置线条颜色，线条宽度等内容。</p><h5 id="文本绘制层–CATextLayer"><a href="#文本绘制层–CATextLayer" class="headerlink" title="文本绘制层–CATextLayer"></a>文本绘制层–CATextLayer</h5><p>&ensp;&ensp;CAtextLayer 用于进行视图上下文本的绘制，UILable控件就是基于CATextLayer实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// CATextLayer</span><br><span class="line">CATextLayer *textLayer = [CATextLayer layer];</span><br><span class="line">textLayer.bounds = CGRectMake(0, 0, 320, 100);</span><br><span class="line">textLayer.position = CGPointMake(300, 700);</span><br><span class="line">textLayer.string = @&quot;这是一段文字&quot;;</span><br><span class="line">textLayer.fontSize = 25;</span><br><span class="line">textLayer.foregroundColor = [UIColor redColor].CGColor;</span><br><span class="line">textLayer.alignmentMode = kCAAlignmentLeft;</span><br><span class="line">[self.view.layer addSublayer:textLayer];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上面代码中设置了一段在layer上显示的文字。</p><h4 id="CAAnimation动画体系介绍"><a href="#CAAnimation动画体系介绍" class="headerlink" title="CAAnimation动画体系介绍"></a>CAAnimation动画体系介绍</h4><p>&ensp;&ensp;通过前面的介绍，开发者可以通过CALayer设置许多视图UI上的属性，CAAnimation框架作用就是将这些属性的变化都以动画的形式展示出来，由于CALayer相对UIView可以更加灵活的设置更多属性，因此CALayer层的动画操作更自由。下图中是CAAnimation及其子类的继承关系结构图:</p><p><img src="/2021/09/12/iOS动画基础/CAAnimation.png" alt="CAAnimation继承图"></p><p>&ensp;&ensp;CAAnimation分出的三个字累CAPropertyAnimation,CAAnimationGroup,CATranstion分别用于处理三种不同类型的动画.CAPropertyAnimation可以处理视图属性改变的动画。CAAnimationGroup可以处理组合动画，CATranstion可以处理转场动画。CAPropertyAnimation分出两个子类，CABasicAnimation和CAKeyframeAnimation，这两个字累分别用来处理基础类动画和关键帧动画。基础动画的一个子类CASpringAnimation处理阻尼动画。</p><p>&ensp;&ensp;CAAnimation中定义了两个主要属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CAMediaTimingFunction *timingFunction; //动画执行时序方式</span><br><span class="line">BOOL removedOnCompletion; //动画完成时是否移除对象</span><br></pre></td></tr></table></figure><p>&ensp;&ensp; timingFunction中的动画效果是线性执行，淡入，淡出等，点击查看源码可以查看有哪些效果。</p><p>&ensp;&ensp; CAPropertyAnimation定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface CAPropertyAnimation : CAAnimation</span><br><span class="line">///初始化方法</span><br><span class="line">+ (instancetype)animationWithKeyPath:(nullable NSString *)path;</span><br><span class="line">/// 需要执行动画的属性名称，比如背景色渐变动画path可以设置为backgroundColor</span><br><span class="line">@property(nullable, copy) NSString *keyPath;</span><br><span class="line">/// 动画的执行状态是否叠加到视图的原状态上 if true， 第二次动画执行从第一次终点开始</span><br><span class="line">@property(getter=isAdditive) BOOL additive;</span><br><span class="line">/// 动画是否重复执行</span><br><span class="line">@property(getter=isCumulative) BOOL cumulative;</span><br><span class="line">/// 这个属性和transform动画执行相关</span><br><span class="line">@property(nullable, strong) CAValueFunction *valueFunction;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="CABasicAnimation创建基础动画"><a href="#CABasicAnimation创建基础动画" class="headerlink" title="CABasicAnimation创建基础动画"></a>CABasicAnimation创建基础动画</h5><p>&ensp;&ensp;CABasicAnimation是动画框架中最常用的动画执行类，使用CABasic创建一个渐变色动画</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    /// gradient</span><br><span class="line">    CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;];</span><br><span class="line">    anim.fromValue = (id)[UIColor redColor].CGColor;</span><br><span class="line">    anim.toValue = (id)[UIColor blueColor].CGColor;</span><br><span class="line">    anim.duration = 2;</span><br><span class="line">    [_layer addAnimation:anim forKey:@&quot;&quot;];</span><br><span class="line">    /// rotate</span><br><span class="line">    CABasicAnimation *anima2 = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;];</span><br><span class="line">    anima2.fromValue = @0;</span><br><span class="line">    anima2.toValue = @200;</span><br><span class="line">    anima2.duration = 2;</span><br><span class="line">    anima2.valueFunction =[CAValueFunction functionWithName:kCAValueFunctionTranslateX];</span><br><span class="line">    [_layer addAnimation:anima2 forKey:@&quot;2&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CAKeyFrameAnimation创建关键帧动画"><a href="#CAKeyFrameAnimation创建关键帧动画" class="headerlink" title="CAKeyFrameAnimation创建关键帧动画"></a>CAKeyFrameAnimation创建关键帧动画</h5><p>&ensp;&ensp;通过关键帧创建的动画可以通过设置关键帧的方式自由控制整个动画的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    _layer = [CALayer layer];</span><br><span class="line">    _layer.bounds = CGRectMake(0, 0, 100, 100);</span><br><span class="line">    _layer.position = CGPointMake(160, 200);</span><br><span class="line">    _layer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    CAKeyframeAnimation *ani = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    ani.values = @[[NSValue valueWithCGPoint:CGPointMake(100, 200)],[NSValue valueWithCGPoint:CGPointMake(120, 300)],[NSValue valueWithCGPoint:CGPointMake(140, 400)],[NSValue valueWithCGPoint:CGPointMake(160, 800)]];</span><br><span class="line">    ///设置每段动画的时间占比，第一个位置到第二个位置占比0.5,第二个位置到第三个位置占比0.3</span><br><span class="line">    ani.keyTimes = @[@0,@0.5,@0.8,@1];</span><br><span class="line">    ani.duration = 3;</span><br><span class="line">    [_layer addAnimation:ani forKey:@&quot;&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;运行之后可以看到视图在三秒内进行了位置偏移，切速度逐渐变快</p><h5 id="CATranstion–layer层的转场动画"><a href="#CATranstion–layer层的转场动画" class="headerlink" title="CATranstion–layer层的转场动画"></a>CATranstion–layer层的转场动画</h5><p>&ensp;&ensp;CATransition动画用来处理CAlayer层的转场效果，可以在CALayer对象出现时展示动画效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    CALayer *layer = [CALayer layer];</span><br><span class="line">    layer.bounds = CGRectMake(0, 0, 100, 100);</span><br><span class="line">    layer.position = CGPointMake(100, 300);</span><br><span class="line">    layer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">    CATransition *ani = [CATransition animation];</span><br><span class="line">    ani.type = kCATransitionPush;</span><br><span class="line">    ani.subtype = kCATransitionFromRight;</span><br><span class="line">    ani.duration = 3;</span><br><span class="line">    [layer addAnimation:ani forKey:@&quot;&quot;];</span><br><span class="line">    [self.view.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp; 其中的type用来设置转场动画的类型，subType设置动画执行的方向。</p><h5 id="layer层组合动画–CAAnimationGroup"><a href="#layer层组合动画–CAAnimationGroup" class="headerlink" title="layer层组合动画–CAAnimationGroup"></a>layer层组合动画–CAAnimationGroup</h5><p>&ensp;&ensp;CAAnimationGroup类没有定义特定的动画类型，可以理解为是一个动画容器，在其中加入组合后的动画效果，进行展示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    CABasicAnimation *ani1 = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;];</span><br><span class="line">    ani1.toValue = (id)[UIColor blueColor].CGColor;</span><br><span class="line">    CABasicAnimation *ani2 = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    ani2.toValue = [NSValue valueWithCGPoint:CGPointMake(200, 400)];</span><br><span class="line">    CAAnimationGroup *group = [CAAnimationGroup animation];</span><br><span class="line">    CABasicAnimation *ani3 = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;];</span><br><span class="line">    ani3.fromValue = @0;</span><br><span class="line">    ani3.toValue = @M_PI;</span><br><span class="line">    ani3.valueFunction =[CAValueFunction functionWithName:kCAValueFunctionRotateZ];</span><br><span class="line">    ani3.beginTime = 2;</span><br><span class="line">    group.duration = 3;</span><br><span class="line">    group.animations = @[ani1,ani2,ani3];</span><br><span class="line">    [_layer addAnimation:group forKey:@&quot;&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上述代码给layer增加了三层动画，同时设置了旋转动画从第2秒才开始执行。</p><h5 id="CATransform3D动画"><a href="#CATransform3D动画" class="headerlink" title="CATransform3D动画"></a>CATransform3D动画</h5><p>&ensp;&ensp;任何CALayer对象都有transform属性，这个属性用来设置CALayer对象数学变换的效果。可以实现平移，旋转，放缩等动画效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    UIView *view = [UIView new];</span><br><span class="line">    view.frame = CGRectMake(100, 200, 100, 100);</span><br><span class="line">    view.backgroundColor = [UIColor redColor];</span><br><span class="line">    UIView *view2 = [[UIView alloc]initWithFrame:CGRectMake(100, 200, 100, 100)];</span><br><span class="line">    view2.backgroundColor = [UIColor blueColor];</span><br><span class="line">    /// x平移100 y平移100，z平移0</span><br><span class="line">    CATransform3D trans = CATransform3DTranslate(view2.layer.transform, 100, 100, 0);</span><br><span class="line">    /// x方向缩小0.5，y方向放大2</span><br><span class="line">    CATransform3D trans2 = CATransform3DScale(trans, 0.5, 2, 0);</span><br><span class="line">    ///旋转变换沿着z轴旋转45度</span><br><span class="line">    CATransform3D trans3 = CATransform3DRotate(trans2, M_PI_4, 0, 0, 1);</span><br><span class="line">    view2.layer.transform = trans3;</span><br><span class="line">    /// 用于将要变换的效果进行翻转</span><br><span class="line">    view.layer.transform = CATransform3DInvert(trans2);</span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line">    [self.view addSubview:view2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上面代码在同样位置创建了两个view，然后使用平移变换将其中一个进行了移动。trans2给图像增加了放缩变换，trans3给图像增加了z轴的旋转变换，CATransform3DInvert给将要增加的效果进行翻转。<br>&ensp;&ensp;效果如下<br><img src="/2021/09/12/iOS动画基础/CATransform3D.png" alt="CATransform3D"></p><h4 id="粒子动画效果"><a href="#粒子动画效果" class="headerlink" title="粒子动画效果"></a>粒子动画效果</h4><p>&ensp;&ensp;宏观上有序的，轨迹确定的规则动画可以从过layer层和UIViewAnimation实现，对于微观的，无序的，轨迹无法预测的随机动画，可以使用CAEmitterLayer实现。CAEmitterLayer可以实现效果炫酷的粒子动画，粒子效果分为两部分，一部分是粒子发射器，用于配制粒子的整体效果，另一部分是粒子单元，用于配制粒子的具体属性。CAEmitterLayer继承子CALayer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor blackColor];</span><br><span class="line">    _emitterLayer = [[CAEmitterLayer alloc] init];</span><br><span class="line">    /// 粒子发射器在xy平面的位置</span><br><span class="line">    _emitterLayer.emitterPosition = CGPointMake(self.view.frame.size.width/2, self.view.frame.size.height - 20);</span><br><span class="line">    /// 粒子发射器的大小</span><br><span class="line">    _emitterLayer.emitterSize = CGSizeMake(self.view.frame.size.width-100, 20);</span><br><span class="line">    _emitterLayer.renderMode = kCAEmitterLayerAdditive;</span><br><span class="line">    </span><br><span class="line">    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 10, 10)];</span><br><span class="line">    view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    view.layer.cornerRadius = 5;</span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line">    UIImage *img = [self imageFromView:view];</span><br><span class="line">    /// 火焰发射单元</span><br><span class="line">    /// 粒子单元</span><br><span class="line">    CAEmitterCell *fire = [CAEmitterCell emitterCell];</span><br><span class="line">    /// 粒子的创建速率 默认1/s</span><br><span class="line">    fire.birthRate = 800;</span><br><span class="line">    /// 粒子存活时间，默认1s</span><br><span class="line">    fire.lifetime = 3.0;</span><br><span class="line">    /// 粒子的生存时间容差</span><br><span class="line">    fire.lifetimeRange = 1.5;</span><br><span class="line">    fire.color = [UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1].CGColor;</span><br><span class="line">    fire.name = @&quot;fire&quot;;</span><br><span class="line">    fire.contents = (id)img.CGImage;</span><br><span class="line">    /// 粒子速率</span><br><span class="line">    fire.velocity = 160;</span><br><span class="line">    /// 粒子速率容差</span><br><span class="line">    fire.velocityRange = 80;</span><br><span class="line">    /// 粒子在xy平面的发射角度</span><br><span class="line">    fire.emissionLongitude = M_PI + M_PI_2;</span><br><span class="line">    /// 粒子发射角度容差</span><br><span class="line">    fire.emissionRange = M_PI_2;</span><br><span class="line">    /// 粒子缩放速度</span><br><span class="line">    fire.scaleSpeed = 0.3;</span><br><span class="line">    /// 粒子旋转度</span><br><span class="line">    fire.spin = 0.2;</span><br><span class="line">    /// 烟雾</span><br><span class="line">    CAEmitterCell *smoke = [CAEmitterCell emitterCell];</span><br><span class="line">    smoke.birthRate = 800;</span><br><span class="line">    smoke.lifetime = 6.0;</span><br><span class="line">    smoke.lifetimeRange = 1.5;</span><br><span class="line">    smoke.color = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.05].CGColor;</span><br><span class="line">    smoke.name = @&quot;smoke&quot;;</span><br><span class="line">    smoke.contents = (id)img.CGImage;</span><br><span class="line">    smoke.velocity = 250;</span><br><span class="line">    smoke.velocityRange = 100;</span><br><span class="line">    smoke.emissionLongitude = M_PI+M_PI_2;</span><br><span class="line">    smoke.emissionRange = M_PI_2;</span><br><span class="line">    _emitterLayer.emitterCells = [NSArray arrayWithObjects:smoke,fire, nil];</span><br><span class="line">    [self.view.layer addSublayer:_emitterLayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)imageFromView:(UIView *)view &#123;</span><br><span class="line">    CGSize size = view.frame.size;</span><br><span class="line">    UIGraphicsBeginImageContext(size);</span><br><span class="line">    [view.layer renderInContext:UIGraphicsGetCurrentContext()];</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上述注释中解释了CAEmitterLayer和CAEmitterCell的部分属性，可以点击相关源码查看详细的定义。 最终的效果如下所示：</p><p><img src="/2021/09/12/iOS动画基础/fire.png" alt="fire"></p><h4 id="播放动态gif图"><a href="#播放动态gif图" class="headerlink" title="播放动态gif图"></a>播放动态gif图</h4><p>&ensp;&ensp;由于许多应用在进行某些需求的动画处理时会使用播放GIF图的方式，因此把这一技术也归纳为iOS动画开发技术。一般有两种方式进行GIF图的播放，一种是将其渲染为UIWebView进行播放，一种是将GIF文件中存储的图片数据与图片信息获取出来，使用UIImageView的帧动画进行播放。</p><h5 id="使用UIWebView进行GIF图动态播放"><a href="#使用UIWebView进行GIF图动态播放" class="headerlink" title="使用UIWebView进行GIF图动态播放"></a>使用UIWebView进行GIF图动态播放</h5><p>&ensp;&ensp;GIF图渲染为UIWebView进行渲染具有简单，效能强的特点，缺点是加载GIF图需要一定的时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    ///UIWebView已经废弃，使用WKWebView</span><br><span class="line">    WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(100, 200, 280, 300)];</span><br><span class="line">    /// 注意gif资源不能放在Assests目录下</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;mygif&quot; ofType:@&quot;gif&quot;]];</span><br><span class="line">    [webView loadData:data MIMEType:@&quot;image/gif&quot; characterEncodingName:@&quot;UTF-8&quot; baseURL:[NSURL fileURLWithPath:NSTemporaryDirectory()]];</span><br><span class="line">    [self.view addSubview:webView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用UIImageView帧动画播放gif图"><a href="#使用UIImageView帧动画播放gif图" class="headerlink" title="使用UIImageView帧动画播放gif图"></a>使用UIImageView帧动画播放gif图</h5><p>&ensp;&ensp; gif图是一组包含图片及其信息数据的文件，其中记录着各张图片播放时长等信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/// 使用uiimageView播放gif图</span><br><span class="line">   UIImageView *imgView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 500, 280, 300)];</span><br><span class="line">   [self.view addSubview:imgView];</span><br><span class="line">   NSString *dataPath = [[NSBundle mainBundle] pathForResource:@&quot;mygif&quot; ofType:@&quot;gif&quot;];</span><br><span class="line">   CGImageSourceRef source = CGImageSourceCreateWithURL((CFURLRef)[NSURL fileURLWithPath:dataPath], NULL);</span><br><span class="line">   size_t count = CGImageSourceGetCount(source);</span><br><span class="line">   CGFloat allTime = 0;</span><br><span class="line">   NSMutableArray *imageArray = [[NSMutableArray alloc] init];</span><br><span class="line">   NSMutableArray *timeArray = [[NSMutableArray alloc] init];</span><br><span class="line">   NSMutableArray *heightArray = @[].mutableCopy;</span><br><span class="line">   NSMutableArray *widthArray = @[].mutableCopy;</span><br><span class="line">   for (size_t i = 0; i&lt;count; i++) &#123;</span><br><span class="line">       CGImageRef image = CGImageSourceCreateImageAtIndex(source, i, NULL);</span><br><span class="line">       [imageArray addObject:(__bridge UIImage *)image];</span><br><span class="line">       CGImageRelease(image);</span><br><span class="line">       /// 图片信息</span><br><span class="line">       NSDictionary *info = (__bridge NSDictionary *)CGImageSourceCopyPropertiesAtIndex(source, i, NULL);</span><br><span class="line">       CGFloat width = [[info objectForKey:(__bridge NSString *)kCGImagePropertyPixelWidth] floatValue];</span><br><span class="line">       CGFloat height = [[info objectForKey:(__bridge NSString *)kCGImagePropertyPixelHeight] floatValue];</span><br><span class="line">       [widthArray addObject:[NSNumber numberWithFloat:width]];</span><br><span class="line">       [heightArray addObject:[NSNumber numberWithFloat:height]];</span><br><span class="line">       NSDictionary *timeDic = [info objectForKey:(__bridge NSDictionary *)kCGImagePropertyGIFDictionary];</span><br><span class="line">       CGFloat time = [[timeDic objectForKey:(__bridge NSString *)kCGImagePropertyGIFDelayTime] floatValue];</span><br><span class="line">       allTime +=time;</span><br><span class="line">       [timeArray addObject:[NSNumber numberWithFloat:time]];</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;contents&quot;];</span><br><span class="line">   NSMutableArray *times = @[].mutableCopy;</span><br><span class="line">   CGFloat currentTime = 0;</span><br><span class="line">   for (int i=0; i&lt;imageArray.count; i++) &#123;</span><br><span class="line">       [times addObject:[NSNumber numberWithFloat:currentTime/allTime]];</span><br><span class="line">       currentTime += [timeArray[i] floatValue];</span><br><span class="line">   &#125;</span><br><span class="line">   [animation setKeyTimes:times];</span><br><span class="line">   [animation setValues:imageArray];</span><br><span class="line">   [animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]];</span><br><span class="line">   animation.repeatCount = MAXFLOAT;</span><br><span class="line">   animation.duration = allTime;</span><br><span class="line">   [imgView.layer addAnimation:animation forKey:@&quot;gifAnimation&quot;];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;最后效果和前面的WkWebView相同，展示了一个gif图。不过代码比较繁琐。从中也可以看出，如果要对gif图中的某一部分进行操作也是可以通过这种方式实现的。</p><p><strong>以上代码demo请参考<a href="https://github.com/SJ110/ios-animation-demo" target="_blank" rel="noopener">这里</a></strong></p><h4 id="小游戏Flappy-Bird设计"><a href="#小游戏Flappy-Bird设计" class="headerlink" title="小游戏Flappy Bird设计"></a>小游戏Flappy Bird设计</h4><p>&ensp;&ensp; flppy bird小游戏是对ios动画的一个小应用，也是参考书中的一个小demo，其中小鸟的动作通过动画实现。需要抓住的点是背景的移动是通过定时器实现的，在1/60秒内，屏幕上的背景会向左移动一个像素，从而实现了背景的移动。给小鸟所在的屏幕增加一个点击事件，每次点击小鸟的坐标都可以变化一定的像素。通过随机数设置障碍物的位置。下面是两张截图: 源码请参考<a href="https://github.com/SJ110/flappy-bird" target="_blank" rel="noopener">这里</a></p><p><img src="/2021/09/12/iOS动画基础/flappybird1.png" alt="flappybird1"></p><p><img src="/2021/09/12/iOS动画基础/flappybird2.png" alt="flappybird2"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;这边博客主要是总结一下最近看到ios动画开发的一些基础知识。主要包含如下一些知识点。主要参考自&lt;a href=&quot;https://weread.qq.com/web/reader/56932a20719b1fcb569e111kf4532c00231f457c545ad3c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《iOS开发实战：从入门到上架APPsotre》&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1、使用UIImageView播放图片组动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2、使用block回调创建UIView层过渡动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3、使用block回调创建UIView层转场动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4、使用commit方式创建UIView层过渡动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5、使用commit方式创建UIView层转场动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6、CAlayer层在UI开发中的应用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7、各种CALayer子类的用法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8、coreAnimation核心动画框架的用法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9、视图的transform变换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10、粒子效果动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11、ios中播放GIF动态图的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12、Flappy Bird动画小游戏&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOSruntime之method_exchange</title>
    <link href="http://yoursite.com/2021/09/05/iOSruntime%E4%B9%8Bmethod-exchange/"/>
    <id>http://yoursite.com/2021/09/05/iOSruntime%E4%B9%8Bmethod-exchange/</id>
    <published>2021-09-05T06:33:54.000Z</published>
    <updated>2021-09-05T06:41:58.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;最近看到工程中对于容器中的生命周期方法hook比较多，有些甚至发生了重复hook的操作。后来组内大佬一同分析之后，无论这个方法背hook了多少次，<br>&ensp;&ensp;所有被hook的方法都是会一直被执行下去的，我之前听的大概差不多懂了，但是今天还是写个小demo见证下效果。</p><a id="more"></a><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>&ensp;&ensp;一般来讲分类的作用是是给一些系统提供的类别增加一些扩展的功能，这样在可以在不侵入原本代码的基础上，做到能力的扩展。举一个例子，想要按钮有一个点击之后按钮晃动的功能，就可以给UIButton增加一个shaking的分类方法，每次在点击按钮之后调用shaking方法。这样这个shaking的能力相当于独立了出来，很方便能够被复用。</p><p>&ensp;&ensp;当然，上面说的都不是重点。ios方法hook经常也在分类中使用，一般的方式是在+load方法中进行方法交换, load方法在app启动时就会调用，这样可以保证交换的时机尽可能的早。交换之后调用原方法时就相当于调用了交换后的方法，比如下demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    Method originalM = class_getInstanceMethod([self class], @selector(viewDidAppear:));</span><br><span class="line">    Method destinationM = class_getInstanceMethod([self class], @selector(destinationViewDidAppear:));</span><br><span class="line">    BOOL didAddMethod = class_addMethod([self class], @selector(destinationViewDidAppear:), method_getImplementation(destinationM), method_getTypeEncoding(destinationM));</span><br><span class="line">    if (!didAddMethod) &#123;</span><br><span class="line">        method_exchangeImplementations(originalM, destinationM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)destinationViewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    NSLog(@&quot;exchange method1,%@&quot;,NSStringFromClass([self class]));</span><br><span class="line">    [self destinationViewDidAppear:animated];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;其中的destinationViewDidAppear就是交换后的方法。注意到这个方法末尾的调用并不是重复调用这个方法，而是去调用了原方法，这里有点乱，应该这么说，交换后的方法我们不会主动调用，而是去调用原本的方法（此时原方法已经被交换），然后调用完之后继续调用交换方法（此时交换的方法已经是原方法)。 整个过程就相当于是你去公司上班的路上顺便买了早饭然后在继续上路。买早饭这个动作就是交换后的方法。做完在回到原本的路径上继续往下。这就大概是方法交换的整个流程。</p><h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>&ensp;&ensp;多次方法交换后为何每个都继续执行了？下图说明整个过程</p><p><img src="/2021/09/05/iOSruntime之method-exchange/0.png" alt="图0"></p><p><img src="/2021/09/05/iOSruntime之method-exchange/1.png" alt="图1"></p><p><img src="/2021/09/05/iOSruntime之method-exchange/2.png" alt="图2"></p><p>&ensp;交换完成后就变成了这个样子，所以当执行viewDidAppear时其实执行的是exmethod2，然后method2在调用自身，其实是执行method1，然后method1再调用自身，其实执行的是viewDidAppear。</p><p>&ensp;&ensp;也就是说谁先交换，谁就后执行。但是推荐不要这样做，因为每个分类中的load方法执行顺序不确定，所以那个方法先被交换是不确定的。</p><p>&ensp;&ensp;但是要注意每次需要交换的方法不要重名，不然就相当于两次交换回到最初的样子了。两个交换后的方法都不会被执行。</p><p>代码截图如下：</p><p><img src="/2021/09/05/iOSruntime之method-exchange/3.png" alt="图3"></p><p><img src="/2021/09/05/iOSruntime之method-exchange/4.png" alt="图4"></p><p>&ensp;&ensp;执行结果和预期一致。</p><p><img src="/2021/09/05/iOSruntime之method-exchange/5.png" alt="图5"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;最近看到工程中对于容器中的生命周期方法hook比较多，有些甚至发生了重复hook的操作。后来组内大佬一同分析之后，无论这个方法背hook了多少次，&lt;br&gt;&amp;ensp;&amp;ensp;所有被hook的方法都是会一直被执行下去的，我之前听的大概差不多懂了，但是今天还是写个小demo见证下效果。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>SD_webImage调用链路探索</title>
    <link href="http://yoursite.com/2021/09/05/SD-webImage%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2021/09/05/SD-webImage%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E6%8E%A2%E7%B4%A2/</id>
    <published>2021-09-05T06:05:18.000Z</published>
    <updated>2021-09-05T06:21:25.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;关于sd_webImage是这样介绍的。Asynchronous image downloader with cache support with an UIImageView category. (一个异步下载且支持缓存的uiimageview分类)。</p><p>很多时候图片资源都是作为一个远程资源。为了加载图片需要根据url（统一资源定位符）去获取资源。我以前曾亲身体会到使用</p><a id="more"></a> <h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:url]]];///1</span><br><span class="line"> </span><br><span class="line">[self.imageView sd_setImageWithURL:[NSURL URLWithString:self.imageUrl]];///2</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;两者带来极大不同效果。方法1是在主线程中货源图片资源并且加载，如果把这个事情放到列表中去做，滑动列表时会出现明显的卡顿效果，这是因为主线程因为加载资源被阻塞了。</p><p>&ensp;&ensp;使用方法2就是把资源获取通过异步的方式放在子线程中处理，取得之后通过回调的方式在加载图片。列表滑动会变得相当流程。</p><p>&ensp;&ensp;在对SD_webImage常用方法进行探索前，可以先明确一下实现这样一个异步加载器需要些什么。<font color="Crimson">首先是”异步“，可以猜测其中关于根据图片url获取图片的操作不是在主线程进行的。然后是“缓存”，一个常见的缓存包含了内存缓存和磁盘缓存。所以在第一次获取到资源后应该会有一个类似cache保存的操作，减少下次重新下载耗费的时间。也许还会有一个磁盘缓存，app下次启动时如果发现已经存在这个资源也需要再次下载了。要做到这些需要一些缓存策略之类的东西。然后就是”分类”，这是一个对于uiimageView的分类，提供了一些新的分类方法。所以整个流程大概如下，uiimageview在加载图片时首先判断这个图片是否在内存中有无，有的话直接返回，没有的话再去本地路径中查找，有的话就返回，没有再去发起get请求，获取图片资源数据。获取之后再把数据存到内存中，同时存到本地。然后把数据通过回调返回。下面根据一次调用过程去看整个链路是如何工作的。</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">这是我们常用的加载图片的方法。这个方法暴露在 &lt;UIImageView+WebCache.h&gt;中，到实现文件查看，发现，几个同类型的方法最后都走向同一个方法</span><br><span class="line"></span><br><span class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</span><br><span class="line">                  placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                           context:(nullable SDWebImageContext *)context</span><br><span class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(nullable SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(nullable SDInternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这是uiview分类中的方法，因为作者也为buButton和NSButton提供了异步加载图片的能力，所以在他们共同的父类中扩展方法可以使其都可以调用。</p><p>&ensp;&ensp;在这个方法里面首先是一些上下文的操作，以UIImageview为例，首先尝试获取operationkey，对这个operationkey的解释是（pass through the operation key to downstream, which can used for tracing operation or image view class），意思就是方便追踪正在操作的视图类。获取到之后会</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.sd_latestOperationKey = validOperationKey;</span><br><span class="line">[self sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;意思就是如果validOperationKey对应的视图对象正在下载图片，会取消正在下载的操作。<font color="Crimson">感觉这部分理解起来是要表达这么一个意思，因为对于不同的UIImageview对象会生成相同的operationkey，所以每次只会对一个uiimageview对象进行下载操作。（刚才想了下，我的想法有问题，虽然不通的UIImageview对象生成了相同的key，但是不同的对象应该持有的是不同的操作下载队列，不同的uiimageview对象是否同时在下载应该是NSURLSession关心的事情</font>接下来就是把站位图放到视图上。接下来到调用下载方法之间还有一堆操作，大致理解一下就是在下载的过程中，增加一个指示器，根据下载进度更新指示器，完成之后移除指示器。</p><p> &ensp;&ensp;最主要的工作就是下面这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (SDWebImageCombinedOperation *)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                          options:(SDWebImageOptions)options</span><br><span class="line">                                          context:(nullable SDWebImageContext *)context</span><br><span class="line">                                         progress:(nullable SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                                        completed:(nonnull SDInternalCompletionBlock)completedBlock;</span><br><span class="line">///completedBlock</span><br><span class="line"> </span><br><span class="line">typedef void(^SDInternalCompletionBlock)(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL);</span><br><span class="line"> </span><br><span class="line">/// Image Cache Type</span><br><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">  </span><br><span class="line">    SDImageCacheTypeNone,</span><br><span class="line"> </span><br><span class="line">    SDImageCacheTypeDisk,</span><br><span class="line"> </span><br><span class="line">    SDImageCacheTypeMemory,</span><br><span class="line"> </span><br><span class="line">    SDImageCacheTypeAll</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这个方法由SDWebImageManager进行管理，completedBlock中有很多的参数，特别关注下其中的cacheType，查看枚举定义，很明显的看出后面很根据cachetype的值决定是否下载。下载完成的会调用也是处理一些是否下载成功，是否出现错误的保护操作。继续进到下载的方法中查看，首先是对url的一些校验，最关键的还是其中的这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    // Start the entry to load image from cache</span><br><span class="line">    [self callCacheProcessForOperation:operation url:url options:result.options context:result.context progress:progressBlock completed:completedBlock];  ///call</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// Query normal cache process</span><br><span class="line">- (void)callCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation</span><br><span class="line">                                 url:(nonnull NSURL *)url</span><br><span class="line">                             options:(SDWebImageOptions)options</span><br><span class="line">                             context:(nullable SDWebImageContext *)context</span><br><span class="line">                            progress:(nullable SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                           completed:(nullable SDInternalCompletionBlock)completedBlock; /// configeration</span><br><span class="line"> </span><br><span class="line">///</span><br><span class="line">    // Check whether we should query cache</span><br><span class="line">    BOOL shouldQueryCache = !SD_OPTIONS_CONTAINS(options, SDWebImageFromLoaderOnly);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这就是前面说的查询缓存的方法，根据shouldQueryCache 决定是否查询缓存，假定命中了需要查询缓存，然后就是根据url和context查询key值，在根据key值去查询。</p><p>///查询缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (id&lt;SDWebImageOperation&gt;)queryImageForKey:(NSString *)key</span><br><span class="line">                                    options:(SDWebImageOptions)options</span><br><span class="line">                                    context:(SDWebImageContext *)context</span><br><span class="line">                                  cacheType:(SDImageCacheType)cacheType</span><br><span class="line">                                 completion:(SDImageCacheQueryCompletionBlock)completionBlock</span><br><span class="line"> </span><br><span class="line">/// Policy for cache operation</span><br><span class="line">typedef NS_ENUM(NSUInteger, SDImageCachesManagerOperationPolicy) &#123;</span><br><span class="line">    SDImageCachesManagerOperationPolicySerial, // process all caches serially (from the highest priority to the lowest priority cache by order) 串行</span><br><span class="line">    SDImageCachesManagerOperationPolicyConcurrent, // process all caches concurrently。并行</span><br><span class="line">    SDImageCachesManagerOperationPolicyHighestOnly, // process the highest priority cache only 高优先级</span><br><span class="line">    SDImageCachesManagerOperationPolicyLowestOnly // process the lowest priority cache only 低优先级</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;到这里，发现东西越来越杂，看的有点头疼了。但是主要过程大致如下：</p><p>&ensp;&ensp;如果caches为空，直接返回，如果cache中一个值，直接查询，否则根据策略决定使用何种方式查询。选择默认的 SDImageCachesManagerOperationPolicySerial策略看下内部，内部主要调用的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id&lt;SDWebImageOperation&gt;)queryImageForKey:(nullable NSString *)key</span><br><span class="line">                                             options:(SDWebImageOptions)options</span><br><span class="line">                                             context:(nullable SDWebImageContext *)context</span><br><span class="line">                                           cacheType:(SDImageCacheType)cacheType</span><br><span class="line">                                          completion:(nullable SDImageCacheQueryCompletionBlock)completionBlock;</span><br><span class="line">///最终查询方法</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options context:(nullable SDWebImageContext *)context cacheType:(SDImageCacheType)queryCacheType done:(nullable SDImageCacheQueryCompletionBlock)doneBlock;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;在最终内存查询的方法中，就是找到回调中带有image数据，没找到，回调中数据为nil，在末尾终于被我找到了，shouldQueryMemoryOnly，如果要执行disk查找的话，  shouldQueryMemoryOnly返回no。最终都会返回一个doneBlock给外部。好，现在回到外层，如果一开始就认为不用查询缓存，就会执行下载操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Download process</span><br><span class="line">- (void)callDownloadProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation</span><br><span class="line">                                    url:(nonnull NSURL *)url</span><br><span class="line">                                options:(SDWebImageOptions)options</span><br><span class="line">                                context:(SDWebImageContext *)context</span><br><span class="line">                            cachedImage:(nullable UIImage *)cachedImage</span><br><span class="line">                             cachedData:(nullable NSData *)cachedData</span><br><span class="line">                              cacheType:(SDImageCacheType)cacheType</span><br><span class="line">                               progress:(nullable SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                              completed:(nullable SDInternalCompletionBlock)completedBlock;</span><br><span class="line"> </span><br><span class="line">/// 接口请求图片</span><br><span class="line">- (nullable id&lt;SDWebImageOperation&gt;)requestImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                options:(SDWebImageOptions)options</span><br><span class="line">                                                context:(nullable SDWebImageContext *)context</span><br><span class="line">                                               progress:(nullable SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                                              completed:(nullable SDImageLoaderCompletedBlock)completedBlock;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这一步就会去调用接口请求数据了，这个方法里面还有一个for循环，所以应该还存在并行调用的场景，最终的下载方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                   context:(nullable SDWebImageContext *)context</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"> </span><br><span class="line">///存储</span><br><span class="line"> // Continue store cache process</span><br><span class="line">[self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;通过这个方法会去下载图片，如果下载成功，就会调用存储方法：存储之后在讲对应的回调返回出去。</p><p>&ensp;&ensp;以上就是一次图片下载经过的整个过程，大致流程和一开始预测的过程类似。但是其中包含了设计者相当多的设计思路，尽量保证每一种场景case都考虑在内，所以其中if，esle场景判断相当多。</p><p>&ensp;&ensp;其次是其中代码的管理也相当规范，可以看到暴露给用户的就是一个简单的sd_setImageWithURL方法，但是内部完成的动作可以说是相当复杂。而且其中还有很多我当前没理解到的地方，比如说context的管理， 各个manager对于多种operation的管理。还有内部代码多是使用block回调处理的，很容易一下就看不明白了。</p><p>&ensp;&ensp;只能说这次缕了一下简单的过程，其中代码管理，各个模块协调的部分还需要继续往下看才行。</p><p>&ensp;&ensp;参考<br><a href="https://github.com/SJ110/analyze/blob/master/contents/SDWebImage/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20—%20SDWebImage.md" target="_blank" rel="noopener">https://github.com/SJ110/analyze/blob/master/contents/SDWebImage/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20—%20SDWebImage.md</a> </p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;关于sd_webImage是这样介绍的。Asynchronous image downloader with cache support with an UIImageView category. (一个异步下载且支持缓存的uiimageview分类)。&lt;/p&gt;
&lt;p&gt;很多时候图片资源都是作为一个远程资源。为了加载图片需要根据url（统一资源定位符）去获取资源。我以前曾亲身体会到使用&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>masonry链式调用探索</title>
    <link href="http://yoursite.com/2021/08/23/masonry%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2021/08/23/masonry%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%8E%A2%E7%B4%A2/</id>
    <published>2021-08-23T10:31:19.000Z</published>
    <updated>2021-08-23T12:21:26.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;最近刚好看了一篇对masonry这个库做了分析的文章，讲的挺清楚，有兴趣可以参考。<br><a href="https://github.com/SJ110/analyze/blob/master/contents/Masonry/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20---%20Masonry.md" target="_blank" rel="noopener">https://github.com/SJ110/analyze/blob/master/contents/Masonry/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20---%20Masonry.md</a><br>看完之后虽然对于这个链式调用的过程有了一定的认识，但是想要搞清楚还是需要实际跟着这个过程走一下。</p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>&ensp;&ensp;以下是对一个uiview构建布局时的masonry代码。下面分析其调用过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.bottomBackGroundImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.left.right.bottom.mas_equalTo(self);</span><br><span class="line">    make.top.mas_equalTo(self.mas_top).offset(35+KSafeAreaTopHeight);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (NSArray *)mas_makeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这个方法是定义在uiview的一个分类中的，这种方式便于只需要引入masonry头文件后就可以使用masonry的相关功能。看下内部实现，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    self.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    return [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;首先是将 translatesAutoresizingMaskIntoConstraints 这个属性设置为NO，这样之后使用autolayout布局才会生效。<br>然后是初始化了一个MASConstraintMaker对象，这个maker对象初始化时会创建一个narray数组叫做constraints,这个数组就用来保存block中编写的约束内容。用来最后布局。<br>block中是用来布局约束的代码。</p><p>[constraintMaker install] 回去执行block回调中拿到的约束布局数据，去进行布局。</p><p>make.left.right.bottom.mas_equalTo(self);</p><p>这个链式调用需要重点关注一下，</p><p>进入MASConstraintMaker.m看其中的实现，发现其中的约束都是通过调用</p><p>addConstraintWithLayoutAttribute来添加的，而每一个方向的约束都会返回一个MASConstraint 对象，所以返回的每个MASConstraint对象都可以继续往下调用，但是其中每一次的调用对于下一次</p><p>来说是无感的。</p><p>addConstraintWithLayoutAttribute方法最后会调用</p><ul><li>(MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute;</li></ul><p>这个方法内会将传递进来的布局属性layoutAttribute 创建一个 MASViewAttribute对象，在用 MASViewAttribute创建一个约束对象 MASViewConstraint。然后将这个约束对象放到之前的数组constraints中。</p><p>对于make.left.right.bottom.mas_equalTo(self);来说，前三个链式调用结束之后因为返回的MASConstraint对象，所以继续往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(id))equalTo &#123;</span><br><span class="line">    return ^id(id attribute) &#123;</span><br><span class="line">        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (MASConstraint * (^)(id))mas_equalTo &#123;</span><br><span class="line">    return ^id(id attribute) &#123;</span><br><span class="line">        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;可以看到mas_equalTo和equalTo实现其实是完全一致的。这个方法接受一个id对象，返回一个MASConstraint的block对象，到这里可以说已经很混乱了，先是链式调用，之后又是block类型的方法。</p><p>休息一下再看。</p><p>&ensp;&ensp;继续往下看到内部调用了一个equalToWithRelation的block，这个所以这个block是定义在 MASConstraint+Private.h中，在 MASConstraint.h和其子类中的，之前没注意到我还觉得奇怪，为什么父类中的私有方法会被子类调用。原来是定义在了一个第三方的类中。找到MASConstraint的子类 MASViewConstraint.m中，</p><ul><li>(MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation； 方法也是一个block函数，接受一个id类型和一个 NSLayoutRelation的参数，他会把传进来的两个赋值给MASConstraint的两个属性，然后在返回自身实例。</li></ul><p>&ensp;&ensp;再看下MASViewConstraint这个类中的一个set方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSecondViewAttribute:(id)secondViewAttribute &#123;</span><br><span class="line">    if ([secondViewAttribute isKindOfClass:NSValue.class]) &#123;</span><br><span class="line">        [self setLayoutConstantWithValue:secondViewAttribute];</span><br><span class="line">    &#125; else if ([secondViewAttribute isKindOfClass:MAS_VIEW.class]) &#123;</span><br><span class="line">        _secondViewAttribute = [[MASViewAttribute alloc] initWithView:secondViewAttribute layoutAttribute:self.firstViewAttribute.layoutAttribute];</span><br><span class="line">    &#125; else if ([secondViewAttribute isKindOfClass:MASViewAttribute.class]) &#123;</span><br><span class="line">        _secondViewAttribute = secondViewAttribute;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSAssert(NO, @&quot;attempting to add unsupported attribute: %@&quot;, secondViewAttribute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;可以看到其不仅可以接受一个value类型的变量，也可以接受一个uiview类型的变量和MASViewAttribute类型的变量这也是为什么我们在链式调用时可以mas_equalTo(self),mas_equalTo(20),mas_equalTo(self.mas_left),但是mas_equalTo(self.left)就会报错，因为self.left类型是MASConstraint类型。</p><p>&ensp;&ensp;这一切动作都结束之后，此时sconstraints数组中已经包含了约束布局数据，进行install，</p><p>&ensp;&ensp;其中的核心方法时系统提供的对两个视图进行约束的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(nullable id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c。</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;还会做一些前置判断，比如要约束的视图a，是否能找到到其相对布局的视图b的共同父视图。已经进行过约束，则直接返回，需要更新约束，将新的约束替换旧的约束等等。到此工作才算完全结束。</p><p>&ensp;&ensp;总结：和自己直接去读源码相比，有了一定的调用链路，加上别人的分析之后，在看源码变得方便许多。这是一个不错的学习源码的方式。不过不要完全把别人的观点带过来，别人的观点也可能出错。</p><p>&ensp;&ensp;再有就是masonry的代码确实有点复杂。看的头大</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;最近刚好看了一篇对masonry这个库做了分析的文章，讲的挺清楚，有兴趣可以参考。&lt;br&gt;&lt;a href=&quot;https://github.com/SJ110/analyze/blob/master/contents/Masonry/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20---%20Masonry.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SJ110/analyze/blob/master/contents/Masonry/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20---%20Masonry.md&lt;/a&gt;&lt;br&gt;看完之后虽然对于这个链式调用的过程有了一定的认识，但是想要搞清楚还是需要实际跟着这个过程走一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ios属性修饰符copy</title>
    <link href="http://yoursite.com/2021/08/23/ios%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6copy/"/>
    <id>http://yoursite.com/2021/08/23/ios%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6copy/</id>
    <published>2021-08-23T10:19:31.000Z</published>
    <updated>2021-08-23T12:21:19.418Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>&ensp;&ensp;ios开发中，对于NSString，NSDictionary，NSArray一般都会使用copy来进行修饰，其实用strong的话也没有问题。只是copy修饰在进行赋值时会进行内存的拷贝，相当于赋值之后和被赋值的对象指向不同的内存地址。这样做的好处是防止修改了被赋值对象（等号右边）导致了等号左边的属性发生变化。</p><a id="more"></a><p>&ensp;&ensp;当然如果属性本身是对外不可见的，怎么修改都放在.m文件中，这样外界就无法修改类的属性，类的属性只受内部控制，这样可以使用strong来修饰，不过也只是降低了被修改的风险而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) SJPAnimationViewController *vc;</span><br><span class="line">@property (nonatomic, copy) NSString *str;</span><br><span class="line">@property (nonatomic, copy) NSDictionary *dict;</span><br><span class="line">@property (nonatomic, copy) NSArray *arr;</span><br><span class="line">//@property (nonatomic, strong) NSString *str;</span><br><span class="line">//@property (nonatomic, strong) NSDictionary *dict;</span><br><span class="line">//@property (nonatomic, strong) NSArray *arr;</span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">@implementation SJPTabBarController</span><br><span class="line"> </span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self initTabBarVc];</span><br><span class="line">    NSMutableString *mStr = [NSMutableString stringWithString:@&quot;123&quot;];</span><br><span class="line">    NSMutableDictionary *mDict = [NSMutableDictionary dictionaryWithDictionary:@&#123;@&quot;test1&quot;:@&quot;123&quot;,@&quot;test2&quot;:@&quot;456&quot;&#125;];</span><br><span class="line">    NSMutableArray *mArr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;]];</span><br><span class="line">    self.str = mStr;</span><br><span class="line">    self.dict = mDict;</span><br><span class="line">    self.arr = mArr;</span><br><span class="line">    /// 修改数据</span><br><span class="line">    mStr.string = @&quot;12345&quot;;</span><br><span class="line">    [mDict removeObjectForKey:@&quot;test1&quot;];</span><br><span class="line">    [mArr removeObjectAtIndex:0];</span><br><span class="line">    NSLog(@&quot;mstring 地址：@%p, 数据:@%@\n&quot;,mStr,mStr);</span><br><span class="line">    NSLog(@&quot;string 地址：@%p, 数据:@%@\n\n\n&quot;,self.str,self.str);</span><br><span class="line">    NSLog(@&quot;marray 地址:@%p, 数据@%@\n&quot;,mArr,mArr);</span><br><span class="line">    NSLog(@&quot;array 地址:@%p, 数据@%@\n\n\n&quot;,self.arr,self.arr);</span><br><span class="line">    NSLog(@&quot;mdict 地址：@%p, 数据：@%@\n&quot;,mDict,mDict);</span><br><span class="line">    NSLog(@&quot;dict 地址：@%p, 数据：@%@\n&quot;,self.dict,self.dict);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上图是demo代码，下图是表现结果.</p><p><img src="/2021/08/23/ios属性修饰符copy/pic1.png" alt="picture1"></p><p>&ensp;&ensp;使用copy修饰的结果，修改了原数据，不会导致赋值之后的数据发生改变。因为指向了不同的地址。</p><p><img src="/2021/08/23/ios属性修饰符copy/pic2.png" alt="picture2"></p><p>&ensp;&ensp;使用strong修饰的结果，修改了原数据，赋值之后的数据也发生了改变，因为指向了相同的地址。</p><p><img src="/2021/08/23/ios属性修饰符copy/pic3.png" alt="picture3"></p><p>&ensp;&ensp;另外追加一点，为何nsstring的值给定之后可以重复修改，nsdictionary和nsarray值给定之后需要修改却不行。</p><p>&ensp;&ensp;上面这个说法其实是错误的。并不是nssrting可以重复修改，只是string类型修改起来比较容易，重新赋值之后其实本身已经指向了新的内存地址。因此，nsdict和nsarray想要修改值要做的就是修改本身的内存地址，只不过内部可能包含更多数据，所以比起string来说更加繁琐。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;ios开发中，对于NSString，NSDictionary，NSArray一般都会使用copy来进行修饰，其实用strong的话也没有问题。只是copy修饰在进行赋值时会进行内存的拷贝，相当于赋值之后和被赋值的对象指向不同的内存地址。这样做的好处是防止修改了被赋值对象（等号右边）导致了等号左边的属性发生变化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ios常见面试题</title>
    <link href="http://yoursite.com/2021/06/07/ios%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2021/06/07/ios%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-06-07T11:19:14.000Z</published>
    <updated>2021-10-25T07:13:06.686Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要收录一些Ios面试中常会问到的一些题目</p><h3 id="1、frame和bounds的区别"><a href="#1、frame和bounds的区别" class="headerlink" title="1、frame和bounds的区别"></a>1、frame和bounds的区别</h3><p>&ensp; &ensp; 1、frame：该view在父视图坐标系中的位置和大小，参考坐标系为父视图。 2、bounds：该view在自己坐标系中位置和大小，参考坐标系为自己。3、要想知道自身的坐标，只需要知道其在父视图中的坐标即可。因此当一个父视图包含一个子视图时，可以通过修改父视图的bounds属性修改其在父视图中的相对位置。 因为bounds参考坐标系为自身，因此修改bounds的x,y坐标相当于修改其自身坐标原点的位置，从而修改了子视图参考父视图的位置。</p><a id="more"></a><h3 id="2、面向协议编程-pop-即-protocol-oriented-programming"><a href="#2、面向协议编程-pop-即-protocol-oriented-programming" class="headerlink" title="2、面向协议编程(pop  即 protocol oriented programming)"></a>2、面向协议编程(pop  即 protocol oriented programming)</h3><p>&ensp; &ensp; 讲到pop现将oop（面向对象编程）,oop具有如下优点。1、<strong>封装和权限控制</strong>，在.h文件中申明公有方法和属性，在.m文件中申明私有方法和属性。2、<strong>扩展性</strong>，在oc中可以通过分类的方式在不破坏原本封装性的同时增加新的方法。还可以通过协议（protocol）和代理（delegate）实现类的灵活扩展。3、<strong>继承和多态</strong>，将公有的属性和方法放在父类中，子类继承时根据自身需要扩展新的方法和属性，增加代码灵活性。在ios中，消息可能会转发给不同的对象，需要根据消息类型确定转发的对象，从而调用不同的类别的方法，这种称为运行时多态，也是动态多态。</p><p>&ensp; &ensp; oop的缺点1、<strong>隐式共享</strong>，说动隐式共享就需要提到深拷贝和浅拷贝，在对变量向另一个变量赋值时，如果该变量只是一个值引用类型，那么赋值后的两个变量都会指向同一块内存区域。造成数据混乱。需要需要对数据进行区分，需要重新向内存区申请一块新的地址存放新的数据。</p><p>&ensp; &ensp; pop相比oop的优势：1、<strong>更加灵活</strong>，比如当希望一个类需要具有某种能力时，可以使用protocol的方式，如果该类继承了该协议，并且实现了协议方法，就说明其具有处理这种场景的能力。这样的好处是不必去基类种增加方法。降低的冗余性。2、<strong>降低依赖</strong>，需要 这种能力的类就去实现这个协议，否则就不必实现，这样可以使得父类的只有通用的方法。</p><p>&ensp; &ensp; 考虑下面的场景，如果给一个button添加一个点击后带有抖动的效果，如何实现。1、实现一个自定义的Uibutton类，在其中添加shake方法。这种方式的代码缺乏复用性，如果其他地方需要这个能力，就必须重新实现一遍shake方法。2、写一个UIbutton类的分类，扩展其自身的能力。这种方式虽然可以解决问题，但是如果不同的场景需要不同shake方式，就需要增加条件判断，而且并不是所有人都知道存在这个分类方法。3、定义一个protocol协议，继承了该协议的类就需要实现shake方法。这种方法具有高度的定制划，需要什么类型的shake就自行定义。代码扩展能力很强。</p><h3 id="3、IOS-MVC和MVVM"><a href="#3、IOS-MVC和MVVM" class="headerlink" title="3、IOS MVC和MVVM"></a>3、IOS MVC和MVVM</h3><p>&ensp; &ensp; 在公司中一般编程都是采用MVC的设计方式，即view和model进行交互，model的来源又由controller管理，同时controller持有view，当数据来源变更时会由view触发model的变化，model变化反过来影响view的展示。大致这样一个过程。在听说MVVM的设计方式后，感觉没有用过总是不知道是如何实现的。网上搜博客也是简单的给出两个图，一个是MVC，一个是MVVM，光看图还是难以理解两者之间的真正差别。此处就不在介绍MVC模式的方式，这种方式也比较简单上手，理解比较容易。</p><p>&ensp; &ensp; <a href="https://www.jianshu.com/p/548980de876a" target="_blank" rel="noopener">https://www.jianshu.com/p/548980de876a</a> 这篇博客中给出了一个demo比较简单的一个MVVM架构。可以做一定的参考。下面根据博客内容对MVVM模式做一个简单介绍。</p><p>&ensp; &ensp; <img src="/2021/06/07/ios常见面试题/mvvm.png" alt="MVVM"></p><p>&ensp; &ensp; 如图中所示：1、VC还是管理view的生命周期，但是view不在和model进行数据交互，而是和Viewmodel进行交互。2、model的数据更新不在告知view需要更新视图。而是通过viewmodel，viewmodel告知view需要更新视图。3、大致流程可以理解为，服务端数据来之后VC触发viewmodel更新，viewmodel更新引起model和View的更新。这个流程里面数据变化引起的视图变化主要工作交给了Viewmodel去处理。这样可以使VC中的代码量大大降低。</p><p>&ensp; &ensp; 文中demo也大致如下，当列表刷新时会触发tableView的reloaddata方法，从而调用cellforrow重新渲染数据，在cellforRow中viewModel通过indexpath去为每个cell创建一个model，但是这个model是由ViewModel持有的，看起来model和cell之间没有任何关系。（就是在model和cell之间加了一个屏障，这个屏障基本做了之前model和cell之间要做的事。）既然Viewmodel持有了model，那么所有model内的数据就可以轻松拿到了。</p><h3 id="4、Ios-method-swizzling"><a href="#4、Ios-method-swizzling" class="headerlink" title="4、Ios method swizzling"></a>4、Ios method swizzling</h3><p>&ensp; &ensp; 方法交换在很多app内都有运用，<a href="https://www.jianshu.com/p/ff19c04b34d0" target="_blank" rel="noopener">https://www.jianshu.com/p/ff19c04b34d0</a> ，这篇博客对其解释的比较详细，可以参考一下。其原理祖耀是利用oc的runtime时候的消息发送机制。使用method swizzling将两个method进行互换。</p><p>&ensp; &ensp; 我现在所在公司主要是做货运相关的，app内有很多的货源列表，试想这样一种场景，给所有列表增加一个页面时长统计的功能，1、我们可以给在每一个列表的viewWillappear中开始计时，然后在dealloc里面结束计时。这样的话工作量是比较大的。2、可以让所有的列表都有继承自同一个基类列表，这样只需要在基类列表中做处理即可。我们公司如今就是这样的处理方案。3、给viewcontrlloer增加一个分类，使用method swizzling，交换需要实现的方法和viewWillappear方法。</p><p>使用method swizzling主要有几个方法比较重要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">///获取一个实例方法method 第一个参数实该类的类名，第二个参数是方法的选择子</span><br><span class="line">class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)</span><br><span class="line">///获取一个类方法</span><br><span class="line">class_getClassMethod(Class _Nullable cls, SEL _Nonnull name)</span><br><span class="line">/*</span><br><span class="line">第一个参数是该类类名，第二个参数是要被添加的方法的选择子，第三个参数是添加的新方法的指针，第四个参数是新添加方法的参数列表</span><br><span class="line">如果方法交换成功返回yes，否则no</span><br><span class="line">*/</span><br><span class="line">class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) </span><br><span class="line">/// 进行原方法和目的方法的交换</span><br><span class="line">method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)</span><br></pre></td></tr></table></figure><h4 id="Method-Swizzling类簇"><a href="#Method-Swizzling类簇" class="headerlink" title="Method Swizzling类簇"></a>Method Swizzling类簇</h4><p>&ensp; &ensp; 在项目开发中经常容易遇见NSArray数组越界或者NSDictionary取到的vlaue/key为nil导致crash，苹果的这种做法有些狠了。但是在使用method swizzling为数组越界做判断时，却发现不起作用。这是因为method swizzling对NSarray类簇不起作用，其内部有很多继承子当前类的子类，比如 objectAtIndex:这个方法会在内部创建不同的抽象类进行操作，所以我们进行method swizzling时实际操作的是NSArray的父类。 可以使用runtime方法获取其真正的类。</p><h3 id="5、-UITabBarController-amp-amp-UINavigationController"><a href="#5、-UITabBarController-amp-amp-UINavigationController" class="headerlink" title="5、 UITabBarController &amp;&amp; UINavigationController"></a>5、 UITabBarController &amp;&amp; UINavigationController</h3><p>&ensp; &ensp; 今天主要梳理了下tabBarcontroller和navigationController的运用。首先和和同事商量了一下app页面的组织形式。目前常见的app页面形式主要是首页底部一个tabbar，顶部一个navi，中间是用于展示的视图。也就是底部一个tabBarController持有了一个navigationcontroller,然后navi由持有了一个用于展示的视图。</p><p>&ensp; &ensp; 当前我公司大致也是这种设计思路。如果想操作tabBar，可以自行实现tabBar的相关协议。如果想修改Navi，可以通过uiViewController的navigationItem取到相关属性进行操作。</p><p>&ensp; &ensp; 如果想要设置navi上的背景色，可以如下使用，否则navi可能会看起来有一层蒙层一般。这种效果在app内一般设置在基类中，免得所有继承的子类都要重新设置一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//背景色</span><br><span class="line">[nav.navigationBar setBarTintColor:[UIColor orangeColor]];</span><br><span class="line">//元素颜色</span><br><span class="line">[nav.navigationBar setTintColor:[UIColor whiteColor]];</span><br><span class="line">[nav.navigationBar setTitleTextAttributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:19],</span><br><span class="line">                                                                      NSForegroundColorAttributeName:[UIColor redColor]&#125;];</span><br></pre></td></tr></table></figure><h3 id="6、iOS开发中-property的属性nonatomic-retain-readonly-strong等介绍"><a href="#6、iOS开发中-property的属性nonatomic-retain-readonly-strong等介绍" class="headerlink" title="6、iOS开发中@property的属性nonatomic retain readonly strong等介绍"></a>6、iOS开发中@property的属性nonatomic retain readonly strong等介绍</h3><h4 id="nonatomic和atomic"><a href="#nonatomic和atomic" class="headerlink" title="nonatomic和atomic"></a>nonatomic和atomic</h4><p>&ensp; &ensp; 默认是有这个atomic这个属性的，这是为了保证在多线程情况下编译器自动生成互斥锁代码防止读写不同步。如果该对象无需考虑多线程的场景，使用nonatomic修饰。</p><h4 id="copy，assign，retain"><a href="#copy，assign，retain" class="headerlink" title="copy，assign，retain"></a>copy，assign，retain</h4><p>&ensp; &ensp; assgin:默认类型，setter方法直接赋值，不进行热河retain操作，不改变引用计数，一般用于处理基本的数据类型。（float，double，integer）。  retain：释放旧的对象，将旧对象的值赋值给新对象，再另新对象的引用计数为1.应该是拷贝一份原来的指针，赋值给新的对象，再将原来的对象释放。 copy：copy和retain处理流程比较类似，释放旧对象，copy新对象，但是会重新申请一块内存，使用copy需要保证对象符合NSCopying协议，如果是NSArray对象，copy只会是浅拷贝，即将原Array的地址赋值一份。</p><h4 id="assign和retain"><a href="#assign和retain" class="headerlink" title="assign和retain"></a>assign和retain</h4><p>&ensp; &ensp; assign主要是用于修饰一些基础数据类型，并且没有引用计数，retain会有引用计数，只有当一个属性的引用计数为0时才会销毁。</p><h4 id="copy与retain"><a href="#copy与retain" class="headerlink" title="copy与retain"></a>copy与retain</h4><p>&ensp; &ensp; retain 和copy的区别主要是是否重新创建一块新地址。如果是copy，会重新申请一块内存保存新的属性。如果是retain，赋值时引用计数加1.两者会指向同一块内存区。</p><h4 id="strong和weak"><a href="#strong和weak" class="headerlink" title="strong和weak"></a>strong和weak</h4><p>&ensp; &ensp; 一般来讲使用weak是为了防止出现循环引用的问题，外层调用了内层的属性，内层将某些方法放到外层调用（delegate），使用strong会出现retain cycle。 声明weak的指针，在指针被释放时，本身会指向nil，防止野指针问题。 还有一遍类的内部属性使用strong，在外部时比如（delegate）为weak</p><h3 id="7、iOS-block原理浅析"><a href="#7、iOS-block原理浅析" class="headerlink" title="7、iOS block原理浅析"></a>7、iOS block原理浅析</h3><p>&ensp;&ensp; block底层是一个结构体，该结构体中有一个isa指针，本质是一个OC对象，block的变量捕获方式：局部变量通过值传递的形式，因此在block外部定义的局部变量，在block内部改变值大小时block内部是不会改变的，因为局部变量有可能在block执行时已经销毁。 局部静态变量的访问方式是指针传递，因为指针存放在堆区，在block运行时可以捕获到。全局变量：全局变量具有全局作用域，不需要block传值，内部可以直接访问修改。</p><p>&ensp; &ensp; block类型，在以下几种情况下，编译器会自动将栈上的block复制到堆上。1、block作为函数返回值时。2、block使用strong修饰时，3、block作为gcdAPI的方法参数时。堆上的block内部持有强引用的变量时，会造成变量无法释放，造成内存泄漏。正确的做法是在block内部弱引用变量，消除循环。</p><p>&ensp; &ensp; __block修饰符, __block可以用来解决block内部无法修改局部变量值的问题， __block不能修饰全局变量，静态变量。 __block作用是将变量使用一个结构体包装起来，其内部使用一个指针指向包装的结构体，使得block内部通过指针访问到变量修改值。</p><h3 id="8-copy-mutabelCopy"><a href="#8-copy-mutabelCopy" class="headerlink" title="8.copy mutabelCopy"></a>8.copy mutabelCopy</h3><p>&ensp;&ensp;对于常见的oc数据类型,包括string,array,dictionary都包含可变和不可变两种类型,对两者分类调用copy和mutableCopy时是否创建新的空间如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                          copy是否产生新对象    新对象类型    mutableCopy是否产生新对象      新对象类型</span><br><span class="line">NSString                    否                                  是                      NSMutableString</span><br><span class="line">NSMutableString             是                NSString          是                      NSMutableString</span><br><span class="line"></span><br><span class="line">NSArray                     否                                  是                      NSMutableArray</span><br><span class="line">NSMutableArray              是                NSArray           是                      NSMutableArray</span><br><span class="line"> </span><br><span class="line">NSDictionary                否                                  是                      NSMutableDictionary</span><br><span class="line">NSMutableDictionary         是                NSDictionary      是                      NSMutableDictionary</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文主要收录一些Ios面试中常会问到的一些题目&lt;/p&gt;
&lt;h3 id=&quot;1、frame和bounds的区别&quot;&gt;&lt;a href=&quot;#1、frame和bounds的区别&quot; class=&quot;headerlink&quot; title=&quot;1、frame和bounds的区别&quot;&gt;&lt;/a&gt;1、frame和bounds的区别&lt;/h3&gt;&lt;p&gt;&amp;ensp; &amp;ensp; 1、frame：该view在父视图坐标系中的位置和大小，参考坐标系为父视图。 2、bounds：该view在自己坐标系中位置和大小，参考坐标系为自己。3、要想知道自身的坐标，只需要知道其在父视图中的坐标即可。因此当一个父视图包含一个子视图时，可以通过修改父视图的bounds属性修改其在父视图中的相对位置。 因为bounds参考坐标系为自身，因此修改bounds的x,y坐标相当于修改其自身坐标原点的位置，从而修改了子视图参考父视图的位置。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>dart学习笔记</title>
    <link href="http://yoursite.com/2021/05/31/dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/05/31/dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-31T11:24:52.000Z</published>
    <updated>2021-08-23T12:19:57.204Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp; &ensp; 本文记载dart入门的一些基础<br>参考 <a href="https://flutter.cn/docs/development/ui/interactive" target="_blank" rel="noopener">https://flutter.cn/docs/development/ui/interactive</a></p><h3 id="有状态和无状态widgets"><a href="#有状态和无状态widgets" class="headerlink" title="有状态和无状态widgets"></a>有状态和无状态widgets</h3><p>&ensp; &ensp; 在flutter中，渲染在界面上的视图都可以堪称是一个个的widget构成，类比ios中的视图view，一些widget是无状态的，都是stateleesWidget的子集，比如Icon，Text，IconButton等，其他widget是有状态的，是statefulWidget的子集。这些widget可以通过和用户的交互改变自身的状态和表现出来的样式，比如：CheckBox，Slider，Form等。</p><a id="more"></a><p>&ensp; &ensp; 一个有状态的widget包含两个子类，一个statefulWidget子类和一个state子类，state累包含该widget的可变状态并定义该widget的build()方法。当wedget状态变化时，State对象调用setState(),告诉框架重新绘制widegt。</p><h4 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h4><p>&ensp; &ensp;如何决定widget的状态管理可以通过以下原则：如果状态是用户数据，滑块的位置等最好由父widget进行管理。 如果状态有关界面外观效果，比如动画，状态最好由widget本身进行管理。</p><h3 id="动画概览"><a href="#动画概览" class="headerlink" title="动画概览"></a>动画概览</h3><p>&ensp; &ensp;flutter中的动画系统基于animation，Widget可以直接讲这些动画合并到子集的build方法中来读取他们的当前值或者监听他们的状态变化，也可以讲其作为复杂动画的基础传递给其他widget。</p><h4 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h4><p>&ensp; &ensp;动画的收腰组成部分就是Animation类，一个动画表现在在其生命周期内发生变化的特定类型的值。大多需要执行动画的wiget都需要接受一个Animation对象作为参数，从而获取动画的当前状态值以及应当监听的值的更改。</p><h4 id="addListener"><a href="#addListener" class="headerlink" title="addListener"></a>addListener</h4><p>&ensp; &ensp; 每当动画的状态发生变化时，动画会通知所有通过addListener添加的监听器。然后正在监听动画的state调用自身的setState方法，根据状态来进行widget重新构建。</p><h4 id="addStatusListener"><a href="#addStatusListener" class="headerlink" title="addStatusListener"></a>addStatusListener</h4><p>&ensp; &ensp; 动画还提供了AnimationStatus，表示动画讲如何随时间进行变化，当动画状态发生变化时，动画都会通知addStatusListener添加的监听器。</p><h3 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h3><p>&ensp; &ensp; 补间动画本身值定义了如何在两个值件进行插值。要获取动画当前帧的具体值，需要一个动画来确定当前状态，有两种方法可以讲补间动画与动画组合在一起以获得动画具体值。 1、 使用evaluate方法处理动画的当前值获得一个对应的插值。 2、使用animate方法处理一个动画。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp; &amp;ensp; 本文记载dart入门的一些基础&lt;br&gt;参考 &lt;a href=&quot;https://flutter.cn/docs/development/ui/interactive&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://flutter.cn/docs/development/ui/interactive&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;有状态和无状态widgets&quot;&gt;&lt;a href=&quot;#有状态和无状态widgets&quot; class=&quot;headerlink&quot; title=&quot;有状态和无状态widgets&quot;&gt;&lt;/a&gt;有状态和无状态widgets&lt;/h3&gt;&lt;p&gt;&amp;ensp; &amp;ensp; 在flutter中，渲染在界面上的视图都可以堪称是一个个的widget构成，类比ios中的视图view，一些widget是无状态的，都是stateleesWidget的子集，比如Icon，Text，IconButton等，其他widget是有状态的，是statefulWidget的子集。这些widget可以通过和用户的交互改变自身的状态和表现出来的样式，比如：CheckBox，Slider，Form等。&lt;/p&gt;</summary>
    
    
    
    <category term="dart" scheme="http://yoursite.com/categories/dart/"/>
    
    
    <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>iOS消息传递机制和消息转发机制</title>
    <link href="http://yoursite.com/2021/04/01/iOS%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/04/01/iOS%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/</id>
    <published>2021-04-01T05:53:15.000Z</published>
    <updated>2021-08-23T12:20:21.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>&ensp; &ensp; objective-c是一门动态语言，是c语言的超集。在c语言中，编译期间就必须根据代码执行的顺序决定运行时期的执行结果。在编译结束之后就知道代码最终会走进哪一个方法。在objectvie-c中，方法是动态绑定的，对象在运行过程中根据消息转发机制对相应的方法做出响应。</p><a id="more"></a><h3 id="iOS消息传递"><a href="#iOS消息传递" class="headerlink" title="iOS消息传递"></a>iOS消息传递</h3><p>&ensp; &ensp; 一般来说消息传递是指对象在进行方法调用时，如果在该对象中找不到对应的方法实现，就会到改对象的父类中查找对应的方法实现。如果找到则继续执行下去。如果没有找到继续到父类中寻找对应的方法实现，如果到基类中还是没有找到对应的方法实现，则会触发消息转发机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id returnValue = [someObject messgeName:parameter];</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; 上面示例中，someObject是方法调用着，messaName是方法名，也称为selector（选择子），选择子和其所带的参数合称为消息。运行过程中，编译器会将商法消息转化为objc_msgSend()进行调用。原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void objc_msgSend(id self, SEL cmd, ...)</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>&ensp; &ensp;  第一个参数是方法调用者，第二个参数是选择子（应该是指向对应c语言方法实现的一个指针），后面的可变参数是消息所携带的参数。</p><p>消息传递完整流程：</p><p>&ensp; &ensp; 1、方法调用者根据isa指针找到自己所属类的方法列表，首先会去cache中查找是否有方法实现，如果有则找到直接运行。如果没有则道方法列表中寻找对应的方法实现。如果该类实现了这个方法，那么会将这个方法加入到cache中，并执行这个方法。</p><p>&ensp; &ensp; 2、如果在该类的方法别表中找不到对应的方法实现，会到这个类的父类中使用相同的方式查找相对应的方法实现。</p><p>&ensp; &ensp; 3、如果到基类中都没有找到objc_msgSend()中的选择子的方法。那么将会触发消息转发机制。</p><h3 id="iOS消息转发"><a href="#iOS消息转发" class="headerlink" title="iOS消息转发"></a>iOS消息转发</h3><p>&ensp; &ensp;  在开发过程中经常会遇到，<strong><em>xxx: unrecognized selector sent to instance</em></strong>,类似报错都是iOS方法在触发消息转发机制后，找不到对应的方法实现抛出的问题。其完成的流程图如下：</p><p><img src="/2021/04/01/iOS消息传递机制和消息转发机制/iOS%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="ios消息转发流程"></p><p>&ensp; &ensp; 从图中可以看到，消息转发主要包括三个步骤</p><p>1、 method resolution</p><p>2、 fast forwarding</p><p>3、 normal forwarding</p><p>如果想要最后不会抛出<strong><em>unrecognized selector</em></strong>的异常，那么就必须在消息转发中的某一个步骤拯救。</p><h4 id="method-resolution"><a href="#method-resolution" class="headerlink" title="method resolution"></a>method resolution</h4><p>&ensp; &ensp; 如果调用了实例方法会进行<strong><em>+(BOOL)resolveInstanceMethod:(SEL)sel</em></strong>判断，如果调用了类方法，则会进行<strong><em>+(BOOL)resolveClassMethod:(SEL)sel</em></strong>，返回yes则表示可以进行消息处理，否则进入到第二步。</p><h4 id="fast-forwarding"><a href="#fast-forwarding" class="headerlink" title="fast forwarding"></a>fast forwarding</h4><p> &ensp; &ensp; 如果第一步返回NO，进入<br> <strong><em>-(id)forwardingTargetForSelector:(SEL)aSelector</em></strong>，并在其中使用替代的类型方法去响应。</p><h4 id="Normal-forwarding"><a href="#Normal-forwarding" class="headerlink" title="Normal forwarding"></a>Normal forwarding</h4><p>&ensp; &ensp; 如果第2步返回self或者nil,则说明没有可以响应的目标 则进入第三步。<br>第三步的消息转发机制本质上跟第二步是一样的都是切换接受消息的对象，但是第三步切换响应目标更复杂一些，第二步里面只需返回一个可以响应的对象就可以了，第三步还需要手动将响应方法切换给备用响应对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1)-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;&amp;ensp; &amp;ensp; objective-c是一门动态语言，是c语言的超集。在c语言中，编译期间就必须根据代码执行的顺序决定运行时期的执行结果。在编译结束之后就知道代码最终会走进哪一个方法。在objectvie-c中，方法是动态绑定的，对象在运行过程中根据消息转发机制对相应的方法做出响应。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS drawRect&amp;drawTextInRect</title>
    <link href="http://yoursite.com/2021/03/27/iOS-drawRect-drawTextInRect/"/>
    <id>http://yoursite.com/2021/03/27/iOS-drawRect-drawTextInRect/</id>
    <published>2021-03-27T01:47:36.000Z</published>
    <updated>2021-08-23T10:32:04.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>&ensp; &ensp; 最近在给一段文字增加padding时，使用了系统API <strong>boundingRectWithSize:options:attributes:context</strong>来计算可变文案的size，然后通过在该size下增加一个水平和垂直的padding并且文案居中对齐获得label/view的size。这样的做法在极端情况下会出现异常情况，由于view/label的最大size是固定好的，因此就算使用计算得到size最后还是只能使用label可以展示的最大size。最后的结果是正常长度的文案可以显示padding，但是过长的文案padding无效。</p><a id="more"></a>  <p><img src="/2021/03/27/iOS-drawRect-drawTextInRect/%E6%AD%A3%E5%B8%B8%E5%B1%95%E7%A4%BA.png" alt="正常展示"></p><p><img src="/2021/03/27/iOS-drawRect-drawTextInRect/%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B1%95%E7%A4%BA.png" alt="不正常展示"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>&ensp; &ensp; 这个问题的解决方式可以通过自行操作label中文案显示来解决。大致意思就是给定一个空的label，如何展示以及展示在什么位置由自己决定。</p><h4 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect"></a>drawRect</h4><p>&ensp; &ensp; 使用这个方法可以在视图中绘制一些自己想要的图案。但是有一些注意事项：<br>1.这个方法不需要手动触发，当视图需要重新渲染或者视图发生变化会调用。2.可以通过在继承自uiView的子类中调用该方法来绘制图形。 具体的使用方式可以参考这篇文章中的写法。</p><p><a href="https://www.jianshu.com/p/1aae00b4e440" target="_blank" rel="noopener">https://www.jianshu.com/p/1aae00b4e440</a></p><h4 id="drawTextInRect"><a href="#drawTextInRect" class="headerlink" title="drawTextInRect"></a>drawTextInRect</h4><p>&ensp; &ensp; 使用此方法会在视图渲染的时候触发，只需要在其中设置文案的inset和rect。其中rect是渲染前已经是确定好的，因此只需要设置需要padding的值即可。</p><p>&ensp; &ensp; 最终决定的解决方案是使用drawTextInrect</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawTextInRect:(CGRect)rect &#123;</span><br><span class="line">    UIEdgeInsets insets = &#123;0, 5, 0, 5&#125;;</span><br><span class="line">    [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;&amp;ensp; &amp;ensp; 最近在给一段文字增加padding时，使用了系统API &lt;strong&gt;boundingRectWithSize:options:attributes:context&lt;/strong&gt;来计算可变文案的size，然后通过在该size下增加一个水平和垂直的padding并且文案居中对齐获得label/view的size。这样的做法在极端情况下会出现异常情况，由于view/label的最大size是固定好的，因此就算使用计算得到size最后还是只能使用label可以展示的最大size。最后的结果是正常长度的文案可以显示padding，但是过长的文案padding无效。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>一年多以后的再一次更新</title>
    <link href="http://yoursite.com/2021/03/15/%E4%B8%80%E5%B9%B4%E5%A4%9A%E4%BB%A5%E5%90%8E%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2021/03/15/%E4%B8%80%E5%B9%B4%E5%A4%9A%E4%BB%A5%E5%90%8E%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E6%9B%B4%E6%96%B0/</id>
    <published>2021-03-15T09:43:48.000Z</published>
    <updated>2021-08-23T12:17:05.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp; &ensp; 距离上一次更新已经是一年多以前了。回想起来这一年多过的老快了，好像啥也没做就过去了。自己也已经步入社会10个月了吧。年前的几个月感觉没什么区别，现在慢慢接触的人和东西多了以后感觉进入社会还真的和学校不太一样，不知道是不是因为公司里同龄人比较少的原因。大多数的人好像把甩锅放到了首位，而不是想第一时间先解决问题。官场气息有点高，总感觉自己比别人早来一段时间要厉害一些。有一股子颐指气使的味道。我自己还是很讨厌这种氛围的。感觉在这种环境中自己也会变成这样的人。努力保证自己变得慢一点吧。</p><a id="more"></a> <p> &ensp; &ensp; 说到自己其他的变化，好像变得不喜欢出门了。也许是这边没有认识的人的缘故吧。总感觉出门到处溜达如果不是认识的人一起会变得好累。还不如呆在屋子里就这样躺着发呆。我还真是闲的一。）</p><p>&ensp; &ensp; 再说说能力吧，写码能力确实相比之前提升了一丢丢，但是还是差了好多。后续还是要开始刷leetcode了吧，不然自己的思维能力总是会差一些。面对一些问题，有时自己的思维总是要稍微差一点。对一个问题的思考方式也需要改变。我只希望在自己的不断业务开发里面能稍微提高一下自己的思考方式。</p><p>&ensp; &ensp; 接下来几个月，我尽量保证自己一周更新一篇文章吧，也算是给自己定一个目标，然后积累自己最近了解的一些东西。然后一些题解，一些自己的观点啥的。那就从这一篇开始吧。</p><h3 id="ios阴影不展示"><a href="#ios阴影不展示" class="headerlink" title="ios阴影不展示"></a>ios阴影不展示</h3><p>&ensp; &ensp; 记录一下今天遇到的阴影不展示的问题，这篇博客里面做出了详细的指导，感谢原作者。下面放了链接。</p><p><a href="https://www.jianshu.com/p/0f24ad35788d" target="_blank" rel="noopener">https://www.jianshu.com/p/0f24ad35788d</a></p><p>&ensp; &ensp; 先描述一下今天遇到的问题，我在给一个view设置阴影的时候发现无论如何设置阴影都无法展示。一开始以为设置的方式有问题，然后查了一下阴影相关的一些属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(CGColorRef *) shadowColor//阴影颜色</span><br><span class="line">(float) shadowOpacity//阴影透明度</span><br><span class="line">(CGSize) shadowOffset//阴影偏移量</span><br><span class="line">(CGFloat) shadowRadius//模糊计算的半径</span><br><span class="line">(CGPathRef *) shadowPath//阴影路径</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; 需要特别注意的一点是：在设置阴影的时候必须给view指定一个背景色，否则阴影是无法显示的。但是我这次遇到的这个问题是其他原因。当给一个view同时设置圆角和阴影时，圆角的效果可以展示，但是阴影的效果是没有的。这是因为在设置圆角是需要设置一个maskToBounds = yes的属性，这个动作会将子视图超过父视图的部分给clips掉，然后就会导致边缘的阴影是无法展示的。</p><p>&ensp; &ensp; 因此正确的做法应该是重新引入一个视图作为当前视图的父视图，然后子视图只设置圆角，父视图负责设置阴影。当然这样做当子视图没有填满父视图的时候，会导致圆角看起来没有生效，所以这一点还是需要小心的。</p><h3 id="ios-协议"><a href="#ios-协议" class="headerlink" title="ios 协议"></a>ios 协议</h3><p>&ensp; &ensp; 这里主要总结一下iOS协议的一些基本只是和用法，主要包括以下两个部分。1、iOS协议的声明和使用。2、iOS协议，代理，委托，几个名词的含义和关系。3、iOS在协议中声明属性。</p><h4 id="1、iOS协议的声明和使用"><a href="#1、iOS协议的声明和使用" class="headerlink" title="1、iOS协议的声明和使用"></a>1、iOS协议的声明和使用</h4><p>&ensp; &ensp;iOS协议的声明类似于C++中的纯虚函数。告诉外界如果遵守（继承）了这个协议，就有能力实现协议中声明的方法，进而完成一些类本身无法完成的事。</p><p>&ensp; &ensp; 这样看起来和继承没什么区别。接下来加一些限制，在iOS开发中，伴随着协议还有一个名词，那就是代理（delegate）。试想这样一个场景，在一个页面容器中，包含两个子页面成为子页面1和子页面2。其中子页面2的数据来源需要依靠子页面1.现在的问题就是如何从子页面2拿到子页面1提供的数据。这里就可以使用协议了。方法如下：</p><p>&ensp; &ensp; 声明一个协议A，子页面2继承协议A，但是子页面2无法完成协议A中的方法，因此使用代理将这些方法交给子页面1或者父容器去实现。具体要做的事就是取到子页面1中提供的数据，然后为子页面2提供数据源。这样就是一个协议完成工作的整个流程了。</p><h4 id="2、iOS协议，代理，委托"><a href="#2、iOS协议，代理，委托" class="headerlink" title="2、iOS协议，代理，委托"></a>2、iOS协议，代理，委托</h4><p>&ensp; &ensp; 协议：提供了可以解决一些问题的方法声明，但是没有实现，需要有能力实现的类去实现。（任务）</p><p>&ensp; &ensp; 代理（delegate）：上面所说的子页面2，子页面2无法完成数据请求，需要继承协议。那协议的实现需要其他类去帮忙完成。因此设置一个代理属性。（boss）</p><p>&ensp; &ensp; 委托：实现协议的类。最后能够实现协议，完成功能的类。（开发）</p><h4 id="3、iOS在协议中声明属性"><a href="#3、iOS在协议中声明属性" class="headerlink" title="3、iOS在协议中声明属性"></a>3、iOS在协议中声明属性</h4><p>&ensp; &ensp; 在协议中是可以声明属性的。在一般的类中声明属性（property）的同时编译器会自动生成该属性的setter和getter方法和一个成员。但是在协议中声明属性的话是无法自动生成读取方法的。在继承协议时会有编译器警告，可以手动添加读取方法也可以使用关键字synthesize自动补全。同样的效果也发生在分类上。</p><h3 id="tableview-cell重用机制"><a href="#tableview-cell重用机制" class="headerlink" title="tableview cell重用机制"></a>tableview cell重用机制</h3><p>&ensp; &ensp; iOS tableview cell 的重用在节约了很大的内存空间，并且在滑动过程中通过重用机制可以提升性能。而且通过model进行数据传递还可以解决滑动过程中cell重复的问题。</p><p>&ensp; &ensp; 在重用机制主要依靠<strong>两个mutableArray：visiableCells和reusabelCells</strong>。如果某一次接口返回了20条数据，但是屏幕一次只能展示6条数据，那么前6条数据的展示就需要 initWithStyle:reuseIdentifier:初始化6个cell来展示，此时6个cell都是visible的，当滑动屏幕时，会创建第7个visible的cell，因为此时的reuseableCells是没有可用cell的。当出现第7个cell时第一个cell会消失，存储到reusableCells中，并从visibleCell中移除。然后继续滑动到第8个cell时，会通过”Identifier“字段判断当前cell是否可重用，如果可以重用，那么就从不在创建新的cell，而是使用第一个cell来进行展示 <em>（1）</em>。如果不可重用，那么创建一个新的cell并指定一个新的”identifer“。</p><p>&ensp; &ensp; 需要注意的点：1.重用机制是通过reuseIdentify来实现的，要保证不出现问题，只需要保证数据类型一致。如果是特殊的数据，就重新使用一个identify来创建一个新的cell。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;ensp; &amp;ensp; 距离上一次更新已经是一年多以前了。回想起来这一年多过的老快了，好像啥也没做就过去了。自己也已经步入社会10个月了吧。年前的几个月感觉没什么区别，现在慢慢接触的人和东西多了以后感觉进入社会还真的和学校不太一样，不知道是不是因为公司里同龄人比较少的原因。大多数的人好像把甩锅放到了首位，而不是想第一时间先解决问题。官场气息有点高，总感觉自己比别人早来一段时间要厉害一些。有一股子颐指气使的味道。我自己还是很讨厌这种氛围的。感觉在这种环境中自己也会变成这样的人。努力保证自己变得慢一点吧。&lt;/p&gt;</summary>
    
    
    
    <category term="回顾" scheme="http://yoursite.com/categories/回顾/"/>
    
    
    <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>blog record</title>
    <link href="http://yoursite.com/2020/06/16/blog-record/"/>
    <id>http://yoursite.com/2020/06/16/blog-record/</id>
    <published>2020-06-16T10:32:15.000Z</published>
    <updated>2020-06-16T15:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>现在是2020年6月16日晚23：02，明天是我成为社畜的第一天，本想早几天记录下从武汉毕业到南京这几天心路历程，偷懒到只能在现在写点什么了。在没动手前觉得自己可以写好多东西的，现在就感觉之前所想到的好像都忘记了一样。不过没事，随便记录一下表示自己也是一个有感情的人吧。</p><a id="more"></a> <h3 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h3><p>撒西不理啦，上次写日志还是在好几个月前，说来也惭愧，疫情导致自己一直再找借口不学习。好在从现在开始如果我不去学习只有等着被淘汰，所以我应该会好好学点什么的吧。</p><p>七号晚上到达武汉，在是否能够进校毕业这件事上又给自己弄出了好些问题，好在最后成功进校，完成了算是近年来的第一个小目标吧。见到了那么久都没有见过的同学。虽然又一两个在游戏听到了声音，但是见到总还是觉得很开心。进行了象征性的毕业聚餐。照了几张毕业照，可是好烦啊，为什么在家呆了小半年我又变黑了，淦！</p><p>11号离开了武汉，10和两个好朋友吃了个简单的散伙饭。这两个b是真的见色忘义，为了晚上和女朋友玩直接抛弃我？还好良心发现知道请我吃顿好的（原本这餐饭是该我请的）。那这个问题久跳过吧。</p><p>不知道是不是这段时间来二次元看多了，有时候自己好想学着那些主角的性格做事，好中二! 不过我还是发现了自己确实做不到别人那种地步，毕竟咱还是活在三次元的。有时候知晓自己的性格，不要给别人带去麻烦我觉得是很重要的，我所说的不是搞清楚自己喜欢吃什么，喜欢什么运动。而是在和其他人相处时自己能做的久不要随意使唤他人了。至少目前这是我的观点，当然在好朋友面前这个观点不成立（这也是我的观点，禁止套娃！）。</p><p>都这样了，还是贴一张最后聚餐的照片吧，说到这，我忽然想起对班长说的一句话，比起拍照，我更喜欢用眼睛记录下那些美好的瞬间。我也不清楚这是不是我的真心话，有时候我也幻想自己可以拍一些搞笑二比的照片，但是好像没怎么实现，可能还是我出于对自己在照片中样貌的厌恶吧（也许）。</p><p><img src="/2020/06/16/blog-record/fir.jpg" alt="pic"></p><p>这个b还闭着眼，啧啧。</p><h3 id="chapter2"><a href="#chapter2" class="headerlink" title="chapter2"></a>chapter2</h3><p>到了南京首要任务就是找房子住了，我是真没想到最后为了付房租需要花费我几大千。现在只能寄希望于入职后下个月的工资了。</p><p>反正8到12号这几天走的我怀疑人生就是了。原本在这里有好多想写的，现在要下笔了却又不知道写啥了。有些东西感悟过就行，不过希望真的对于我能起到一点点作用，我现在还记得前段时间自己不断狂立flag，然后狂倒flag的惨烈景象。</p><p>室友比较好相处还是不错的，大家性格都优点大大咧咧，目前看来是这样，还是希望之后能好好相处，不然出啥乱子了面子上还是不太挂得住。希望不要遇到之前脑子想的那些情况，对彼此有意见却一直不说，到了某一天再爆发那就很恐怖了。<br>为了防止那种情况发生，还是要注意下自己的言行，不要或者少做出过激行为，有时候自己会头脑发热搞些屁事出来，我还是承认这一点的。</p><h3 id="chapter3"><a href="#chapter3" class="headerlink" title="chapter3"></a>chapter3</h3><p>哎，又觉得没得说了，哦对了，拍了一张离开宿舍时的照片，还是放一下吧，留个念想，下次再去不知道什么时候了。</p><p><img src="/2020/06/16/blog-record/sec.jpg" alt="pic"></p><p>还有就是和室友做了最后道别了，不，是一次愉快的道别。希望他研究生能够成为大腿吧，以后也许可以抱一抱（\卑微.jpg）。</p><p>所以啊，我觉得有时候一些自己所认为的好朋友还是一起稍微呆一段时间久好好做各自的事情为好。不然总会发现别人性格中的自己厌恶的地方。要是找不到？那也许就是知己吧（我瞎说的）。要说有什么后悔的嘛，感觉很多的来着，但是现在却一条也想不起来了。也许是我又想偷懒了，想睡觉不想写了。</p><p>感觉这四年来对于自己也没啥好总结的，性格应该变了一些，对了后悔就是自己这段时间没有好好看玩一本书了。这原本是我已经培养了快两年的爱好，之后一定要继续下去。</p><p>虽然好多人调侃说今年的愿望是活下去。我也不知道说什么。困难的事请总会来临，但是过了之后感觉也就那样了。所以痛苦的感觉我也记不清了，但是经历的时候是真的痛苦。开心的时候也是真的开心。</p><p>那就祝自己工作上少犯点错。尽快学会自己解决问题吧。 就不用照片镇楼了。之后还得继续更新自己博客哦。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;现在是2020年6月16日晚23：02，明天是我成为社畜的第一天，本想早几天记录下从武汉毕业到南京这几天心路历程，偷懒到只能在现在写点什么了。在没动手前觉得自己可以写好多东西的，现在就感觉之前所想到的好像都忘记了一样。不过没事，随便记录一下表示自己也是一个有感情的人吧。&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/其他/"/>
    
    
    <category term="感悟" scheme="http://yoursite.com/tags/感悟/"/>
    
  </entry>
  
  <entry>
    <title>swift语法基础(四)</title>
    <link href="http://yoursite.com/2020/01/23/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%9B%9B/"/>
    <id>http://yoursite.com/2020/01/23/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%9B%9B/</id>
    <published>2020-01-23T07:12:12.000Z</published>
    <updated>2020-02-07T05:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>swift统一的函数语法非常灵活，可以用来表示任何函数，包括最简单的没有参数名字的c风格函数，到复杂的带局部外部参数名的OC风格参数，参数可以听过默认值，以简化函数调用。参数也可以及当作传入参数，也当作传出参数。也就是说，一旦函数执行，传入的参数值会被修改。</p><p>swift中每一个函数都有一个由函数的参数类型和返回值类型组成的类型。可以把函数类型当作任何其他变量类型处理。这样可以简单的把函数当作别的函数的参数。也可以从其他函数中返回函数。函数定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现封装。</p><a id="more"></a><h4 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h4><p>当定义一个函数时，可以定义一个或多个有名字和类型的值，作为函数的输入，称为参数，也可以定义某种类型的值作为函数执行结束的输出作为返回类型。</p><p>每个函数有一个函数名，用来描述函数执行的任务，使用函数时，用函数名调用。并传给它匹配的输入值（实参），函数的实参必须与函数参数表里参数顺序一致。</p><p>下面是一个 greet函数例子:</p><pre><code>func greet(person: String) -&gt; String {    let greeting = &quot;Hello, &quot; + person + &quot;!&quot;    return greeting}print(greetAgain(person: &quot;Anna&quot;))// 打印“Hello again, Anna!”</code></pre><p>所有这些信息汇总起来称为函数定义，以func作为前缀。 -&gt; 后跟返回类型。</p><h4 id="函数参数与返回值"><a href="#函数参数与返回值" class="headerlink" title="函数参数与返回值"></a>函数参数与返回值</h4><ul><li><p>无参函数</p><p>函数可以没有参数，这个函数就是一个无参数函数。但是函数名后面还是需要圆括号。</p></li><li><p>多参数函数</p></li></ul><p>函数可以有多种输入参数，这些参数被包含在函数的括号中，用逗号分隔。</p><pre><code>func greet(person: String, alreadyGreeted: Bool) -&gt; String {if alreadyGreeted {    return greetAgain(person: person)} else {    return greet(person: person)}}print(greet(person: &quot;Tim&quot;, alreadyGreeted: true))// 打印“Hello again, Tim!”</code></pre><ul><li>无返回值函数</li></ul><p>函数可以没有返回值，如下：</p><pre><code>func greet(person: String) {    print(&quot;Hello, \(person)!&quot;)}greet(person: &quot;Dave&quot;)// 打印“Hello, Dave!”</code></pre><ul><li>多重返回值函数</li></ul><p>可以用元组类型让多个值作为一个复合值从函数中返回。如下:</p><pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int) {var currentMin = array[0]var currentMax = array[0]for value in array[1..&lt;array.count] {    if value &lt; currentMin {        currentMin = value    } else if value &gt; currentMax {        currentMax = value    }}    return (currentMin, currentMax)}</code></pre><p>该函数返回一个包含两个Int的元组，这些值被标记为min和max。</p><pre><code>let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)// 打印“min is -6 and max is 109”</code></pre><p>需要注意的是元组成员不需要在元组从函数中返回时命名。因为名字已经在返回类型中指定了。</p><ul><li>可选元组返回类型</li></ul><p>如果函数返回的元组类型可能整个元组都没有值，可以使用可选的元组作为返回类型反映元组是nil。可以通过在元组类型的右括号后放置一个问号来定义一个可选元组。例如:(Int,Int)?或者 (String,Bool,Int)?</p><p>前面minmax(array:)函数返回一个包含两个Int值的元组，但是函数不会对传入的数组执行任何安全检查，如果array是一个空数组，在执行时会触发错误。所以为了解决这个问题，函数改写为使用可选元组返回类型，当数组为空时返回nil:</p><pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {if array.isEmpty { return nil }var currentMin = array[0]var currentMax = array[0]for value in array[1..&lt;array.count] {    if value &lt; currentMin {        currentMin = value    } else if value &gt; currentMax {        currentMax = value    }}    return (currentMin, currentMax)}</code></pre><ul><li>隐式返回的函数</li></ul><p>如果一个函数的整个函数体是单行表达式，这个函数可以隐式的返回这个表达式。</p><h4 id="函数标签和参数名称"><a href="#函数标签和参数名称" class="headerlink" title="函数标签和参数名称"></a>函数标签和参数名称</h4><p>每个函数都有一个参数标签以及一个参数名称，参数标签在调用函数的时候使用，调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用，默认情况下，函数参数使用参数名称来作为参数标签。</p><ul><li>指定参数标签</li></ul><p>可以在参数名称前指定参数标签，中间用空格分隔:</p><pre><code>func someFunction(argumentLabel parameterName: Int) {// 在函数体内，parameterName 代表参数值}</code></pre><p>一个新版greet例子:</p><pre><code>func greet(person: String, from hometown: String) -&gt; String {return &quot;Hello \(person)!  Glad you could visit from \(hometown).&quot;}print(greet(person: &quot;Bill&quot;, from: &quot;Cupertino&quot;))// 打印“Hello Bill!  Glad you could visit from Cupertino.”</code></pre><p>参数标签能够让函数在调用是更有表达力。</p><ul><li>忽略参数标签</li></ul><p>如果不希望为某个参数添加一个标签，使用下划线代替:</p><pre><code>func someFunction(_ firstParameterName: Int, secondParameterName: Int) { // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值}someFunction(1, secondParameterName: 2)</code></pre><ul><li>默认参数值</li></ul><p>可以在函数体中通过给参数赋值来为任意一个参数定义默认值，默认值被定义后，调用这个函数时可以忽略这个参数。一般将带有默认值的参数放在末尾。</p><ul><li>可变参数</li></ul><p>可变参数可以接受0个或者多个值，函数调用时，可以用可变参数来指定函数参数可以被传入不确定的输入值。在变量类型名后加入(…)表示可变参数。</p><pre><code>func arithmeticMean(_ numbers: Double...) -&gt; Double {var total: Double = 0for number in numbers {    total += number} return total / Double(numbers.count)} //使用可变参数计算任意长度数字的平均数arithmeticMean(1, 2, 3, 4, 5)// 返回 3.0, 是这 5 个数的平均数。arithmeticMean(3, 8.25, 18.75)// 返回 10.0, 是这 3 个数的平均数。</code></pre><p><strong>notice：</strong>一个函数最多由一个可变参数。</p><ul><li>输入输出参数</li></ul><p>如果函数参数是常量，则不能在函数内修改。如果想要修改参数的值，并且想在这些修改在函数调用后任然存在，需要将参数定义为输入输出参数。</p><p>定义一个输入输出参数时，在参数顶以前加<strong>inout</strong>关键字，一个输入输出参数由传入函数的值，这个值被函数修改，然后传出函数。</p><p>只能传递变量给输入输出参数，当传入的参数作为输入输出参数时，需要在参数名前加 &amp;，表示这个值可以被函数修改。 例子如下：</p><pre><code>func swapTwoInts(_ a: inout Int, _ b: inout Int) {    let temporaryA = a    a = b    b = temporaryA}//调用如下var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)// 打印“someInt is now 107, and anotherInt is now 3”</code></pre><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>每个函数都有中特定的函数类型，函数的类型由函数的参数类型和返回类型组成。</p><pre><code>func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {    return a + b}func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int {    return a * b}</code></pre><p>这两个函数的类型为(Int,Int)-&gt;Int</p><pre><code>func printHelloWorld() {    print(&quot;hello, world&quot;)}//函数类型为 ()-&gt; void</code></pre><ul><li>使用函数类型</li></ul><p>使用函数类型可以：定义一个类型为函数的常量或者变量，将适当的函数赋值给他。</p><pre><code>var mathFunction: (Int, Int) -&gt; Int = addTwoInts</code></pre><p>上面代码解读为: 定义一个mathFunction的变量，类型是一个有两个Int的参数，并返回一个Int的函数。让这个新变量指向addTwoInts函数。</p><p>现在可以使用mathFunction调用被复制的函数。</p><pre><code>print(&quot;Result: \(mathFunction(2, 3))&quot;)// Prints &quot;Result: 5&quot;</code></pre><p>也可以将相同类型匹配的不同函数赋值给同一个变量：</p><pre><code>mathFunction = multiplyTwoIntsprint(&quot;Result: \(mathFunction(2, 3))&quot;)// Prints &quot;Result: 6&quot;</code></pre><p>也可以简单写法，使用swift的推断机制，推出变量为函数类型：</p><pre><code>let anotherMathFunction = addTwoInts// anotherMathFunction 被推断为 (Int, Int) -&gt; Int 类型</code></pre><ul><li>函数类型作为参数类型</li></ul><p>使用(Int,Int)-&gt;Int 这样的函数作为另一个函数的参数类型，这样可以将函数的一部分实现留给函数的调用者提供。如下例子：</p><pre><code>func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {print(&quot;Result: \(mathFunction(a, b))&quot;)}printMathResult(addTwoInts, 3, 5)// 打印“Result: 8”</code></pre><p>如上定义了一个 printMathResult(<em>:</em>:_:)函数，有三个参数，第一个参数为函数类型，可以传入任何类型的这个函数。它不关心传入的函数如何实现，只关心传入函数是不是一个正确的类型。</p><ul><li>函数类型作为返回类型</li></ul><p>可以用函数类型作为另一个函数的返回类型，需要做的是在返回箭头(-&gt;)后写一个完成的函数类型，例子如下：</p><pre><code>func stepForward(_ input: Int) -&gt; Int {    return input + 1}func stepBackward(_ input: Int) -&gt; Int {    return input - 1}func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {    return backward ? stepBackward : stepForward}//chooseStepFunction返回类型是(Int)-&gt;(Int),</code></pre><p>现在可以使用如下方式调用该函数:</p><pre><code>var currentValue = 3let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero 现在指向 stepBackward() 函数。</code></pre><p>现在 moveNearToZero是一个函数类型，可以像函数那样使用它:</p><pre><code>print(&quot;Counting to zero:&quot;)// Counting to zero:while currentValue != 0 {    print(&quot;\(currentValue)... &quot;)    currentValue = moveNearerToZero(currentValue)}print(&quot;zero!&quot;)// 3...// 2...// 1...// zero!</code></pre><ul><li>嵌套函数</li></ul><p>函数可以定义在别的函数体中，称为嵌套函数，默认情况下,嵌套函数对外界不可见，但是可以被他们的外围函数调用，一个外围函数可以返回他的某个嵌套函数，使得这个函数可以在其他域中被使用。下面例子chooseStepFunction(backward:) 函数：</p><pre><code>func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {func stepForward(input: Int) -&gt; Int { return input + 1 }func stepBackward(input: Int) -&gt; Int { return input - 1 }return backward ? stepBackward : stepForward}var currentValue = -4let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero now refers to the nested stepForward() functionwhile currentValue != 0 {    print(&quot;\(currentValue)... &quot;)    currentValue = moveNearerToZero(currentValue)}print(&quot;zero!&quot;)// -4...// -3...// -2...// -1...// zero!</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是自包含的函数代码块，可以在代码中被传递和使用。闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。swift会管理在捕获过程中涉及的所有内存操作。前面介绍的全局和嵌套函数实际也是特殊的闭包。闭包采用如下三种形式之一:</p><pre><code>1. 全局函数是一个有名字但不会捕获任何值得闭包2. 嵌套函数是一个有名字并可以捕获其封闭函数域内值得闭包3. 闭包表达式是一个利用轻量级语法所写的可以捕获上写问中变量或常量的匿名闭包。</code></pre><p>swift的闭包表达式风格简单，鼓励在常见场景中进行语法优化，主要优化如下：</p><pre><code>1. 利用上下文推断参数和返回值类型2. 隐式返回单表达式闭包，即表达式闭包可以省略return关键字3. 参数名称缩写4. 尾随闭包语法</code></pre><h4 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h4><p>闭包表达式是一种构建内敛闭包的方式，语法简洁，在保证不丢失它语法清晰明了的同时，闭包表达式提供了几种优化的语法简写形式，下面例子通过对sorted(by:)这个案例的多次迭代改进来展示这个过程：</p><p> swift标准库提供了 sorted(by:)的方法。会基于提供的闭包表达式的判断结果对数组中的值进行排序，一旦完成排序过程，该方法返回一个与就数组大小相同类型的新数组，该数组的元素有着正确的排序顺序，原数组不会被该方法修改。</p><p>sorted(by:)方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔值表明排序顺序。</p><pre><code>let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]func backward(_ s1: String, _ s2: String) -&gt; Bool {    return s1 &gt; s2} //倒序排列var reversedNames = names.sorted(by: backward)// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</code></pre><ul><li>闭包表达式语法</li></ul><p>闭包表达式有如下一般形式:</p><pre><code>{ (parameters) -&gt; return type in    statements}</code></pre><p>闭包表达式参数可以是inout参数，但不能设定默认值，如果命名了可变参数，可以使用可变参数，元组也可以作为参数和返回值。如下是backward函数对应闭包表达式代码：</p><pre><code>reversedNames = names.sorted(by: { (s1: String, s2:     String) -&gt; Bool in        return s1 &gt; s2})</code></pre><p>需要注意的是内敛闭包参数和返回值类型声明与backward(<em>:</em>:)类型声明相同。但在内连闭包表达式中，<strong>函数和返回值类型都写在大括号内而不是大括号外</strong>。<strong>闭包的函数体部分由关键字in</strong>引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。 </p><ul><li>根据上下文推断类型</li></ul><p>sorted(by:)方法的参数是传入的，swift可以推断其参数和返回值类型，sorted被一个字符串数组调用，因此参数必须为(string,string)-&gt;bool类型的函数。这意味者(string,string) 和bool类型不需要作为闭包表达式的一部分，因为所有的类型都可以被正确推断，返回箭头和围绕在参数周围的括号也可以省略：</p><pre><code>reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )//类型推断省略了参数类型以及箭头</code></pre><p>实际上，通过闭包表达式构造的闭包作为参数传递给函数或者方法时，总是可以推断出闭包的参数和返回值类型。因此可以不需要完整的格式构造内联闭包。</p><ul><li>但表达式闭包的隐式返回</li></ul><p>单行表达式闭包可以通过省略return来隐式返回单行表达式的结果。</p><pre><code>reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )</code></pre><ul><li>参数名称缩写</li></ul><p>swift自动为内联闭包提供了参数名称缩写，可以通过$0,$1,$2…来顺序调用闭包参数。</p><p>如果在闭包表达式中使用名称缩写，可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。in关键字也可以省略，因为此时闭包表达式完全由闭包函数体构成。</p><pre><code>reversedNames = names.sorted(by: { $0 &gt; $1 } )</code></pre><ul><li>运算符方法</li></ul><p>swift中的string类型定义了关于大于号(&gt;)的字符串实现，其作为一个函数接受两个string类型的参数并返回bool类型。刚好满足sorted函数的参数要求。因此可以如下:</p><pre><code>reversedNames = names.sorted(by: &gt;)</code></pre><ul><li>尾随闭包</li></ul><p>如果<strong>需要将一个很长的闭包表达式作为最后一个参数传递给函数</strong>，这个闭包替换成尾随闭包的形式效果更好。尾随闭包格式如下：</p><pre><code>    func someFunctionThatTakesAClosure(closure: () -&gt; Void) {    // 函数体部分}// 以下是不使用尾随闭包进行函数调用someFunctionThatTakesAClosure(closure: {    // 闭包主体部分})// 以下是使用尾随闭包进行函数调用someFunctionThatTakesAClosure() {    // 闭包主体部分}</code></pre><p>在闭包表达式语法章节字符串闭包可以作为尾随闭包的形式改写为：</p><pre><code>reversedNames = names.sorted() { $0 &gt; $1 }</code></pre><p>当闭包表达式时函数或者方法的唯一参数，当你使用尾随闭包时，可以省略为如下：</p><pre><code>reversedNames = names.sorted { $0 &gt; $1 } //省略括号</code></pre><p>当闭包非常长不能一行书写时，尾随闭包非常有用。举例来说，下面介绍了如何在map(_:)方法中使用尾随闭包将Int类型数组[16,58,510]转换为包含对应string类型的值的数组。</p><pre><code>let digitNames = [0: &quot;Zero&quot;, 1: &quot;One&quot;, 2: &quot;Two&quot;,   3: &quot;Three&quot;, 4: &quot;Four&quot;,5: &quot;Five&quot;, 6: &quot;Six&quot;, 7: &quot;Seven&quot;, 8: &quot;Eight&quot;, 9: &quot;Nine&quot;]let numbers = [16, 58, 510]</code></pre><p>上述代码创建了一个整型数位和他们英文名映射的字典，和一个转换数组。现在可以通过传递一个尾随闭包给numbers数组的map(_:)方法来创建对应的字符串版本数组。</p><pre><code>let strings = numbers.map {(number) -&gt; String invar number = numbervar output = &quot;&quot;repeat {    output = digitNames[number % 10]! + output    number /= 10} while number &gt; 0return output}// strings 常量被推断为字符串类型数组，即 [String]// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code></pre><p>上述例子中，number为前面定义的局部变量，因此可以在闭包函数体内对其进行修改。闭包表达式指定了返回类型为string。闭包表达式每次调用时创建一个output并返回结果。</p><ul><li>值捕获</li></ul><p>闭包可以在其被定义的上下文中捕获常量或者变量。即使定义这些常量的原作用域已经不存在，但是闭包任然可以在闭包函数体内引用和修改这些值。swift中捕获值得最简单形式是嵌套函数，嵌套函数可以捕获其外部函数得所有参数以及定义得常量和变量。</p><ul><li>闭包是引用类型</li></ul><p>无论是将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或者变量的值设置为对应函数或闭包的引用。这意味着将闭包赋值给两个不同的常量或者变量，两个值都指向同一个闭包。</p><p>逃逸闭包，自动闭包参考<a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/07_closures" target="_blank" rel="noopener">https://swiftgg.gitbook.io/swift/swift-jiao-cheng/07_closures</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h3&gt;&lt;p&gt;swift统一的函数语法非常灵活，可以用来表示任何函数，包括最简单的没有参数名字的c风格函数，到复杂的带局部外部参数名的OC风格参数，参数可以听过默认值，以简化函数调用。参数也可以及当作传入参数，也当作传出参数。也就是说，一旦函数执行，传入的参数值会被修改。&lt;/p&gt;
&lt;p&gt;swift中每一个函数都有一个由函数的参数类型和返回值类型组成的类型。可以把函数类型当作任何其他变量类型处理。这样可以简单的把函数当作别的函数的参数。也可以从其他函数中返回函数。函数定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现封装。&lt;/p&gt;</summary>
    
    
    
    <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
    <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift语法基础(三)</title>
    <link href="http://yoursite.com/2020/01/17/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%B8%89/"/>
    <id>http://yoursite.com/2020/01/17/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%B8%89/</id>
    <published>2020-01-17T04:23:04.000Z</published>
    <updated>2020-01-23T07:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><p>swift使用数组，集合，字典三种基本的集合类型用来存储集合数据，数组是有序数据的集，集合是无序数据的集，字典是无序的键值对的集。</p><p>swift中的数组，集合和字典必须明确其中保存的键和值类型，这样可以防止插入数据类型不一致。</p><ul><li>集合的可变性</li></ul><p>如果创建一个数组，集合或者字典并且把它分配成一个变量，那么这个集合将会是可变的。可以进行增删数据。如果是常量则它的大小和内容都不可变。</p><a id="more"></a> <h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组中相同的值可以出现在一个数组不同位置多次。简单语法为： Array &lt; Element&gt;，Element是这个数组中允许的数据类型，可以使用简单语法[Element]。</p><ul><li>创建空数组</li></ul><p>使用下面语法创建一个空数组：</p><pre><code>var someInts = [Int]()print(&quot;someInts is of type [Int] with \(someInts.count) items.&quot;)// 打印“someInts is of type [Int] with 0 items.”</code></pre><p>如果代码中提供了类型信息，可以使用空数组语句将一个数组改为空数组</p><pre><code>someInts.append(3)// someInts 现在包含一个 Int 值someInts = []// someInts 现在是空数组，但是仍然是 [Int] 类型的。</code></pre><ul><li>创建一个带有默认值的数组</li></ul><p>swift中可以创建特定大小并且所有数据都被默认构造的方法。如下：</p><pre><code>var threeDoubles = Array(repeating: 0.0, count: 3)// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]</code></pre><ul><li>两个数组相加创建一个数组</li></ul><p>可以使用+来组合两个已经存在的相同类型数组，</p><pre><code>var anotherThreeDoubles = Array(repeating: 2.5, count: 3)// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]var sixDoubles = threeDoubles + anotherThreeDoubles// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</code></pre><ul><li>使用数组字面量构造数组</li></ul><p>可以使用数组字面量构造数组，这与C语言类似：</p><pre><code>var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]// shoppingList 已经被构造并且拥有两个初始项。//由于swift的类型推断机制 ，可以这样写：var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]</code></pre><ul><li>访问和修改数组</li></ul><p>可以通过数组的方法和属性来访问和修改数组，或者使用下标</p><pre><code>//使用count属性获取数组数据项数量    print(&quot;The shopping list contains \(shoppingList.count) items.&quot;)// 输出“The shopping list contains 2 items.”（这个数组有2个项）</code></pre><p>使用isEmpty属性检查数组是否为空，使用append(_:)方法哎数组后面增加数据项：</p><pre><code>shoppingList.append(&quot;Flour&quot;)// shoppingList 现在有3个数据项</code></pre><p>使用+=  + 属性进行同类型数组的数据增加</p><pre><code>shoppingList += [&quot;Baking Powder&quot;]// shoppingList 现在有四项了shoppingList += [&quot;Chocolate Spread&quot;, &quot;Cheese&quot;, &quot;Butter&quot;]// shoppingList 现在有七项了</code></pre><p>使用下标语法获取数据项，下标从0开始。注意下标不能溢出。</p><p><strong>还可以使用下标改变一系列的值，即使更新前后的数据量不同，也正确</strong></p><pre><code>shoppingList[4...6] = [&quot;Bananas&quot;, &quot;Apples&quot;]// shoppingList 现在有6项//将三个数据替换为两个数据</code></pre><p>使用insert(_:at:)方法在某个<strong>指定索引值之前</strong>添加数据项</p><pre><code>shoppingList.insert(&quot;Maple Syrup&quot;, at: 0)// shoppingList 现在有7项// 现在是这个列表中的第一项是“Maple Syrup”</code></pre><p>使用remover(at:)方法溢出数组中某一项，并且返回被溢出的数据项</p><pre><code>let mapleSyrup = shoppingList.remove(at: 0)// 索引值为0的数据项被移除</code></pre><p><strong>值得注意的是，数据被溢出后，空出项会被自动填补。</strong></p><p>如果通过是需要每个数据项的值和索引值，使用enumerated()方法遍历数组，enumerated()返回一个由索引值和数据值组成的元组数组。索引下标从0开始：</p><pre><code>for (index, value) in shoppingList.enumerated() {    print(&quot;Item \(String(index + 1)): \(value)&quot;)}// Item 1: Six eggs// Item 2: Milk// Item 3: Flour// Item 4: Baking Powder// Item 5: Bananas</code></pre><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合用来存储相同类型并且没有确定顺序的值，**当集合元素顺序不重要时或者希望确保每个元素只出现依次时可以使用集合。</p><ul><li>集合类型的hash值</li></ul><p>一个类型为了存储在集合中，该类型必须是可hash化的，即该类型必须提供一个方法来计算它的哈希值，哈希值类型是Int，相等的对象hash值必须相同，比如a==b，因此必须使用a.hashvalue==b.hashvalue. swift中所有基本类型都是可hash化的。可以作为集合值得类型或者字典键的类型。没有关联值得枚举成员值默认也是可hash化的。</p><ul><li>集合类型语法</li></ul><p>集合类型被写为Set&lt; Element&gt;，这里Element表示集合中允许存储的类型。</p><ul><li>创建一个空的集合</li></ul><p>可以通过构造器创建一个特定类型的空集合</p><pre><code>var letters = Set&lt;Character&gt;()print(&quot;letters is of type Set&lt;Character&gt; with \(letters.count) items.&quot;)// 打印“letters is of type Set&lt;Character&gt; with 0 items.”</code></pre><p>可以通过上下文提供的类型信息，将一个集合设置为空的集合。</p><pre><code>letters.insert(&quot;a&quot;)// letters 现在含有1个 Character 类型的值letters = []// letters 现在是一个空的 Set，但是它依然是 Set&lt;Character&gt; 类型</code></pre><ul><li>使用数组字面量创建集合</li></ul><p>使用数组字面量来构造集合，与c语言类似</p><pre><code>var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]// favoriteGenres 被构造成含有三个初始值的集合</code></pre><p>由于swift的推断功能，可以无须写出集合类型，根据成员推断出</p><pre><code>var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]</code></pre><ul><li>访问和修改集合</li></ul><p>可以通过集合的属性和方法进行访问和修改</p><p>使用count属性获取集合元素数量。</p><p>使用isEmpty属性检查集合是否为空</p><p>使用insert(_:)插入一个新元素。</p><pre><code>favoriteGenres.insert(&quot;Jazz&quot;)// favoriteGenres 现在包含4个元素</code></pre><p>使用remove属性删除一个元素，如果是该元素存在则返回删除的元素，否则返回nil。可以通过removeAll()方法删除所有元素。</p><pre><code>let removedGenre = favoriteGenres.remove(&quot;Rock&quot;)</code></pre><p>使用contains(_:)方法检察一个集合中是否包含特定的值。返回一个bool值。</p><p>可以在for-in循环中遍历一个集合所有成员：</p><pre><code>for genre in favoriteGenres {    print(&quot;\(genre)&quot;)}</code></pre><p><strong>notice：</strong>swift中Set类型没有确定顺序，为了保证返回一个有序数组，可以使用sorted()方法遍历集合，将元素按字典序排列后遍历。</p><pre><code>for genre in favoriteGenres.sorted() {    print(&quot;\(genre)&quot;)}// Classical// Hip hop// Jazz</code></pre><ul><li>集合操作</li></ul><p>可以使用集合的特性完成一些操作。比如判断两个集合是否全包含，部分包含或者不相交。</p><p>下图描述了集合a和b，以及通过阴影部分显示集合各种操作的结果。</p><p><img src="/2020/01/17/swift语法基础-三/set.png" alt="set"></p><p>如上图：</p><p>使用inertsection(_:)方法根据两个集合的交集创建一个新的集合。</p><p>使用 symmetricDifference(_:) 方法根据两个集合不相交的值创建一个新的集合。</p><p>使用union(_:)方法根据两个集合的所有值创建一个新的集合。</p><p>使用subtracting(_:)方法根据不再一个集合中的值创建一个新的集合。</p><pre><code>let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sorted()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.intersection(evenDigits).sorted()// []oddDigits.subtracting(singleDigitPrimeNumbers).sorted()// [1, 9]oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()// [1, 2, 9]</code></pre><ul><li>集合成员关系和相等</li></ul><p>下图描述了三个集合a,b,c以及通过重叠区域表述集合间共享的元素，a是b的父集合，b是a的子集合。b和c是不相交集合。</p><p><img src="/2020/01/17/swift语法基础-三/set2.png" alt="set2"></p><p>如上图：<br>使用 == 判断两个集合<strong>包含的值</strong>是否相同</p><p>使用isSubset(of:)方法判断一个集合中的所有值是否也被包含在另外一个集合中。</p><p>使用isSuperset(of:)方法判断一个集合是否包含另外一个集合所有值。</p><p>使用isStrictSubset(of:)或者isStrictSuperset(of:)方法判断一个集合是否是另外一个集合子集合或者父集合并且两个集合并不相等。</p><pre><code>let houseAnimals: Set = [&quot;🐶&quot;, &quot;🐱&quot;]let farmAnimals: Set = [&quot;🐮&quot;, &quot;🐔&quot;, &quot;🐑&quot;, &quot;🐶&quot;, &quot;🐱&quot;]let cityAnimals: Set = [&quot;🐦&quot;, &quot;🐭&quot;]houseAnimals.isSubset(of: farmAnimals)// truefarmAnimals.isSuperset(of: houseAnimals)// truefarmAnimals.isDisjoint(with: cityAnimals)// true</code></pre><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典是一种无序的集合，存储的是键值对间的关系，所有键和值的类型需要相同。一个key对应一个value。</p><ul><li>字典简单语法</li></ul><p>使用Dictionary&lt;key,value&gt;定义。也可以使用 [key:value]这样的简化定义。</p><ul><li>创建一个空字典</li></ul><p>使用类似数组的方式创建一个空字典</p><pre><code>var namesOfIntegers = [Int: String]()// namesOfIntegers 是一个空的 [Int: String] 字典</code></pre><p>如果上下文已经提供了类型信息，可以使用字面量来创建一个空字典，记作[:]</p><pre><code>namesOfIntegers[16] = &quot;sixteen&quot;// namesOfIntegers 现在包含一个键值对namesOfIntegers = [:]// namesOfIntegers 又成为了一个 [Int: String] 类型的空字典</code></pre><ul><li>使用字典字面量创建字典</li></ul><p>这个方法与之前创建数组类似：</p><pre><code>var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]//简化版var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]</code></pre><ul><li>访问和修改字典</li></ul><p>使用只读的count属性获取字典的数据项数量</p><p>使用isEmpty属性检查字典是否为空</p><p>使用下标语法给字典增加新的数据项。</p><pre><code>airports[&quot;LHR&quot;] = &quot;London&quot;// airports 字典现在有三个数据项</code></pre><p>使用updataeValue(_:forkey:)方法可以更新特定键值对的值。<strong>这个方法会返回更新前的value值</strong>，</p><pre><code>if let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUB&quot;) {    print(&quot;The old value for DUB was \(oldValue).&quot;)}// 输出“The old value for DUB was Dublin.”</code></pre><p>使用removeValue(forkey:)方法在字典中移除键值对。这个方法在键值对存在时会返回被移除的值或者不存在时返回nil。</p><ul><li>字典遍历</li></ul><p>使用for-in遍历某个字典，每个数据项都已键值对形式返回，可以使用临时常量或者变量分解这些元组。</p><pre><code>for (airportCode, airportName) in airports {    print(&quot;\(airportCode): \(airportName)&quot;)}// YYZ: Toronto Pearson// LHR: London Heathrow//访问key属性for airportCode in airports.keys {    print(&quot;Airport code: \(airportCode)&quot;)}// Airport code: YYZ// Airport code: LHR//访问value属性for airportName in airports.values {    print(&quot;Airport name: \(airportName)&quot;)}// Airport name: Toronto Pearson// Airport name: London Heathrow</code></pre><p>如果需要字典的键集合或者值集合。可以使用如下方法构建一个新数组：</p><pre><code>let airportCodes = [String](airports.keys)// airportCodes 是 [&quot;YYZ&quot;, &quot;LHR&quot;]let airportNames = [String](airports.values)// airportNames 是 [&quot;Toronto Pearson&quot;, &quot;London Heathrow&quot;]</code></pre><p>需要有序遍历字典，可以使用sorted()方法。</p><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>swift提供了多种控制流结构，包括while， if，guard，switch，break，countinue，for-in。</p><h4 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h4><p>使用for-in遍历集合中所有元素，或者某个范围内元素</p><pre><code>let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]for name in names {    print(&quot;Hello, \(name)!&quot;)}// Hello, Anna!// Hello, Alex!// Hello, Brian!// Hello, Jack!</code></pre><p>可以限定范围：</p><pre><code>for index in 1...5 {        print(&quot;\(index) times 5 is \(index * 5)&quot;)}// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25</code></pre><p>如果不需要区间内的每一项，可以使用_忽略：</p><pre><code>let base = 3let power = 10var answer = 1for _ in 1...power {    answer *= base}print(&quot;\(base) to the power of \(power) is \(answer)&quot;)// 输出“3 to the power of 10 is 59049”</code></pre><p>使用stride(from:through:by),可以遍历某一个间隔</p><pre><code>let hours = 12let hourInterval = 3for tickMark in stride(from: 3, through: hours, by: hourInterval) {    // 每3小时渲染一个刻度线（3, 6, 9, 12）}</code></pre><h4 id="while循环和-Repeat-While"><a href="#while循环和-Repeat-While" class="headerlink" title="while循环和 Repeat-While"></a>while循环和 Repeat-While</h4><p>while循环，每次在循环开始时计算条件是否满足。</p><p>repeat-while循环，每次在循环结束时计算条件是否满足。</p><h4 id="if语句和switch语句"><a href="#if语句和switch语句" class="headerlink" title="if语句和switch语句"></a>if语句和switch语句</h4><p>swift中的if使用和c语言中一致。</p><p>switch尝试把某个值与若干个case匹配i，匹配成功时执行相应代码。执行完相对应的case语句后不需要break可以自行跳出。</p><p><strong>notice：</strong>每个case语句必须包含至少一条语句。</p><p>swift中的case分支可以是一个值区间：</p><pre><code>let approximateCount = 62let countedThings = &quot;moons orbiting Saturn&quot;let naturalCount: Stringswitch approximateCount {case 0:    naturalCount = &quot;no&quot;case 1..&lt;5:    naturalCount = &quot;a few&quot;case 5..&lt;12:    naturalCount = &quot;several&quot;case 12..&lt;100:    naturalCount = &quot;dozens of&quot;case 100..&lt;1000:    naturalCount = &quot;hundreds of&quot;default:    naturalCount = &quot;many&quot;}print(&quot;There are \(naturalCount) \(countedThings).&quot;)// 输出“There are dozens of moons orbiting Saturn.”</code></pre><p>可以使用元组在同一个switch语句中测试多个值：</p><pre><code>let somePoint = (1, 1)switch somePoint {case (0, 0):    print(&quot;\(somePoint) is at the origin&quot;)case (_, 0):    print(&quot;\(somePoint) is on the x-axis&quot;)case (0, _):    print(&quot;\(somePoint) is on the y-axis&quot;)case (-2...2, -2...2):    print(&quot;\(somePoint) is inside the box&quot;)default:    print(&quot;\(somePoint) is outside of the box&quot;)}// 输出“(1, 1) is inside the box”</code></pre><ul><li>值绑定</li></ul><p>case分支允许将匹配的值声明为临时变量或者常量，并且允许在case分支内使用。这成为值绑定。</p><pre><code>let anotherPoint = (2, 0)switch anotherPoint {case (let x, 0):    print(&quot;on the x-axis with an x value of \(x)&quot;)case (0, let y):    print(&quot;on the y-axis with a y value of \(y)&quot;)case let (x, y):    print(&quot;somewhere else at (\(x), \(y))&quot;)}//此处最后一个case可以匹配所有剩余情况    // 输出“on the x-axis with an x value of 2”</code></pre><ul><li>where</li></ul><p>case分支可以使用<strong>where</strong>关键字来判断额外条件</p><pre><code>let yetAnotherPoint = (1, -1)switch yetAnotherPoint {case let (x, y) where x == y:    print(&quot;(\(x), \(y)) is on the line x == y&quot;)case let (x, y) where x == -y:    print(&quot;(\(x), \(y)) is on the line x == -y&quot;)case let (x, y):    print(&quot;(\(x), \(y)) is just some arbitrary point&quot;)}// 输出“(1, -1) is on the line x == -y”</code></pre><ul><li>复合型case</li></ul><p>当多个条件可以使用同一种方法来处理时，可以将几种可能放在一个case后面，用逗号隔开。</p><pre><code>let someCharacter: Character = &quot;e&quot;switch someCharacter {case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;:    print(&quot;\(someCharacter) is a vowel&quot;)case &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;,     &quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;:    print(&quot;\(someCharacter) is a consonant&quot;)default:    print(&quot;\(someCharacter) is not a vowel or a consonant&quot;)}// 输出“e is a vowel”</code></pre><h4 id="控制转移语句"><a href="#控制转移语句" class="headerlink" title="控制转移语句"></a>控制转移语句</h4><ul><li>continue</li></ul><p>告诉循环体立刻停止本次循环，开始下一次循环。</p><ul><li>break</li></ul><p>立刻结束整个控制流的执行。</p><ul><li><p>Fallthrough<br>fallthrough 简单地使代码继续连接到下一个 case 中的代码，这和 C 语言标准中的 switch 语句特性是一样的。</p><p>  let integerToDescribe = 5<br>  var description = “The number (integerToDescribe) is”<br>  switch integerToDescribe {<br>  case 2, 3, 5, 7, 11, 13, 17, 19:</p><pre><code>description += &quot; a prime number, and also&quot;fallthrough</code></pre><p>  default:</p><pre><code>description += &quot; an integer.&quot;</code></pre><p>  }<br>  print(description)<br>  // 输出“The number 5 is a prime number, and also an integer.”</p></li><li><p>带标签的语句和guard</p></li></ul><p>参考此处：</p><p><a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/05_control_flow" target="_blank" rel="noopener">https://swiftgg.gitbook.io/swift/swift-jiao-cheng/05_control_flow</a></p><ul><li>检测API可用性</li></ul><p>swift内置支持API可用性，可以确保我们不会在当前部署机器上使用不可用API。</p><pre><code>if #available(iOS 10, macOS 10.12, *) {// 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API} else {    // 使用先前版本的 iOS 和 macOS 的 API}</code></pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;集合类型&quot;&gt;&lt;a href=&quot;#集合类型&quot; class=&quot;headerlink&quot; title=&quot;集合类型&quot;&gt;&lt;/a&gt;集合类型&lt;/h3&gt;&lt;p&gt;swift使用数组，集合，字典三种基本的集合类型用来存储集合数据，数组是有序数据的集，集合是无序数据的集，字典是无序的键值对的集。&lt;/p&gt;
&lt;p&gt;swift中的数组，集合和字典必须明确其中保存的键和值类型，这样可以防止插入数据类型不一致。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集合的可变性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果创建一个数组，集合或者字典并且把它分配成一个变量，那么这个集合将会是可变的。可以进行增删数据。如果是常量则它的大小和内容都不可变。&lt;/p&gt;</summary>
    
    
    
    <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
    <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift语法基础(二)</title>
    <link href="http://yoursite.com/2020/01/15/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/01/15/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%BA%8C/</id>
    <published>2020-01-15T05:17:45.000Z</published>
    <updated>2020-01-17T04:20:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h3><p>swift中包含了C中所有的基础数据类型，Int，Double，Float，Bool，String。还提供了三种基本的集合类型，Array，Set，Dictionary。参考集合类型部分。</p><p>在swift中广泛使用值不可变的变量即常量，在swift中，如果你要处理的值不需要改变，那使用常量可使代码更加安全。</p><p>swift中还增加了高阶数据类型比如元组（Tuple），元组可以创建或者传递一组数据。作为一组返回值时，可以使用一个元组返回多个值。swift增加了可选类型，可选表示 “那儿有一个值，并且它等于 x ” 或者 “那儿没有值” 。</p><p>swift时一门类型安全的语言，这意味着swift可以让你清楚地知道值得类型。</p><a id="more"></a> <h4 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h4><p>常量和变量必须在使用前声明，使用var声明变量，使用let声明常量。</p><pre><code>let maximumNumberOfLoginAttempts = 10var currentLoginAttempt = 0</code></pre><p>可以在一行中声明多个常量或者变量，使用逗号隔开</p><pre><code>var x = 0.0, y = 0.0, z = 0.0</code></pre><h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><p>当声明得常量或者变量时可以加上<em>类型注解</em>，说明要存储得值的类型。格式为：</p><pre><code>var welcomeMessage: StringwelcomeMessage = &quot;Hello&quot;</code></pre><p>可以在一行中定义多个同样类型的变量，使用逗号分隔，在最后一个变量名之后添加类型注解：</p><pre><code>var red, green, blue: Double//一般来说很少使用类型注解，在声明常量或者变量的时候赋给了初值，编译器可以推断出类型。</code></pre><p>常量和变量名不能包含数学符号，箭头，保留的Unicode码位，连线与制表符.也不能以数字开头。</p><h4 id="输出常量和变量"><a href="#输出常量和变量" class="headerlink" title="输出常量和变量"></a>输出常量和变量</h4><p>使用print(_:separator:terminator:) 函数来输出当前常量或变量的值:print是一个用来输出一个或者多个值到适当输出区的全局函数，输出内容到console上，默认情况下，该函数通过添加换行符来结束当前行，如果不想换行，可以传递空字符串给terminator，比如：print(someValue, terminator:””)。</p><p>也可以使用 \ ()的方式将字符串进行转义。</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>swift中的注释和c语言中注释相似， 使用双斜杠。多行注释也相同。</p><p>swift并不要求在每条语句结尾处使用分号，也可以添加分号。</p><h4 id="整数，整数范围"><a href="#整数，整数范围" class="headerlink" title="整数，整数范围"></a>整数，整数范围</h4><p>可以使用不同整数类型的min和max属性来获取对应类型的最小值和最大值</p><pre><code>let minValue = UInt8.min  // minValue 为 0，是 UInt8 类型let maxValue = UInt8.max  // maxValue 为 255，是 UInt8 类型</code></pre><p>Int：在32位平台上与Int32长度相同，在64位平台上与Int64相同</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数类型比整数类型表示范围更大，Double表示64位浮点数，Float表示32位浮点数。</p><h4 id="类型安全和类型推断"><a href="#类型安全和类型推断" class="headerlink" title="类型安全和类型推断"></a>类型安全和类型推断</h4><p>Swift 是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个 String，你绝对不可能不小心传进去一个 Int。因此会在编译时进行类型检查。</p><p>如果表达式中同时出现了整数和浮点数，会被推断为Double类型：</p><pre><code>let anotherPi = 3 + 0.14159// anotherPi 会被推测为 Double 类型</code></pre><h4 id="数值型字面量"><a href="#数值型字面量" class="headerlink" title="数值型字面量"></a>数值型字面量</h4><ul><li><p>一个十进制数，没有前缀</p></li><li><p>一个二进制数，前缀0b</p></li><li><p>一个八进制数，前缀0o</p></li><li><p>一个十六进制数，前缀0x</p><p>  let decimalInteger = 17<br>  let binaryInteger = 0b10001       // 二进制的17<br>  let octalInteger = 0o21           // 八进制的17<br>  let hexadecimalInteger = 0x11     // 十六进制的17</p></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>不同类型的变量和常量如果超过范围编译器会报错</p><pre><code>let cannotBeNegative: UInt8 = -1// UInt8 类型不能存储负数，所以会报错let tooBig: Int8 = Int8.max + 1// Int8 类型不能存储超过最大值的数，所以会报错</code></pre><p>要将一种数字类型转换为另一种。要用当前值来初始化一个期望类型的新数字。如下：</p><pre><code>let twoThousand: UInt16 = 2_000let one: UInt8 = 1//UInt8和UInt16不能直接计算，需要转换let twoThousandAndOne = twoThousand + UInt16(one)</code></pre><p>SomeType(ofInitialValue)调用swift构造器并传入一个一个初值的默认方法。</p><ul><li><p>整数和浮点数转换<br>整数和浮点数的转换必须显式指定类型：</p><pre><code>let three = 3let pointOneFourOneFiveNine = 0.14159let pi = Double(three) + pointOneFourOneFiveNine// pi 等于 3.14159，所以被推测为 Double 类型，如果不进行转化无法相加</code></pre></li><li><p>浮点数到整数<br>浮点数到整数的转换会阶段小数部分。 </p><pre><code>let pi=3.14159let integerPi = Int(pi)    // integerPi 等于 3，所以被推测为 Int 类型</code></pre></li></ul><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名(type aliases)就是给现有类型定义另一个名字，使用关键字<strong>typealias</strong>：</p><pre><code>typealias AudioSample = UInt16var maxAmplitudeFound = AudioSample.min// maxAmplitudeFound 现在是 0</code></pre><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>Bool值包括true和false。在if判断和控制流作为条件。需要注意的是，当编写条件语句时，如果使用非Bool值则会报错</p><pre><code>let i = 1if i { //i不是布尔值// 这个例子不会通过编译，会报错}let i = 1if i == 1 {  //i==1是布尔值// 这个例子会编译成功}    </code></pre><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组是把多个值组成一个复合值。元组内的值可以是任意类型，<strong>并不要求是相同类型</strong>，如下http状态码：</p><pre><code>let http404Error = (404, &quot;Not Found&quot;)// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)</code></pre><p>元组可以是两个或两个以上类型的组合，比如(Int,Int,Double)。<br>可以将一个元组的内容分解为单独的常量或者变量，就可以正常使用了。</p><pre><code>let (statusCode, statusMessage) = http404Errorprint(&quot;The status code is \(statusCode)&quot;)// 输出“The status code is 404”print(&quot;The status message is \(statusMessage)&quot;)// 输出“The status message is Not Found”</code></pre><p>如果只需要其中一部分元组，分解的时候可以把忽略的部分用下划线(_)标记：</p><pre><code>let (justTheStatusCode, _) = http404Errorprint(&quot;The status code is \(justTheStatusCode)&quot;)// 输出“The status code is 404”</code></pre><p>也可以通过下标访问元组中的某个元素，下标从0开始：</p><pre><code>print(&quot;The status code is \(http404Error.0)&quot;)// 输出“The status code is 404”print(&quot;The status message is \(http404Error.1)&quot;)// 输出“The status message is Not Found”</code></pre><p>给元组中的元素命名后，可以通过名字获取元素的值：</p><pre><code>let http200Status = (statusCode: 200, description: &quot;OK&quot;)//元组命名print(&quot;The status code is \(http200Status.statusCode)&quot;)// 输出“The status code is 200”print(&quot;The status message is \(http200Status.description)&quot;)// 输出“The status message is OK”</code></pre><h4 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h4><p>使用可选类型来处理值可能缺失的情况，可选类型表示两种可能，可以解析可选类型访问这个值， 或者根本没有值。</p><pre><code>let possibleNumber = &quot;123&quot;let convertedNumber = Int(possibleNumber)// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;</code></pre><p>上述String转Int可能失败，因此返回一个可选类型(optional)Int。也即?Int</p><pre><code>var serverResponseCode: Int? = 404// serverResponseCode 包含一个可选的 Int 值 404serverResponseCode = nil// serverResponseCode 现在不包含值    //nil不能用于非可选的常量和变量，如果代码中由常量或者变量需要处理值缺失的情况，声明为可选类型。var surveyAnswer: String?// surveyAnswer 被自动设置为 nil</code></pre><h4 id="if语句以及强制解析"><a href="#if语句以及强制解析" class="headerlink" title="if语句以及强制解析"></a>if语句以及强制解析</h4><p>可以使用if语句和nil比较来判断一个可选值是否包含值，使用==或者!=来判断。 如果可选类型有值，不等于nil：</p><pre><code>if convertedNumber != nil {print(&quot;convertedNumber contains some integer value.&quot;)}// 输出“convertedNumber contains some integer value.”</code></pre><p>-可选绑定<br>使用可选绑定来判断可选类型是否包含值，如果包含就赋值给一个临时常量，如下： </p><pre><code>if let actualNumber = Int(possibleNumber) {print(&quot;\&apos;\(possibleNumber)\&apos; has an integer value of \(actualNumber)&quot;)} else {print(&quot;\&apos;\(possibleNumber)\&apos; could not be converted to an integer&quot;)}// 输出“&apos;123&apos; has an integer value of 123”</code></pre><p><strong>notice：</strong>在if条件句中使用常量或者变量创建一个可选绑定，仅在if条件句的body中有效。</p><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><p>运算符是检查，改变，合并值得特殊符号或者短语。swift支持大部分标准C的运算符，且为了减少常见编码错误进行了部分改进，如：赋值符不再由返回值。算术运算符的结果会被检测并禁止值溢出，以此来避免变量大于或者小于所能表示范围导致的异常。</p><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><pre><code>let b = 10var a = 5a = b// a 现在等于 10</code></pre><p>如果赋值的右边是一个多元组，它的元素可以马上分解成多个常量或者变量：</p><pre><code>let (x, y) = (1, 2)// 现在 x 等于 1，y 等于 2</code></pre><p><strong>notice：</strong>swift赋值操作不返回任何值，因此</p><pre><code>if x = y {// 此句错误，因为 x = y 并不返回任何值}    </code></pre><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>算术运算符除了基本数据类型的运算外，也可用于String的拼接：</p><pre><code>&quot;hello, &quot; + &quot;world&quot;  // 等于 &quot;hello, world&quot;</code></pre><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>所有标准C中的比较运算符都可以在swift中使用。比较运算符多用于if条件语句。</p><p>如果两个元组的元素相同且长度相同，就可以进行比较，比较元组大小会按照从左到右，逐值比较的方式，直到两个值不等停止。</p><pre><code>//元组比较(1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;)   // true，因为 1 小于 2(3, &quot;apple&quot;) &lt; (3, &quot;bird&quot;)    // true，因为 3 等于 3，但是 apple 小于 bird(4, &quot;dog&quot;) == (4, &quot;dog&quot;)      // true，因为 4 等于 4，dog 等于 dog</code></pre><p><strong>notice：</strong>如果元组中包含有Bool类型时不可以进行比较，</p><pre><code>(&quot;blue&quot;, -1) &lt; (&quot;purple&quot;, 1)       // 正常，比较的结果为 true(&quot;blue&quot;, false) &lt; (&quot;purple&quot;, true) // 错误，因为 &lt; 不能比较布尔类型</code></pre><h4 id="空合运算符-Nil-Coalescing-Operator"><a href="#空合运算符-Nil-Coalescing-Operator" class="headerlink" title="空合运算符(Nil Coalescing Operator)"></a>空合运算符(Nil Coalescing Operator)</h4><p>空合运算符(a??b)将对可选类型a进行空判断，如果a包含一个值就进行解包，否则返回一个默认值b。表达式a必须时Optional类型，默认值b要合a存储值类型一致。</p><pre><code>let defaultColorName = &quot;red&quot;var userDefinedColorName: String?   //默认值为 nilvar colorNameToUse = userDefinedColorName ?? defaultColorName// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 &quot;red&quot;</code></pre><h4 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h4><p>swift提供了几种方便表达一个区间的区间运算符</p><ul><li><p>闭区间  (a…b)  定义一个从a到b的闭区间 </p></li><li><p>半开区间 (a..&lt;b) 定义一个从a到b但不包括b的区间，</p></li><li><p>单侧区间 闭区间右另一个表达形式，可以表达往一侧无线延申的区间，</p><pre><code>let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]for name in names[2...] {    print(name)}// Brian// Jackfor name in names[...2] {    print(name)}// Anna// Alex// Brian</code></pre><p>半开区间也有单侧表达形式：</p><pre><code>for name in names[..&lt;2] {    print(name)}// Anna// Alex</code></pre></li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符与c语言中相同，且&amp;&amp; 和|| 都是左结合的运算符，意味着多元逻辑操作从左开始计算，也可以使用括号标明优先级。</p><h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><p>字符串是一系列字符的集合，swift中使用String类型来表示，String中内容的访问可以使用Character值的集合。</p><p>swift中的String和Character类型提供了一种快速且兼容Unicode的方式来处理代码中的文本。</p><h4 id="多行字符串字面量"><a href="#多行字符串字面量" class="headerlink" title="多行字符串字面量"></a>多行字符串字面量</h4><p>如果需要一个字符串是跨越多行的，使用三个双引号包裹的文本字符集：</p><pre><code>let quotation = &quot;&quot;&quot;The White Rabbit put on his spectacles.  &quot;Where shall I begin,please your Majesty?&quot; he asked.&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go ontill you come to the end; then stop.&quot;&quot;&quot;&quot;</code></pre><p>多行字符串在”””包围中。</p><h4 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h4><p>要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个String实例</p><pre><code>var emptyString = &quot;&quot;               // 空字符串字面量var anotherEmptyString = String()  // 初始化方法// 两个字符串均为空并等价。</code></pre><p>通过Bool类型的isEmpty判断字符串是否为空</p><pre><code>if emptyString.isEmpty {    print(&quot;Nothing to see here&quot;)}// 打印输出：“Nothing to see here”</code></pre><h4 id="字符串可变性"><a href="#字符串可变性" class="headerlink" title="字符串可变性"></a>字符串可变性</h4><p>可以通过将一个特定字符串分配给变量对其进行修改，也可以分配一个常量来保证字符串不被修改。</p><h4 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h4><p><strong>在swift中，如果创建一个新的字符串，那么当其进行常量，变量赋值或者在函数中传递时，会进行值拷贝，都会对已有字符串创建新副本，并对该新副本而非原始字符串进行传递或者赋值操作。</strong></p><p>下面例子中使用for-in循环打印字符串中每个字符</p><pre><code>for character in &quot;Dog!🐶&quot; {    print(character)}// D// o// g// !// 🐶</code></pre><p>另外，通过标明一个Character类型并用字符字面量自行赋值，可以建立一个独立的字符常量或者变量。</p><pre><code>let exclamationMark: Character = &quot;!&quot;//创建一个字符</code></pre><p>字符串可以通过传递一个Character类型的数组作为自变量来初始化：</p><pre><code>let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;🐱&quot;]let catString = String(catCharacters)print(catString)// 打印输出：“Cat!🐱”</code></pre><p>字符串可以进行连接，这与c语言相同。使用+ ，+=， append进行字符串连接。</p><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>Unicode是一个用于在不同书写系统中对文本进行编码、表示和处理的国际标准。它使你可以用标准格式表示来自任意语言几乎所有的字符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。Swift 的 String 和 Character 类型是完全兼容 Unicode 标准的。</p><h4 id="计算字符数量"><a href="#计算字符数量" class="headerlink" title="计算字符数量"></a>计算字符数量</h4><p>使用count属性获取字符串中Character的个数。可以通过下标来访问和修改字符串。</p><ul><li>字符串索引 每一个String值都有一个关联的索引类型，String.Index,它对应字符串每个character的位置。<strong>不同的字符可能占用不同数量的内存空间，因此不可以使用integer来索引。</strong></li></ul><p><strong>使用startIndex获取String的第一个character的索引，使用endIndex获取最后一个character的下一位置索引。(和C++迭代器类似)。</strong>如果String是空串，straightIndex和endIndex是相等的。</p><p>使用index(before:) 或者index(after:)方法，可以立即得到前面一个或者后面一个索引。 可以调用index(someString:offsetBy:)方法获取对应偏移量的索引。</p><pre><code>let greeting = &quot;Guten Tag!&quot;greeting[greeting.startIndex]// Ggreeting[greeting.index(before: greeting.endIndex)]// !greeting[greeting.index(after: greeting.startIndex)]// ulet index = greeting.index(greeting.startIndex, offsetBy: 7) //获取偏移下标greeting[index]// a</code></pre><p>获取越界的索引时会报错。</p><ul><li><p>使用indices属性创建一个包含全部索引的范围，用来访问字符串中的单个字符。</p><pre><code>for index in greeting.indices {       print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)}// 打印输出“G u t e n   T a g ! ”</code></pre></li><li><p>插入和删除</p></li></ul><p>调用 insert(_:at:)方法可以在一个字符串的指定索引插入一个<strong>字符</strong>。调用insert(contentsOf:at:)方法可以在一个字符串指定索引插入一个<strong>段字符串</strong></p><pre><code>var welcome = &quot;hello&quot;welcome.insert(&quot;!&quot;, at: welcome.endIndex)// welcome 变量现在等于 &quot;hello!&quot;welcome.insert(contentsOf:&quot; there&quot;, at: welcome.index(before: welcome.endIndex))// welcome 变量现在等于 &quot;hello there!&quot;</code></pre><p>调用remove(at:)可以在一个字符串的指定索引删除一个<strong>字符</strong>。调用removerSubrange(_:)可以在一个字符串的指定索引删除一个<strong>子字符串</strong></p><pre><code>welcome.remove(at: welcome.index(before: welcome.endIndex))// welcome 现在等于 &quot;hello there&quot;let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndexwelcome.removeSubrange(range)// welcome 现在等于 &quot;hello&quot;</code></pre><ul><li>子字符串</li></ul><p>当从字符串中获取一个子串可以使用prefix(_:)方法。就可以得到一个subString实例。 subString中的绝大部分函数和String一样，但是如果需要长时间保存字符串时，使用subString转化为string的方法。</p><pre><code>let greeting = &quot;Hello, world!&quot;let index = greeting.firstIndex(of: &quot;,&quot;) ?? greeting.endIndexlet beginning = greeting[..&lt;index]// beginning 的值为 &quot;Hello&quot;// 把结果转化为 String 以便长期存储。let newString = String(beginning)</code></pre><ul><li>String 和subString的区别<br>subString可以重用原String的内存空间，或者另一个subString的空间。String也有同样优化，但是如果两个String共享内存的话，那么他们相等。</li></ul><p><img src="/2020/01/15/swift语法基础-二/string.png" alt="string"></p><p>如图所示：下方String是重新申请一块内存存放的。而subString和原来String共享一块内存空间。</p><h4 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h4><p>swift提供了三种方式比较文本值，字符串字符相等，前缀相等，后缀相等。</p><ul><li><p>字符/字符串相等<br>可以使用==和!=操作符</p><pre><code> let quotation = &quot;We&apos;re a lot alike, you and I.&quot;let sameQuotation = &quot;We&apos;re a lot alike, you and I.&quot;if quotation == sameQuotation {    print(&quot;These two strings are considered equal&quot;)}// 打印输出“These two strings are considered equal”</code></pre></li><li><p>前缀/后缀相等<br>通过调用hasPrefix(<em>:)，hasSuffix(</em>:)检查字符串是否拥有特定的前缀和后缀。 两个方法接受一个String参数，返回一个bool值。</p></li></ul><h4 id="字符串的unicode表示"><a href="#字符串的unicode表示" class="headerlink" title="字符串的unicode表示"></a>字符串的unicode表示</h4><p>当一个 Unicode 字符串被写进文本文件或者其他储存时，字符串中的 Unicode 标量会用 Unicode 定义的几种 编码格式（encoding forms）编码。每一个字符串中的小块编码都被称 代码单元（code units）。这些包括 UTF-8 编码格式（编码字符串为 8 位的代码单元）， UTF-16 编码格式（编码字符串位 16 位的代码单元），以及 UTF-32 编码格式（编码字符串32位的代码单元）。</p><p>UTF8，UTF16,UTF32表示参考</p><p><a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/03_strings_and_characters" target="_blank" rel="noopener">https://swiftgg.gitbook.io/swift/swift-jiao-cheng/03_strings_and_characters</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;基础部分&quot;&gt;&lt;a href=&quot;#基础部分&quot; class=&quot;headerlink&quot; title=&quot;基础部分&quot;&gt;&lt;/a&gt;基础部分&lt;/h3&gt;&lt;p&gt;swift中包含了C中所有的基础数据类型，Int，Double，Float，Bool，String。还提供了三种基本的集合类型，Array，Set，Dictionary。参考集合类型部分。&lt;/p&gt;
&lt;p&gt;在swift中广泛使用值不可变的变量即常量，在swift中，如果你要处理的值不需要改变，那使用常量可使代码更加安全。&lt;/p&gt;
&lt;p&gt;swift中还增加了高阶数据类型比如元组（Tuple），元组可以创建或者传递一组数据。作为一组返回值时，可以使用一个元组返回多个值。swift增加了可选类型，可选表示 “那儿有一个值，并且它等于 x ” 或者 “那儿没有值” 。&lt;/p&gt;
&lt;p&gt;swift时一门类型安全的语言，这意味着swift可以让你清楚地知道值得类型。&lt;/p&gt;</summary>
    
    
    
    <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
    <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift语法基础(一)</title>
    <link href="http://yoursite.com/2020/01/14/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%B8%80/"/>
    <id>http://yoursite.com/2020/01/14/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%B8%80/</id>
    <published>2020-01-14T05:42:19.000Z</published>
    <updated>2020-01-15T05:15:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>寒假开始了1周了，终于也是咸鱼了一周，在今天开始学点东西，既然之后要做ios开发的话，就打算学点swift。整个周期大概20天，先整体看一遍swift的语法，然后去leetcode刷题。因为是windows系统，所以这其中可能会有一些问题。不过只要有开头的话，后面慢慢来就行了。</p><a id="more"></a> <h3 id="swift初见"><a href="#swift初见" class="headerlink" title="swift初见"></a>swift初见</h3><h4 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h4><p> 1.使用let声明常量，使用var来声明变量，常量和变量定义和c语言中一样，常量只能赋值一次。变量可以多次赋值。<strong>可以不用明确的声明类型，这可以由编译器自动判断其类型。</strong>但是如果在申明时没有提供足够的信息表现出类型，需要如下表现：</p><pre><code>//变量和常量var myVariable = 42myVariable = 50let myConstant = 42//类型let implicitInteger = 70let implicitDouble = 70.0let explicitDouble: Double = 70</code></pre><p>2.一个变量或者常量的值类型时保持不变的，如果需要类型转换，请显示进行。</p><pre><code>let label = &quot;The width is&quot;let width = 94let widthLabel = label + String(width)//widthLabel = &quot;The width is 94&quot;</code></pre><p>上面例子中将 整形转化为String,还有一种更简单的值转化为字符串的方式： 把值写道括号中，在括号前加一个反斜杠。</p><pre><code>let apples = 3let oranges = 5let appleSummary = &quot;I have \(apples) apples.&quot;//  &quot;I have 3 apples&quot;let fruitSummary = &quot;I have \(apples + oranges) pieces of fruit.&quot;//  &quot;I have 8 pieces of fruit&quot;</code></pre><p>使用三分双引号来包含多行字符串内容，<strong>每行行首的缩进会被去除</strong>，知道和结尾双引号相互匹配。</p><pre><code>let quotation = &quot;&quot;&quot;I said &quot;I have \(apples) apples.&quot;And then I said &quot;I have \(apples + oranges) pieces of fruit.&quot;&quot;&quot;&quot;//一段三行的String</code></pre><p>3.和c语言类似，使用[]创建数组和字典，使用下标或者key来访问元素，<strong>最后一个元素后面语序有个逗号。</strong></p><pre><code>var shoppingList = [&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;]shoppingList[1] = &quot;bottle of water&quot;//通过下表访问数组var occupations = [&quot;Malcolm&quot;: &quot;Captain&quot;,&quot;Kaylee&quot;: &quot;Mechanic&quot;,]occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot;//通过key访问数组shoppingList.append(&quot;blue paint&quot;)//使用append添加元素</code></pre><p>下面是数组或者字典的创建</p><pre><code>let emptyArray = [String]() //数组let emptyDictionary = [String: Float]() //字典</code></pre><p>如前所述，如果可以推断出是数组或者字典，也可以如下声明：</p><pre><code>var shoppingList = []var occupations = [:]</code></pre><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><p>使用<strong>if</strong>和<strong>switch</strong>来进行条件操作，使用<strong>for-in</strong>，<strong>while</strong>，<strong>repeat-while</strong>来进行循环，包裹条件和循环变量的括号可以省略，但是条件或者循环体的大括号是必须的。</p><p>1.在if语句中，条件表达式必须为一个布尔式。可选值：可选值是一个具体的值或者说是nil表示值缺失。在类型后面加一个问号标记这个变量的值是可选的。</p><pre><code>var optionalName: String? = &quot;John Appleseed&quot;var greeting = &quot;Hello!&quot;if let name = optionalName {    greeting = &quot;Hello, \(name)&quot;}//如果常量name！=nil，执行if条件</code></pre><p>使用<strong>？？</strong>来提供一个默认值，如果可选值缺失，可以使用默认值来代替</p><pre><code>let nickName: String? = nillet fullName: String = &quot;John Appleseed&quot;let informalGreeting = &quot;Hi \(nickName ?? fullName)&quot;//nickname值缺失，使用fullname informalGreeeting=&quot;HI john appleseed&quot;</code></pre><p>2.运行switch语句时，在switch中匹配到case语句后会直接推出，所以不必加上break，但是default需要特别注意。</p><p>3.使用<strong>for-in</strong>来遍历字典，需要一对变量来表示每个键值对，字典时一个无序的集合，所以他们的键和值以任意顺序迭代结束。</p><pre><code>let interestingNumbers = [&quot;Prime&quot;: [2, 3, 5, 7, 11, 13],&quot;Fibonacci&quot;: [1, 1, 2, 3, 5, 8],&quot;Square&quot;: [1, 4, 9, 16, 25],]var largest = 0for (kind, numbers) in interestingNumbers {//kind 和number表示一个键值对     for number in numbers {//number指向numbers的每一个成员        if number &gt; largest {            largest = number        }    }}print(largest)</code></pre><p>while的使用和c语言中一致，但是作为条件的括号可以省略。</p><p>在循环中使用..&lt;表示下标范围。</p><pre><code>var total = 0for i in 0..&lt;4 {total += i}print(total)</code></pre><p>使用 <strong>..&lt;</strong> 创建的范围不包含上界，如果想包含的话需要使用 <strong>…</strong>。</p><h4 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h4><p>1.使用 func 来声明一个函数，使用名字和参数来调用函数。使用 -&gt; 来指定函数返回值的类型。</p><pre><code>//函数调用func greet(person: String, day: String) -&gt; String {return &quot;Hello \(person), today is \(day).&quot;}greet(person:&quot;Bob&quot;, day: &quot;Tuesday&quot;)</code></pre><p>2.使用元组来生成复合值，让一个函数返回多个值，改元组的元素可以用名称或者数字来获取。<br>   //返回值为复合值<br>    func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) {<br>    var min = scores[0]<br>    var max = scores[0]<br>    var sum = 0</p><pre><code>for score in scores {    if score &gt; max {        max = score    } else if score &lt; min {        min = score    }    sum += score}return (min, max, sum)}    let statistics = calculateStatistics(scores:[5, 3, 100, 3, 9])//两种方式访问sumprint(statistics.sum)print(statistics.2)</code></pre><p>3.函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。</p><pre><code>func returnFifteen() -&gt; Int {var y = 10func add() { //函数没有返回值    y += 5}add()return y}returnFifteen()</code></pre><p>函数实际上是一种特殊的闭包，它是一段能之后被调用的代码，闭包中的代码能访问闭包作用于中的变量和函数。即使闭包是在一个不同的作用域被执行的，可以使用{}来创建一个匿名闭包，使用in将参数和返回值类型的声明与闭包函数体进行分离。</p><h4 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h4><p>1.使用class和类名创建一个类，类中属性和的声明和常量变量的声明一样。唯一的区别是他们的上下文是类。</p><pre><code>//创建一个类class Shape {var numberOfSides = 0func simpleDescription() -&gt; String {    return &quot;A shape with \(numberOfSides) sides.&quot;}}</code></pre><p>创建一个类的实例，在类名后面加上括号。使用如下方法访问实例的属性和方法。</p><pre><code>var shape = Shape()shape.numberOfSides = 7var shapeDescription = shape.simpleDescription()</code></pre><p>2.在类中加入构造函数，使用init来创建一个构造器。</p><pre><code>class NamedShape {    var numberOfSides: Int = 0    var name: String    init(name: String) {        self.name = name    }    func simpleDescription() -&gt; String {        return &quot;A shape with \(numberOfSides) sides.&quot;    }}</code></pre><p>注意self用来区别实例变量name和构造器参数name，当创建实例的时候，像传入参数一样给类传入构造器的参数，每个属性都需要赋值。</p><p>3.使用deinit来创建一个析构函数。</p><p>4.子类的定义方法是在其类名后面加上父类的名字，使用冒号分隔。子类如果要重写父类的方法的话，需要使用override标记，编译器会检测override标记的方法是否确实在父类中。</p><pre><code>class Square: NamedShape {var sideLength: Doubleinit(sideLength: Double, name: String) {    self.sideLength = sideLength    super.init(name: name)    numberOfSides = 4}func area() -&gt;  Double {    return sideLength * sideLength}//重写父类方法override func simpleDescription() -&gt; String {    return &quot;A square with sides of length \(sideLength).&quot;}}let test = Square(sideLength: 5.2, name: &quot;my test square&quot;)test.area()test.simpleDescription()</code></pre><h4 id="枚举和结构体"><a href="#枚举和结构体" class="headerlink" title="枚举和结构体"></a>枚举和结构体</h4><p>使用enum来创建一个枚举，枚举可以包含方法。</p><pre><code>enum Rank: Int {case ace = 1case two, three, four, five, six, seven, eight, nine, tencase jack, queen, kingfunc simpleDescription() -&gt; String {    switch self {    case .ace:        return &quot;ace&quot;    case .jack:        return &quot;jack&quot;    case .queen:        return &quot;queen&quot;    case .king:        return &quot;king&quot;    default:        return String(self.rawValue)    }}}let ace = Rank.acelet aceRawValue = ace.rawValue</code></pre><p>上面例子中，使用rawValue属性来访问下一个枚举成员的值。</p><p>使用struct创建一个结构体。结构体和类由很多先攻的地方，包括方法和构造器，他们最大的区别是结构体是传值，类是传引用。</p><pre><code>struct Card {var rank: Rankvar suit: Suitfunc simpleDescription() -&gt; String {    return &quot;The \(rank.simpleDescription()) of \(suit.simpleDescription())&quot;}}//值传递let threeOfSpades = Card(rank: .three, suit: .spades)let threeOfSpadesDescription = threeOfSpades.simpleDescription()</code></pre><h4 id="协议和扩展"><a href="#协议和扩展" class="headerlink" title="协议和扩展"></a>协议和扩展</h4><p>使用protocol来声明一个协议</p><pre><code>protocol ExampleProtocol {    var simpleDescription: String { get }    mutating func adjust()}</code></pre><p>类，枚举和结构体都可以遵循协议。</p><pre><code>   //类继承协议class SimpleClass: ExampleProtocol {var simpleDescription: String = &quot;A very simple class.&quot;var anotherProperty: Int = 69105func adjust() {    simpleDescription += &quot;  Now 100% adjusted.&quot;}}var a = SimpleClass()a.adjust()let aDescription = a.simpleDescription//结构继承协议struct SimpleStructure: ExampleProtocol {var simpleDescription: String = &quot;A simple structure&quot;mutating func adjust() {    simpleDescription += &quot; (adjusted)&quot;}}var b = SimpleStructure()b.adjust()let bDescription = b.simpleDescription</code></pre><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>在尖括号中写一个名字来创建一个泛型函数或者类型</p><pre><code>func makeArray&lt;Item&gt;(repeating item: Item, numberOfTimes: Int) -&gt; [Item] {var result = [Item]()for _ in 0..&lt;numberOfTimes {    result.append(item)}return result}makeArray(repeating: &quot;knock&quot;, numberOfTimes: 4)</code></pre><p>也可以创建泛型函数，方法，类，枚举和结构体。</p><pre><code>// 重新实现 Swift 标准库中的可选类型enum OptionalValue&lt;Wrapped&gt; {case nonecase some(Wrapped)}var possibleInteger: OptionalValue&lt;Int&gt; = .nonepossibleInteger = .some(100)    </code></pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;寒假开始了1周了，终于也是咸鱼了一周，在今天开始学点东西，既然之后要做ios开发的话，就打算学点swift。整个周期大概20天，先整体看一遍swift的语法，然后去leetcode刷题。因为是windows系统，所以这其中可能会有一些问题。不过只要有开头的话，后面慢慢来就行了。&lt;/p&gt;</summary>
    
    
    
    <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
    <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>B+树</title>
    <link href="http://yoursite.com/2019/12/10/B-%E6%A0%91/"/>
    <id>http://yoursite.com/2019/12/10/B-%E6%A0%91/</id>
    <published>2019-12-10T13:15:25.000Z</published>
    <updated>2019-12-22T01:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近需要完成一个构造数据库的索引的实验，实验要求使用B+树做索引结构，因为对于B+树不够了解，所以先复习一下B+树的特性在进行下一步。对于B+树，这篇文章讲的很好。<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/8729425.html</a></p><a id="more"></a> <h3 id="B-树结构特点"><a href="#B-树结构特点" class="headerlink" title="B+树结构特点"></a>B+树结构特点</h3><p>B+tree是应文件系统所需而产生的一种B树的变形树，一棵m阶的B+树的特点：1.有n棵子树的节点中含有n个关键字。2.所有的叶子节点中包含了全部的关键字信息，及指向含有这些关键字记录的指针，且叶子节点本身依关键字的大小自小到大顺序链接。 3.所有的非叶子节点可以堪称是索引部分，节点中仅含有其子树根结点中最大（或最小）关键字。4.B+树的有效内容均在叶子节点。所有叶子节点中有志向兄弟节点的指针5.B+树的头指针有两个，一个指向根节点，一个指向关键字最小的元素,因此B+树有两种遍历方式。从根节点开始随机查询。从最小关键字顺序查询。</p><h3 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h3><p>和其他树形结构一样，B+树也支持插入，删除，遍历等操作。在经过前面两周对B+树的了解后，我认为B+树中最难的应该是元素插入。相对简单的是元素遍历。当然这也是建立在B+树数据结构中具有良好的遍历字段的情况下的。作为同一种数据结构可以不断的修改内部的结构特点，根据实际需要，使得可以方便完成自己的需求。</p><p>现在先讲以下B+树的插入：首先假定B+树每一个节点中可以最多可以包含2m个元素，因此对于任意节点来说，不能少于m个元素。对于每一次插入元素，必须遍历b+树的叶子节点，因为叶子中存放的才是有效的元素，在非叶子节点中都是对于叶子节点的索引。这也使得b+树在节点有序的同时，所有叶子节点元素都是有序的。</p><p>元素插入分如下情况: 1.节点中元素个数满足m&lt;nodes&lt;2m-1,插入元素后直接返回。 2.节点元素有2m-1个，插入后由于节点满（这里可以根据实际情况决定最多放2m还是2m-1个）。需要进行节点分裂，节点分裂会产生新的节点，同时也会产生新的由父节点指向该节点的索引。此时需要从当前节点向根节点遍历，修改父节点的索引。</p><ul><li>eg1</li></ul><p><img src="/2019/12/10/B-树/insert1.png" alt="insert1"></p><p>在此时的树中55，则插入元素后直接返回。</p><ul><li>eg2<br>若在刚才的树中依次插入元素13，21，40，则会造成节点分裂叶子节点分开，同时更新父节点索引，如下图</li></ul><p><img src="/2019/12/10/B-树/insert2.png" alt="insert2"></p><p>如果不断插入元素导致非叶子节点也到达满的情况。按照叶子节点的分裂情况处理即可。</p><h3 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h3><p>B+树的删除就相对来说比较困难了，如果删除元素后节点数满足m&lt;nodes&lt;2m,则可以直接返回，否则需要进行修改。</p><p>B+树的删除分如下情况。 1.删除后节点元素个数满足m&lt;nodes&lt;2m,直接返回。但是如果删除的式节点中的第一个元素，则需要视情况更新索引。 2.删除后节点元素小于m，则考虑向左边或者右边借一个元素进行合并。 3.在2的条件下，左边叶子节点元素个数满足条件，则分一个给右边节点，同时因为元素的有序性，分给右边的元素占据第一个，所以需要更新当前节点索引。 4.在2的情况下，如果左节点不满足，则向右边节点借一个，如果右边节点满足，分出一个元素，同时需要更新右边节点的索引。 5. 如果3 4都不满足，则需要进行节点合并，与哪边合并都可以，此时需要删除父节点的一个索引。</p><p>总体来看，删除操作略微复杂。</p><ul><li>eg1</li></ul><p><img src="/2019/12/10/B-树/del1.png" alt="del1"></p><p>此时删除元素22后，可以直接返回</p><p><img src="/2019/12/10/B-树/del2.png" alt="del2"></p><ul><li>eg2<br>删除22后，删除15,结果如下。</li></ul><p><img src="/2019/12/10/B-树/del3.png" alt="del3"></p><p>此时需要借元素，同时更新索引</p><p><img src="/2019/12/10/B-树/del4.png" alt="del4"></p><ul><li>eg3</li></ul><p>现在删除元素7，则需要进行节点合并，由于删除的7式一个索引，则也需要更新索引。</p><p><img src="/2019/12/10/B-树/del5.png" alt="del5"></p><p>合并后如下：</p><p><img src="/2019/12/10/B-树/del6.png" alt="del6"></p><p>由于更新后的父节点只有一个索引不满足条件，则该节点也需要合并，最后如下</p><p><img src="/2019/12/10/B-树/del7.png" alt="del7"></p><h3 id="B-树的遍历"><a href="#B-树的遍历" class="headerlink" title="B+树的遍历"></a>B+树的遍历</h3><p>B+树可以分两种遍历方式，可以从根节点进行遍历，页可以根据需要，适当修改节点数据结构，直接从最左边叶子节点遍历，两种情况都比较简单，第一种是O(logn）的复杂度，第二种是O(n)的复杂度。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>B+树整体操作如上述，当遇到问题时，其实一种数据结构有时候并不是那么高深莫测，它只是通过某些变形而已，需要结合实际情况，考虑所学的基本知识进行变通。尤其是对基础知识牢固把握时很重要的。并没有很难得知识点，都是通过基础一点点得变化而来。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近需要完成一个构造数据库的索引的实验，实验要求使用B+树做索引结构，因为对于B+树不够了解，所以先复习一下B+树的特性在进行下一步。对于B+树，这篇文章讲的很好。&lt;a href=&quot;https://www.cnblogs.com/nullzx/p/8729425.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/nullzx/p/8729425.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/数据结构/"/>
    
    
    <category term="数据结构" scheme="http://yoursite.com/tags/数据结构/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学知识点整理（二）</title>
    <link href="http://yoursite.com/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2019-12-06T04:25:47.000Z</published>
    <updated>2020-01-14T08:11:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="造型技术"><a href="#造型技术" class="headerlink" title="造型技术"></a>造型技术</h3><h4 id="实体模型的三类表示"><a href="#实体模型的三类表示" class="headerlink" title="实体模型的三类表示"></a>实体模型的三类表示</h4><p> 边界表示：即用一组曲面来描述物体，这些曲面氛围内部和外部，边界表示具体又包括多边形表面模型和扫描表示两种。</p><p> 构造实体几何表示：它将实体表示成立方体，长方体，圆柱体，圆锥体等基本体素的组合，可以采用并交差等运算构造新的形体。</p><p> 空间分割表示：用来表示物体的内部性质，将包含物体的空间区域分成一组小的，非重叠的，连续实体。</p><a id="more"></a> <ul><li><p>边界表示最普遍的方式是多边形表面模型，使用一组包围物体内部的平面<strong>多边形</strong>描述物体。多边形的平面包括两个面，内侧面和外侧面。一般来说，法向量方向指向物体外部，当多边形顶点序列指定后，它满足右手定则。多边形网格可以有两种，三角形带或者四边形网格。（多边形的点多余三个，多边形可能不再同一个平面上）</p></li><li><p>扫描转换法：将空间中的一个点，一条边或一个面沿着某一路径扫描时，所形成的轨迹定义为一个一维的二维的或三维的实体。旋转扫描时一种常用扫描方式</p></li><li><p>粒子系统描述非规则造型：是一组分散，微小的物体，这些微小物理大小和形状随时间变化。使用粒子系统描绘活=火，爆炸，落叶，云雾，雪等景象和视觉效果。  粒子系统的两个要素：粒子本身的造型，粒子的运动方式。 生成过程：模拟多个粒子及其运动过程。要实现这种粒子效果，需要连续不断的产生新粒子，并且让旧粒子逐渐消亡。</p></li><li><p>分形几何，以非整数的形式填充空间的形态特征，具有自像性。特点：不规则，从远距离上看时处处不规则的。 自相似：不同尺度上看，图形的规则性是相同的。</p></li></ul><h3 id="观察与变换"><a href="#观察与变换" class="headerlink" title="观察与变换"></a>观察与变换</h3><p>在观察坐标系中的运动包括平移，旋转，比例，对称，错切。通过这些变换后可以产生新的图形。</p><ul><li><p>平移：将一个点从一个位置移动到另一个位置的重定位过程，不会产生形变的变换。</p></li><li><p>比例：对p点相对于坐标原点沿x轴放缩m倍，沿y放缩n倍。</p></li><li><p>旋转：将点p绕坐标原点转动一个角度得到一个新的点的过程。 </p></li><li><p>对称：将原图形关于对称轴变换后的图形。</p></li><li><p>错切：用于产生弹性物体的变形处理。</p></li></ul><p>齐次坐标的引入：方便多种变换的进行。</p><h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p>平行投影：投影中心在无穷远处，投影的图形就是平行投影。<br>透视投影：投影中心距离投影平面的距离是有限的就是透视投影。</p><h3 id="裁剪与屏幕映射"><a href="#裁剪与屏幕映射" class="headerlink" title="裁剪与屏幕映射"></a>裁剪与屏幕映射</h3><p>只有经过裁剪后在观察空间内部的物体才能被映射到屏幕上。映射到屏幕上还需要进行一定的平移，旋转的操作。因为观察坐标系的坐标位置和屏幕坐标系有一些的区别。屏幕映射在可编程管线中是固定部分，因此计算都由GPU完成。</p><h3 id="phong光照模型"><a href="#phong光照模型" class="headerlink" title="phong光照模型"></a>phong光照模型</h3><p>自然界中的光照是极其复杂的，为了进行模拟，进行了一定的简化，其中phong模型中的光照来源于三种光：环境光，漫反射光，镜面反射光。<br>1.环境光：模拟全局光照中间接光照的影响，即来自其他物体的反射光。2.漫反射光：模拟片段法向量与光源方向向量夹角间的关系，漫反射光使得物体上与光纤方向越接近的片段能从光源出获得更多亮度。3.镜面反射光：模拟模型表面上的两点，如果观察方向与光线方向间的夹角越小，表示受反射光影响越大。其效果就是使得我们能够看到高光点。 phong模型就是以上三种光的计算叠加，可以模拟现实中的光照。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;造型技术&quot;&gt;&lt;a href=&quot;#造型技术&quot; class=&quot;headerlink&quot; title=&quot;造型技术&quot;&gt;&lt;/a&gt;造型技术&lt;/h3&gt;&lt;h4 id=&quot;实体模型的三类表示&quot;&gt;&lt;a href=&quot;#实体模型的三类表示&quot; class=&quot;headerlink&quot; title=&quot;实体模型的三类表示&quot;&gt;&lt;/a&gt;实体模型的三类表示&lt;/h4&gt;&lt;p&gt; 边界表示：即用一组曲面来描述物体，这些曲面氛围内部和外部，边界表示具体又包括多边形表面模型和扫描表示两种。&lt;/p&gt;
&lt;p&gt; 构造实体几何表示：它将实体表示成立方体，长方体，圆柱体，圆锥体等基本体素的组合，可以采用并交差等运算构造新的形体。&lt;/p&gt;
&lt;p&gt; 空间分割表示：用来表示物体的内部性质，将包含物体的空间区域分成一组小的，非重叠的，连续实体。&lt;/p&gt;</summary>
    
    
    
    <category term="openGL" scheme="http://yoursite.com/categories/openGL/"/>
    
    
    <category term="openGL" scheme="http://yoursite.com/tags/openGL/"/>
    
  </entry>
  
</feed>
